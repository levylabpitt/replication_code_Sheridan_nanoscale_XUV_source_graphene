Variable BoxShape
Type integer
Section Mesh::Simulation Box
Description
 This  variable  decides  the  shape  of  the simulation box. The default is
 minimum  for  finite  systems and parallelepiped for periodic systems. Note
 that some incompatibilities apply: 
  *) Spherical or minimum mesh is not allowed for periodic systems. 
  *)  Cylindrical  mesh is not allowed for systems that are periodic in more
 than one dimension. 
  *) box_image is only allowed in 2D. 
Option sphere 1
 The  simulation  box  will  be a sphere of radius Radius. (In 2D, this is a
 circle.) 
Option cylinder 2
 The simulation box will be a cylinder with radius Radius and height (in the
 _x_-direction) of 2 Xlength. 
Option minimum 3
 The  simulation  box  will  be constructed by adding spheres created around
 each atom (or user-defined potential), of radius Radius. 
Option parallelepiped 4
 The simulation box will be a parallelepiped whose dimensions are taken from
 the variable Lsize. 
Option box_image 5
 The  simulation  box  will  be  defined  through  an  image, specified with
 BoxShapeImage.  White (RGB = 255,255,255) means that the point is contained
 in  the  simulation box, while any other color means that the point is out.
 The image will be scaled to fit Lsize, while its resolution will define the
 default Spacing. The actual box may be slightly larger than Lsize to ensure
 one grid point = one pixel for default Spacing. 
Option box_cgal 6
 The  simulation  box will be defined by a file read using the CGAL library.
 The file name needs to be specified with BoxCgalFile. 
 Lsize needs to be large enough to contain the shape defined in the file. 
Option user_defined 77
 The  shape  of  the  simulation  box  will  be  read  from  the  variable
 BoxShapeUsDef. 
END

Variable Radius
Type float
Section Mesh::Simulation Box
Description
 Defines the radius for BoxShape = sphere, 
 cylinder, or minimum. Must be a positive number. 
END

Variable Xlength
Default <tt>Radius</tt>
Type float
Section Mesh::Simulation Box
Description
 If BoxShape is cylinder, the total length of the cylinder is twice Xlength.
 Note  that  when PeriodicDimensions = 1, then the length of the cylinder is
 determined from the lattice vectors. 
END

Variable Lsize
Type block
Section Mesh::Simulation Box
Description
 If  BoxShape is parallelepiped, box_image, or user_defined, this is a block
 of the form: 

 %Lsize 
   sizex | sizey | sizez | ... 
 % 

 where the size* are half the lengths of the box in each direction. 

 The  number of columns must match the dimensionality of the calculation. If
 you want a cube you can also set Lsize as a single variable. 
END

Variable BoxShapeImage
Type string
Section Mesh::Simulation Box
Description
 Name  of  the  file that contains the image that defines the simulation box
 when BoxShape = box_image. No default. Will search in current directory and
 OCTOPUS-HOME/share/. 
END

Variable BoxShapeUsDef
Type string
Section Mesh::Simulation Box
Description
 Boolean  expression  that  defines  the interior of the simulation box. For
 example, 
 BoxShapeUsDef  =  "(sqrt(x^2+y^2)  <= 4) && z>-2 && z<2" defines a cylinder
 with axis parallel to the _z_-axis. 
END

Variable BoxCgalFile
Type string
Section Mesh::Simulation Box
Description
 Filename to be read in by the cgal library. It should describe a shape that
 is used for the simulation box 
END

Variable Displacement
Type float
Default 0.01 a.u.
Section Linear Response::Vibrational Modes
Description
 When calculating phonon properties by finite differences (CalculationMode =
 vib_modes, ResponseMethod = finite_differences), 
 Displacement  controls  how  much  the  atoms  are  to be moved in order to
 calculate the dynamical matrix. 
END

Variable GOCenter
Type logical
Default no
Section Calculation Modes::Geometry Optimization
Description
 (Experimental)  If  set  to  yes,  Octopus  centers  the  geometry at every
 optimization  step.  It  also  reduces  the  degrees  of  freedom  of  the
 optimization by using the translational invariance. 
END

Variable GOMethod
Type integer
Default fire
Section Calculation Modes::Geometry Optimization
Description
 Method by which the minimization is performed. For more information see the
 
 <a
 href=http://www.gnu.org/software/gsl/manual/html_node/Multidimensional-Minimization.html>
 GSL documentation</a>. 
Option steep 1
 Simple steepest descent. 
Option steep_native -1
 (Experimental) Non-gsl implementation of steepest descent. 
Option cg_fr 2
 Fletcher-Reeves  conjugate-gradient  algorithm.  The  conjugate-gradient
 algorithm  proceeds  as a succession of line minimizations. The sequence of
 search  directions is used to build up an approximation to the curvature of
 the function in the neighborhood of the minimum. 
Option cg_pr 3
 Polak-Ribiere conjugate-gradient algorithm. 
Option cg_bfgs 4
 Vector  Broyden-Fletcher-Goldfarb-Shanno  (BFGS)  conjugate-gradient
 algorithm.  It is a quasi-Newton method which builds up an approximation to
 the  second  derivatives  of  the function _f_ using the difference between
 successive gradient vectors. By combining the first and second derivatives,
 the  algorithm  is  able  to  take  Newton-type  steps towards the function
 minimum, assuming quadratic behavior in that region. 
Option cg_bfgs2 5
 The  bfgs2  version  of  this  minimizer  is  the  most  efficient  version
 available, and is a faithful implementation of the line minimization scheme
 described  in  Fletcher,  _Practical  Methods  of Optimization_, Algorithms
 2.6.2 and 2.6.4. 
Option simplex 6
 This  is  experimental, and in fact, *not* recommended unless you just want
 to  fool around. It is the Nead-Melder simplex algorithm, as implemented in
 the  GNU  Scientific  Library  (GSL). It does not make use of the gradients
 (_i.e._,  the  forces) which makes it less efficient than other schemes. It
 is included here for completeness, since it is free. 
Option fire 8
 The  FIRE  algorithm.  See  also  GOFireMass  and GOFireIntegrator. Ref: E.
 Bitzek,  P.  Koskinen,  F.  Gahler, M. Moseler, and P. Gumbsch, _Phys. Rev.
 Lett._ *97*, 170201 (2006). 
END

Variable GOTolerance
Type float
Default 0.001 H/b (0.051 eV/A)
Section Calculation Modes::Geometry Optimization
Description
 Convergence  criterion,  for  stopping the minimization. In units of force;
 minimization  is  stopped  when  all  forces  on ions are smaller than this
 criterion, or the 
 GOMinimumMove is satisfied. If GOTolerance < 0, this criterion is ignored. 
END

Variable GOMinimumMove
Type float
Section Calculation Modes::Geometry Optimization
Description
 Convergence  criterion,  for stopping the minimization. In units of length;
 minimization  is  stopped  when  the coordinates of all species change less
 than GOMinimumMove, or the 
 GOTolerance criterion is satisfied. If GOMinimumMove < 0, this criterion is
 ignored.  Default  is -1, except 0.001 b with GOMethod = simplex. Note that
 if  you  use  GOMethod  =  simplex,  then  you  must  supply  a  non-zero
 GOMinimumMove. 
END

Variable GOStep
Type float
Section Calculation Modes::Geometry Optimization
Description
 Initial  step  for  the geometry optimizer. The default is 0.5. WARNING: in
 some  weird  units.  For  the  FIRE minimizer, default value is 0.1 fs, and
 corresponds to the initial time-step for the MD. 
END

Variable GOLineTol
Type float
Default 0.1
Section Calculation Modes::Geometry Optimization
Description
 Tolerance  for  line-minimization. Applies only to GSL methods that use the
 forces. WARNING: in some weird units. 
END

Variable GOMaxIter
Type integer
Default 200
Section Calculation Modes::Geometry Optimization
Description
 Even  if  the convergence criterion is not satisfied, the minimization will
 stop after this number of iterations. 
END

Variable GOFireMass
Type float
Default 1.0 amu
Section Calculation Modes::Geometry Optimization
Description
 The  Fire  algorithm  (GOMethod = fire) assumes that all degrees of freedom
 are  comparable.  All the velocities should be on the same scale, which for
 heteronuclear  systems  can  be  roughly  achieved  by setting all the atom
 masses  equal, to the value specified by this variable. By default the mass
 of  a proton is selected (1 amu). However, a selection of GOFireMass = 0.01
 can,  in  manys  systems,  speed up the geometry optimization procedure. If
 GOFireMass <= 0, the masses of each species will be used. 
END

Variable GOFireIntegrator
Type integer
Default verlet
Section Calculation Modes::Geometry Optimization
Description
 The  Fire  algorithm (GOMethod = fire) uses a molecular dynamics integrator
 to compute new geometries and velocities. Currently, two integrator schemes
 can be selected 
Option verlet 1
 The Velocity Verlet algorithm. 
Option euler 0
 The Euler method. 
END

Variable GOObjective
Type integer
Default minimize_energy
Section Calculation Modes::Geometry Optimization
Description
 This  rather  esoteric option allows one to choose which objective function
 to  minimize  during  a geometry minimization. The use of this variable may
 lead to inconsistencies, so please make sure you know what you are doing. 
Option minimize_energy 1
 Use the total energy as objective function. 
Option minimize_forces 2
 Use  \sqrt{\sum_i \left| f_i \right|^2} as objective function. Note that in
 this  case  one  still  uses  the  forces  as the gradient of the objective
 function.  This  is,  of course, inconsistent, and may lead to very strange
 behavior. 
END

Variable XYZGOConstrains
Type string
Section Calculation Modes::Geometry Optimization
Description
 Octopus  will  try to read the coordinate-dependent constrains from the XYZ
 file  specified  by the variable XYZGOConstrains. Note: It is important for
 the  contrains  to maintain the ordering in which the atoms were defined in
 the  coordinates specifications. Moreover, constrains impose fixed absolute
 coordinates, therefore constrains are not compatible with GOCenter = yes 
END

Variable XSFGOConstrains
Type string
Section Calculation Modes::Geometry Optimization
Description
 Like XYZGOConstrains but in XCrySDen format, as in XSFCoordinates. 
END

Variable PDBGOConstrains
Type string
Section Calculation Modes::Geometry Optimization
Description
 Like XYZGOConstrains but in PDB format, as in PDBCoordinates. 
END

Variable GOConstrains
Type block
Section Calculation Modes::Geometry Optimization
Description
 If  XYZGOConstrains,  PDBConstrains,  and  XSFGOConstrains are not present,
 Octopus  will  try  to  fetch the geometry optimization contrains from this
 block.  If  this block is not present, Octopus will not set any constrains.
 The format of this block can be illustrated by this example: 

 %GOConstrains 
   'C' | 1 | 0 | 0 
   'O' |  1 | 0 | 0 
 % 

 Coordinates  with  a  constrain  value  of  0  will  be  optimized,  while
 coordinates with a constrain different from zero will be kept fixed. So, in
 this  example  the  x  coordinates  of both atoms will remain fixed and the
 distance between the two atoms along the x axis will be constant. 

 Note:  It is important for the constrains to maintain the ordering in which
 the  atoms  were  defined  in  the  coordinates  specifications.  Moreover,
 constrains  impose fixed absolute coordinates, therefore constrains are not
 compatible with GOCenter = yes 
END

Variable EMStaticElectricField
Type float
Default 0.01 a.u.
Section Linear Response::Static Polarization
Description
 Magnitude  of  the  static  electric  field  used  to  calculate the static
 polarizability, if ResponseMethod = finite_differences. 
END

Variable EMStartDensityIsZeroField
Type logical
Default true
Section Linear Response::Static Polarization
Description
 Use  the  charge  density  from  the zero-field calculation as the starting
 density  for  SCF  calculations with applied fields. For small fields, this
 will  be fastest. If there is trouble converging with larger fields, set to
 false,  to  initialize  the  calculation  for  each  field from scratch, as
 specified  by  the  LCAO  variables.  Only  applies  if  ResponseMethod  =
 finite_differences. 
END

Variable EMCalcDiagonalField
Type logical
Default true
Section Linear Response::Static Polarization
Description
 Calculate  _yz_-field  for  \beta_{xyz}  hyperpolarizability,  which  is
 sometimes  harder  to  converge.  Only  applies  if  ResponseMethod  =
 finite_differences. 
END

Variable EMWriteRestartDensities
Type logical
Default true
Section Linear Response::Static Polarization
Description
 Write  density  after  each  calculation  for restart, rather than just the
 resulting  electronic  dipole  moment.  Only  applies  if  ResponseMethod =
 finite_differences.  Restarting  from calculations at smaller fields can be
 helpful if there are convergence problems. 
END

Variable EMVerbose
Type logical
Default false
Section Linear Response::Static Polarization
Description
 Write full SCF output. Only applies if ResponseMethod = finite_differences.
 
END

Variable Systems
Type block
Section System
Description
 List  of  systems that will be treated in the calculation. The first column
 should  be a string containing the system name. The second column should be
 the system type. See below for a list of available system types. 
Option electronic 1
 An electronic system. (not fully implemented yet) 
Option maxwell 2
 A maxwell system. 
Option classical_particle 3
 A classical particle. Used for testing purposes only. 
Option charged_particle 4
 A charged classical particle. 
Option dftbplus 5
 A DFTB+ system 
Option linear_medium 6
 A linear medium for classical electrodynamics. 
Option matter 7
 A matter system containing electrons and classical ions. 
Option dispersive_medium 8
 (Experimental) A dispersive medium for classical electrodynamics. 
Option multisystem 9
 A system containing other systems. 
END

Variable ReportMemory
Type logical
Default no
Section Execution::Debug
Description
 If  true, after each SCF iteration Octopus will print information about the
 memory  the code is using. The quantity reported is an approximation to the
 size  of  the  heap  and generally it is a lower bound to the actual memory
 Octopus is using. 
END

Variable CalculationMode
Type integer
Default gs
Section Calculation Modes
Description
 Decides what kind of calculation is to be performed. 
Option gs 01
 Calculation of the ground state. 
Option unocc 02
 Calculation  of  unoccupied/virtual  KS  states.  Can  also  be  used for a
 non-self-consistent  calculation  of  states  at  arbitrary  k-points,  if
 density.obf from gs is provided in the restart/gs directory. 
Option td 03
 Time-dependent calculation (experimental for periodic systems). 
Option go 05
 Optimization of the geometry. 
Option opt_control 07
 Optimal control. 
Option em_resp 08
 Calculation  of the electromagnetic response: electric polarizabilities and
 hyperpolarizabilities  and  magnetic  susceptibilities  (experimental  for
 periodic systems). 
Option casida 09
 Excitations via Casida linear-response TDDFT; for finite systems only. 
Option vdw 11
 Calculate van der Waals coefficients. 
Option vib_modes 12
 Calculation of the vibrational modes. 
Option one_shot 14
 Obsolete. Use gs with MaximumIter = 0 instead. 
Option kdotp 15
 Calculation  of  effective  masses  by  \vec{k}  \cdot \vec{p} perturbation
 theory (experimental). 
Option dummy 17
 This  calculation  mode  does  nothing.  Useful  for debugging, testing and
 benchmarking. 
Option invert_ks 18
 Invert the Kohn-Sham equations (experimental). 
Option test 19
Option recipe 99
 Prints out a tasty recipe. 
END

Variable CasidaTheoryLevel
Type flag
Section Linear Response::Casida
Default <tt>eps_diff + petersilka + lrtddft_casida</tt>
Description
 Choose which electron-hole matrix-based theory levels to use in calculating
 excitation  energies.  More  than  one may be used to take advantage of the
 significant commonality between the calculations. 
 variational  and  lrttdft_casida are not usable with complex wavefunctions.
 Note the restart data saved by each theory level is compatible with all the
 others. 
Option eps_diff 1
 Difference of eigenvalues, _i.e._ independent-particle approximation. 
Option petersilka 2
 The  Petersilka approximation uses only elements of the Tamm-Dancoff matrix
 between degenerate transitions (if no degeneracy, this is just the diagonal
 elements).  Also called the "single-pole" approximation. This is acceptable
 if  there  is  little  mixing  between  single-particle transitions. Ref: M
 Petersilka,  UJ  Gossmann,  and  EKU  Gross,  _Phys. Rev. Lett._ *76*, 1212
 (1996);  T  Grabo,  M  Petersilka,and  EKU  Gross, _Theochem_ *501-502* 353
 (2000). 
Option tamm_dancoff 4
 The  Tamm-Dancoff  approximation  uses only occupied-unoccupied transitions
 and  not  unoccupied-occupied transitions. Ref: S Hirata and M Head-Gordon,
 _Chem. Phys. Lett._ *314*, 291 (1999). 
Option variational 8
 Second-order constrained variational theory CV(2)-DFT. Only applies to real
 wavefunctions.  Ref:  T  Ziegler,  M  Seth, M Krykunov, J Autschbach, and F
 Wang, 
 _J. Chem. Phys._ *130*, 154102 (2009). 
Option lrtddft_casida 16
 The  full  Casida  method.  Only  applies  to  real  wavefunctions.  Ref: C
 Jamorski,  ME  Casida,  and DR Salahub, _J. Chem. Phys._ *104*, 5134 (1996)
 and  ME  Casida,  "Time-dependent  density  functional  response theory for
 molecules,"  in  _Recent Advances in Density Functional Methods_, edited by
 DE  Chong,  vol.  1  of  _Recent  Advances in Computational Chemistry_, pp.
 155-192 (World Scientific, Singapore, 1995). 
END

Variable CasidaTransitionDensities
Type string
Section Linear Response::Casida
Default write none
Description
 Specifies which transition densities are to be calculated and written down.
 The  transition  density  for  the many-body state _n_ will be written to a
 file called 
 rho_0n prefixed by the theory level. Format is set by OutputFormat. 

 This  variable  is  a  string  in  list  form,  _i.e._  expressions such as
 "1,2-5,8-15" are valid. 
END

Variable CasidaMomentumTransfer
Type block
Section Linear Response::Casida
Default 0
Description
 Momentum-transfer  vector  for  the  calculation  of  the dynamic structure
 factor.  When  this  variable  is  set, the transition rates are determined
 using an exponential operator instead of the normal dipole one. 
END

Variable CasidaQuadratureOrder
Type integer
Section Linear Response::Casida
Default 5
Description
 Only  applies  if CasidaMomentumTransfer is nonzero. Directionally averaged
 dynamic structure factor is calculated by averaging over the results from a
 set  of  \vec{q}-vectors.  The  vectors  are generated using Gauss-Legendre
 quadrature  scheme  [see _e.g._ K. Atkinson, _J. Austral. Math. Soc._ *23*,
 332 (1982)], and this variable determines the order of the scheme. 
END

Variable CasidaCalcTriplet
Type logical
Section Linear Response::Casida
Default false
Description
 For  a  non-spin-polarized ground state, singlet or triplet excitations can
 be  calculated  using  different  matrix  elements. Default is to calculate
 singlets. This variable has no effect for a spin-polarized calculation. 
END

Variable CasidaHermitianConjugate
Type logical
Section Linear Response::Casida
Default false
Description
 The  Casida  matrix  is  Hermitian,  so  it  should  not  matter whether we
 calculate  the  upper  or  lower diagonal. Numerical issues may cause small
 differences however. Use this variable to calculate the Hermitian conjugate
 of the usual matrix, for testing. 
END

Variable CasidaDistributedMatrix
Type logical
Section Linear Response::Casida
Default false
Description
 Large  matrices  with  more than a few thousand rows and columns usually do
 not  fit  into  the  memory of one processor anymore. With this option, the
 Casida  matrix is distributed in block-cyclic fashion over all cores in the
 ParOther  group. The diagonalization is done in parallel using ScaLAPACK or
 ELPA,  if  available.  For very large matrices (>100000), only the ParOther
 strategy  should be used because the diagonalization dominates the run time
 of the computation. 
END

Variable CasidaWriteDistributedMatrix
Type logical
Section Linear Response::Casida
Default false
Description
 Set to true to write out the full distributed Casida matrix to a file using
 MPI-IO. 
END

Variable CasidaParallelEigensolver
Type integer
Section Linear Response::Casida
Description
 Choose  library  to use for solving the parallel eigenproblem of the Casida
 problem.  This  options  is  only  relevant if a distributed matrix is used
 (CasidaDistributedMatrix=true). By default, elpa is chosen if available. 
Option casida_elpa 1
 Use ELPA library as parallel eigensolver 
Option casida_scalapack 2
 Use Scalapack as parallel eigensolver 
END

Variable CasidaPrintExcitations
Type string
Section Linear Response::Casida
Default write all
Description
 Specifies which excitations are written at the end of the calculation. 

 This  variable  is  a  string  in  list  form,  _i.e._  expressions such as
 "1,2-5,8-15" are valid. 
END

Variable CasidaWeightThreshold
Type float
Section Linear Response::Casida
Default -1.
Description
 Specifies  the  threshold  value  for  which the individual excitations are
 printed.  i.e. juste-h pairs with weight larger than this threshold will be
 printed. 

 If a negative value (default) is set, all coefficients will be printed. For
 many case, a 0.01 value is a valid option. 
END

Variable CasidaCalcForces
Type logical
Section Linear Response::Casida
Default false
Description
 (Experimental)  Enable  calculation  of  excited-state  forces.  Requires
 previous vib_modes calculation. 
END

Variable CasidaCalcForcesKernel
Type logical
Section Linear Response::Casida
Default true
Description
 If  false,  the  derivative  of  the  kernel  will  not  be included in the
 excited-state force calculation. 
END

Variable CasidaCalcForcesSCF
Type logical
Section Linear Response::Casida
Default false
Description
 If  true,  the  ground-state  forces  will be included in the excited-state
 forces,  so  they are total forces. If false, the excited-state forces that
 are produced are only the gradients of the excitation energy. 
END

Variable InvertKSTargetDensity
Type string
Default <tt>target_density.dat</tt>
Section Calculation Modes::Invert KS
Description
 Name  of  the  file  that  contains  the  density used as the target in the
 inversion of the KS equations. 
END

Variable TestMode
Type integer
Default hartree
Section Calculation Modes::Test
Description
 Decides what kind of test should be performed. 
Option hartree 1
 Tests the Poisson solvers used to calculate the Hartree potential. 
Option derivatives 2
 Tests and benchmarks the implementation of the finite-difference operators,
 used to calculate derivatives. 
Option orthogonalization 3
 Tests the implementation of the orthogonalization routines. 
Option interpolation 4
 Test the interpolation routines. 
Option ion_interaction 5
 Tests the ion-ion interaction routines. 
Option projector 6
 Tests  the  code  that applies the nonlocal part of the pseudopotentials in
 case of spin-orbit coupling 
Option dft_u 7
 Tests the DFT+U part of the code for projections on the basis. 
Option hamiltonian_apply 8
 Tests the application of the Hamiltonian, or a part of it 
Option density_calc 9
 Calculation of the density. 
Option exp_apply 10
 Tests the exponential of the Hamiltonian 
Option boundaries 11
 Tests the boundaries conditions 
Option subspace_diag 12
 Tests the subspace diagonalization 
Option batch_ops 13
 Tests the batch operations 
Option clock 18
 Tests for clock 
Option linear_solver 19
 Tests the linear solvers 
Option cgal 20
 Tests for cgal interface 
Option dense_eigensolver 21
 Tests for dense eigensolvers (especially parallel ones) 
Option grid_interpolation 22
 Tests for grid interpolation and multigrid methods. 
Option iihash 23
 Tests for the integer-integer hash table. 
Option sihash 24
 Tests for the string-integer hash table. 
Option sphash 25
 Tests for the string-polymorphic hash table. 
Option mpiwrappers 26
 Tests for the MPI wrappers with large integer displacements. 
Option regridding 27
 Tests the regridding between two different grids. 
Option helmholtz_decomposition 28
 Test for the Helmholtz decomposition subroutines 
Option vecpot_analytical 29
 Tests analytically the vector potential from B field. 
END

Variable TestType
Type integer
Default all
Section Calculation Modes::Test
Description
 Decides on what type of values the test should be performed. 
Option real 1
 Test for double-precision real functions. 
Option complex 2
Option all 3
 Tests for double-precision real and complex functions. 
END

Variable TestRepetitions
Type integer
Default 1
Section Calculation Modes::Test
Description
 This  variable  controls  the  behavior  of  oct-test  for  performance
 benchmarking purposes. It sets the number of times the computational kernel
 of a test will be executed, in order to provide more accurate timings. 

 Currently this variable is used by the hartree_test, 
 derivatives, and projector tests. 
END

Variable TestMinBlockSize
Type integer
Default 1
Section Calculation Modes::Test
Description
 Some  tests  can  work  with  multiple blocksizes, in this case of range of
 blocksizes  will  be  tested.  This  variable  sets the lower bound of that
 range. 

 Currently this variable is only used by the derivatives test. 
END

Variable TestMaxBlockSize
Type integer
Default 128
Section Calculation Modes::Test
Description
 Some  tests  can  work  with  multiple blocksizes, in this case of range of
 blocksizes  will  be  tested.  This  variable  sets the lower bound of that
 range. 

 Currently this variable is only used by the derivatives test. 
END

Variable TestHamiltonianApply
Type integer
Default term_all
Section Calculation Modes::Test
Description
 Decides which part of the Hamiltonian is applied. 
Option term_all 0
 Apply the full Hamiltonian. 
Option term_kinetic 1
 Apply only the kinetic operator 
Option term_local_potential 2
 Apply only the local potential. 
Option term_non_local_potential 4
 Apply only the non_local potential. 
END

Variable TestBatchOps
Type flag
Default ops_axpy + ops_scal + ops_nrm2
Section Calculation Modes::Test
Description
 Decides which part of the Hamiltonian is applied. 
Option ops_axpy bit(1)
 Tests batch_axpy operation 
Option ops_scal bit(2)
 Tests batch_scal operation 
Option ops_nrm2 bit(3)
 Tests batch_nrm2 operation 
Option ops_dotp_matrix bit(4)
 Tests X(mesh_batch_dotp_matrix) 
Option ops_dotp_self bit(5)
 Tests X(mesh_batch_dotp_self) 
Option ops_dotp_vector bit(6)
 Tests X(mesh_batch_dotp_vector) 
END

Variable TestVectorPotentialType
Type integer
Default bounded
Section Calculation Modes::Test
Description
 Select  whether bounded or unbounded type will be used for vector potential
 tests 
Option bounded 1
 Analytical Vector Potential formulation is bounded by spatial gaussian 
Option unbounded 2
 Analytical Vector Potential is not bounded 
END

Variable ResponseMethod
Type integer
Default sternheimer
Section Linear Response
Description
 Some  response  properties  can be calculated either via Sternheimer linear
 response  or  by  using  finite  differences.  You can use this variable to
 select  how  you  want  them  to  be  calculated, it applies to em_resp and
 vib_modes  calculation  modes.  By default, the Sternheimer linear-response
 technique is used. 
Option sternheimer 1
 The  linear  response  is obtained by solving a self-consistent Sternheimer
 equation for the variation of the orbitals. This is the recommended method.
 
Option finite_differences 2
 Properties  are calculated as a finite-differences derivative of the energy
 obtained  by  several  ground-state  calculations.  This  method,  slow and
 limited  only  to  static response, is kept mainly because it is simple and
 useful for testing purposes. 
END

Variable FromScratch
Type logical
Default false
Section Execution
Description
 When  this variable is set to true, Octopus will perform a calculation from
 the beginning, without looking for restart information. 
END

Variable RegularizationFunction
Type integer
Default COS2
Section Maxwell
Description
 The  current  arising  from charged point particles must be mapped onto the
 Maxwell  propagation  grid.  This  requires  a  smearing  or regularization
 function  $\phi(\mathbf{r})$  attached  to  each  particle  position
 $\mathbf{r}_i$ with user defined cutoff width, $\sigma$ 
Option COS2 1
 $\phi(r)=\text{cos}^2(\frac{\pi}{2}\frac{|\mathbf{r}-\mathbf{r}_i|}{\sigma})$
 if $|\mahtbf{r}-\mathbf{r}_i|<\sigma$, and 0 otherwise. 
END

Variable RegularizationFunctionWidth
Type float
Default 2
Section Maxwell
Description
 The  current  arising  from charged point particles must be mapped onto the
 Maxwell  propagation  grid.  This  requires  a  smearing  or regularization
 function  $\phi(\mathbf{r})$  attached  to  each  particle  position
 $\mathbf{r}_i$  with  user  defined  cutoff  width,  $\sigma$.  Default  2
 bohrradii 
END

Variable Interactions
Type block
Section System
Description
 This  input  option controls the interactions between systems. It basically
 allows  to select which systems will interact with another system through a
 given interaction type. The format of the block is the following: 

 %Namespace.Interactions   interaction_type | interaction_mode | ... % 

 Here is an example to better understand how this works: 

 %SystemA.Interactions   gravity | all_except | "SystemB" % 

 This  means  that  SystemA  and  all  the  systems  that belong to the same
 namespace (i.e., all its subsystems) will interact through gravity with all
 interaction partners that are also able to interact through gravity, except
 with  SystemB.  Note  that  the  opposite  is not true so, although clearly
 unphysical,  this  will  not  prevent SystemB from feeling the gravity from
 SystemA (in Octopus the interactions are always one-sided). 

 NB: Each interaction type should only appear once in the block. Any further
 instances beyond the first will be ignored. 

 Available modes and interaction types: 
Option no_partners -1
 (interaction mode) Do not interact with any partner. 
Option all_partners -2
 (interaction mode) Interact with all available partners. 
Option only_partners -3
 (interaction  mode)  Interact  only with some specified partners. A list of
 partner names must be given. 
Option all_except -4
 (interaction  mode)  Interact  with all available partners except with some
 specified partners. A list of partner names to exclude must be given. 
Option gravity 1
 (interaction type) Gravity interaction between two masses. 
Option lorentz_force 2
 (interaction  type)  Lorentz  force  resulting from an EM field acting on a
 moving charge. 
Option coulomb_force 3
 (interaction type) Coulomb force between two charged particles. 
Option linear_medium_to_em_field 4
 (interaction type) Linear medium for propagation of EM fields. 
Option current_to_mxll_field 5
 (interaction  type)  Drude  dispersive  linear medium for propagation of EM
 fields. 
Option maxwell_field_to_medium 6
 (interaction type) Electric field resulting from the Maxwell solver. 
END

Variable StaticExternalPotentials
Type block
Section System
Description
 An  static  external  potential  is  a  model  potential added to the local
 potential of the Hamiltonian 

 The format of this block is the following: The first field defines the type
 of species (the valid options are detailed below). 

 Then  a list of parameters follows. The parameters are specified by a first
 field  with the parameter name and the field that follows with the value of
 the  parameter.  Some  parameters  are  specific to a certain species while
 others  are  accepted  by  all  species.  These  are mass, max_spacing, and
 min_radius. 

 These are examples of possible species: 

 %ExternalPotential 
    potential_user_defined | potential_formula | "1/2*r^2" 
 % 
Option potential_from_file  -202
 The  potential  is  read  from  a  file. Accepted file formats, detected by
 extension: obf, ncdf and csv. 
Option potential_user_defined -201
 Species  with  user-defined  potential.  The  potential  for the species is
 defined by the formula given by the potential_formula parameter. 
Option potential_charge_density -203
 The  potential  for this species is created from the distribution of charge
 given by the density_formula parameter. 
Option file -10010
 The path for the file that describes the species. 
Option potential_formula -10012
 Mathematical  expression  that  defines  the  potential  for
 species_user_defined.  You  can  use  any  of  the  _x_,  _y_,  _z_  or _r_
 variables. 
Option density_formula -10013
 Mathematical  expression  that  defines  the  charge  density  for
 species_charge_density.  You  can  use  any  of  the  _x_,  _y_, _z_ or _r_
 variables. 
END

Variable StaticMagneticField
Type block
Section Hamiltonian
Description
 A  static constant magnetic field may be added to the usual Hamiltonian, by
 setting the block StaticMagneticField. The three possible components of the
 block  (which  should  only  have one line) are the three components of the
 magnetic  field  vector.  Note that if you are running the code in 1D mode,
 this will not work, and if you are running the code in 2D mode the magnetic
 field  will  have to be in the _z_-direction, so that the first two columns
 should be zero. Possible in periodic system only in these cases: 2D system,
 1D  periodic,  with  StaticMagneticField2DGauge  =  linear_y; 3D system, 1D
 periodic,  field  is  zero  in  _y_-  and  _z_-directions  (given currently
 implemented gauges). 

 The  magnetic field should always be entered in atomic units, regardless of
 the  Units variable. Note that we use the "Gaussian" system meaning 1 au[B]
 =  2.350517568\times 10^9 Gauss, which corresponds to 
 2.3505175678\times 10^5 Tesla. 
END

Variable StaticMagneticField2DGauge
Type integer
Default linear_xy
Section Hamiltonian
Description
 The gauge of the static vector potential A when a magnetic field 
 B = \left( 0, 0, B_z \right) is applied to a 2D-system. 
Option linear_xy 0
 Linear  gauge  with  A  = \frac{1}{2c} \left( -y, x \right) B_z. (Cannot be
 used for periodic systems.) 
Option linear_y 1
 Linear gauge with A = \frac{1}{c} \left( -y, 0 \right) B_z. Can be used for
 PeriodicDimensions = 1 but not PeriodicDimensions = 2. 
END

Variable StaticElectricField
Type block
Default 0
Section Hamiltonian
Description
 A  static constant electric field may be added to the usual Hamiltonian, by
 setting the block StaticElectricField. The three possible components of the
 block  (which  should  only  have one line) are the three components of the
 electric field vector. It can be applied in a periodic direction of a large
 supercell via the single-point Berry phase. 
END

Variable RDMTolerance
Type float
Default 1e-7 Ha
Section SCF::RDMFT
Description
 Convergence  criterion  for  stopping  the occupation numbers minimization.
 Minimization  is  stopped  when  all  derivatives  of  the energy wrt. each
 occupation  number  are  smaller  than  this  criterion.  The bisection for
 finding  the  correct  mu  that  is  needed  for  the  occupation  number
 minimization also stops according to this criterion. 
END

Variable RDMToleranceFO
Type float
Default 1e-4 Ha
Section SCF::RDMFT
Description
 Convergence  criterion  for stopping the diagonalization of the Fock matrix
 in  the Piris method. Orbital minimization is stopped when all off-diagonal
 ellements of the Fock matrix are smaller than this criterion. 
END

Variable RDMConvEner
Type float
Default 1e-6 Ha
Section SCF::RDMFT
Description
 Convergence  criterion  for stopping the overall minimization of the energy
 with  respect  to  occupation numbers and the orbitals. The minimization of
 the  energy  stops  when the total energy difference between two subsequent
 minimizations  of the energy with respect to the occupation numbers and the
 orbitals  is  smaller  than  this  criterion.  It  is also used to exit the
 orbital minimization. 
END

Variable RDMBasis
Type logical
Default yes
Section SCF::RDMFT
Description
 If  true,  all  the  energy terms and corresponding derivatives involved in
 RDMFT  will  not  be calculated on the grid but on the basis of the initial
 orbitals 
END

Variable RDMHartreeFock
Type logical
Default no
Section SCF::RDMFT
Description
 If  true,  the  code  simulates  a HF calculation, by omitting the occ.num.
 optimization can be used for test reasons 
END

Variable MaximumIter
Type integer
Default 200
Section SCF::Convergence
Description
 Maximum  number  of  SCF iterations. The code will stop even if convergence
 has  not  been  achieved. -1 means unlimited. 0 means just do LCAO (or read
 from  restart),  compute  the  eigenvalues  and  energy,  and stop, without
 updating the wavefunctions or density. 

 If  convergence  criteria  are  set,  the  SCF loop will only stop once the
 criteria are fulfilled for two consecutive iterations. 

 Note  that  this  variable  is  also  used  in  the  section  Calculation
 Modes::Unoccupied  States,  where it denotes the maximum number of calls of
 the eigensolver. In this context, the default value is 50. 
END

Variable ConvEigenError
Type logical
Default false
Section SCF::Convergence
Description
 If true, the calculation will not be considered converged unless all states
 have individual errors less than EigensolverTolerance. 

 If this criterion is used, the SCF loop will only stop once it is fulfilled
 for two consecutive iterations. 
END

Variable MixField
Type integer
Section SCF::Mixing
Description
 Selects  what should be mixed during the SCF cycle. Note that currently the
 exact-exchange  part of hybrid functionals is not mixed at all, which would
 require  wavefunction-mixing,  not  yet  implemented.  This  may  lead  to
 instabilities  in  the  SCF  cycle,  so  starting  from a converged LDA/GGA
 calculation  is  recommended for hybrid functionals. The default depends on
 the TheoryLevel and the exchange-correlation potential used. 
Option none 0
 No mixing is done. This is the default for independent particles. 
Option potential 1
 The Kohn-Sham potential is mixed. This is the default for other cases. 
Option density 2
 Mix the density. 
Option states 3
 (Experimental) Mix the states. In this case, the mixing is always linear. 
END

Variable SCFinLCAO
Type logical
Default no
Section SCF
Description
 Performs  the  SCF  cycle  with  the  calculation  restricted  to  the LCAO
 subspace.  This  may be useful for systems with convergence problems (first
 do a calculation within the LCAO subspace, then restart from that point for
 an unrestricted calculation). 
END

Variable SCFCalculateForces
Type logical
Section SCF
Description
 This variable controls whether the forces on the ions are calculated at the
 end  of  a self-consistent iteration. The default is yes, unless the system
 only has user-defined species. 
END

Variable SCFCalculateStress
Type logical
Section SCF
Description
 This  variable  controls whether the stress on the lattice is calculated at
 the end of a self-consistent iteration. The default is no. 
END

Variable SCFCalculateDipole
Type logical
Section SCF
Description
 This  variable  controls  whether  the dipole is calculated at the end of a
 self-consistent  iteration.  For  finite  systems  the  default is yes. For
 periodic  systems  the  default  is  no,  unless an electric field is being
 applied  in  a  periodic  direction.  The  single-point  Berry`s  phase
 approximation  is  used  for periodic directions. Ref: E Yaschenko, L Fu, L
 Resca, and R Resta, _Phys. Rev. B_ *58*, 1222-1229 (1998). 
END

Variable SCFCalculatePartialCharges
Type logical
Default no
Section SCF
Description
 (Experimental)  This  variable  controls  whether  partial  charges  are
 calculated at the end of a self-consistent iteration. 
END

Variable LocalMagneticMomentsSphereRadius
Type float
Section Output
Description
 The  local magnetic moments are calculated by integrating the magnetization
 density  in  spheres  centered around each atom. This variable controls the
 radius of the spheres. The default is half the minimum distance between two
 atoms  in the input coordinates, or 100 a.u. if there is only one atom (for
 isolated systems). 
END

Variable UnoccShowOccStates
Type logical
Default false
Section Calculation Modes::Unoccupied States
Description
 If  true,  the convergence for the occupied states will be shown too in the
 output.  This  is  useful  for  testing,  or if the occupied states fail to
 converge.  It  will  be  enabled  automatically if only occupied states are
 being calculated. 
END

Variable UnoccUseTD
Type logical
Default no
Section Calculation Modes::Unoccupied States
Description
 If true, Octopus will use the density and states from the restart/td folder
 to compute the bandstructure, instead of the restart/gs ones. 
END

Variable ConvEnergy
Type float
Default 0.0
Section SCF::Convergence
Description
 Stop  the  SCF  when  the  magnitude  of change in energy during at one SCF
 iteration is smaller than this value. 

A zero value (the default) means do not use this criterion.

 If this criterion is used, the SCF loop will only stop once it is fulfilled
 for two consecutive iterations. 
END

Variable ConvAbsDens
Type float
Default 0.0
Section SCF::Convergence
Description
 Absolute convergence of the density: 

 \varepsilon  =  \int {\rm d}^3r \left| \rho^{out}(\bf r) -\rho^{inp}(\bf r)
 \right|. 

 A zero value (the default) means do not use this criterion. 

 If this criterion is used, the SCF loop will only stop once it is fulfilled
 for two consecutive iterations. 
END

Variable ConvRelDens
Type float
Default 1e-6
Section SCF::Convergence
Description
 Relative convergence of the density: 

 \varepsilon = \frac{1}{N} \mathrm{ConvAbsDens}. 

 _N_  is the total number of electrons in the problem. A zero value means do
 not use this criterion. 

 If you reduce this value, you should also reduce 
 EigensolverTolerance to a value of roughly 1/10 of 
 ConvRelDens to avoid convergence problems. 

 If this criterion is used, the SCF loop will only stop once it is fulfilled
 for two consecutive iterations. 
END

Variable ConvAbsEv
Type float
Default 0.0
Section SCF::Convergence
Description
 Absolute convergence of the sum of the eigenvalues: 

  \varepsilon  =  \left|  \sum_{j=1}^{N_{occ}}  \varepsilon_j^{out}  -
 \sum_{j=1}^{N_{occ}} \varepsilon_j^{inp} \right|  

 A zero value (the default) means do not use this criterion. 

 If this criterion is used, the SCF loop will only stop once it is fulfilled
 for two consecutive iterations. 
END

Variable ConvRelEv
Type float
Default 0.0
Section SCF::Convergence
Description
 Relative convergence of the sum of the eigenvalues: 

 \varepsilon  =  \frac{  \left| \sum_{j=1}^{N_{occ}} ( \varepsilon_j^{out} -
 \varepsilon_j^{inp}  )  \right|}  {\left|  \sum_{j=1}^{N_{occ}}
 \varepsilon_j^{out} \right|}  

A zero value (the default) means do not use this criterion.

 If this criterion is used, the SCF loop will only stop once it is fulfilled
 for two consecutive iterations. 
END

Variable MixingScheme
Type integer
Default broyden
Section SCF::Mixing
Description
 The  scheme used to produce, at each iteration in the self-consistent cycle
 that  attempts to solve the Kohn-Sham equations, the input density from the
 value of the input and output densities of previous iterations. 
Option linear 0
 Simple linear mixing. 
Option broyden 2
 Broyden  scheme  [C.  G  Broyden,  _Math.  Comp._  *19*,  577 (1965); D. D.
 Johnson,  _Phys.  Rev.  B_  *38*,  12807  (1988)].  The  scheme is slightly
 adapted,  see  the  comments  in  the  code.  For  complex  functions (e.g.
 Sternheimer  with  EMEta > 0), we use the generalization with a complex dot
 product. 
Option diis 9
 Direct  inversion in the iterative subspace (diis) scheme [P. Pulay, _Chem.
 Phys.  Lett._,  *73*,  393  (1980)]  as  described  in  [G.  Kresse, and J.
 Hurthmueller, 
 _Phys. Rev. B_ *54*, 11169 (1996)]. 
Option bowler_gillan 1
 The  Guaranteed-reduction  modification  of  the Pulay scheme by Bowler and
 Gillan [D. R. Bowler and M. J. Gillan, 
 _Chem. Phys. Lett._ *325*, 473 (2000)]. 
END

Variable MixingPreconditioner
Type logical
Default false
Section SCF::Mixing
Description
 (Experimental)  If  set  to  yes, Octopus will use a preconditioner for the
 mixing operator. This preconditioner is disabled for systems with dimension
 other than 3. 
END

Variable Mixing
Type float
Default 0.3
Section SCF::Mixing
Description
 The  linear, Broyden and DIIS scheme depend on a "mixing parameter", set by
 this variable. Must be 0 < Mixing <= 1. 
END

Variable MixingResidual
Type float
Default 0.05
Section SCF::Mixing
Description
 In  the  DIIS mixing it is benefitial to include a bit of residual into the
 mixing. This parameter controls this amount. 
END

Variable MixNumberSteps
Type integer
Default 4
Section SCF::Mixing
Description
 In  the  Broyden  and  Bowler_Gillan  schemes,  the  new  input  density or
 potential  is  constructed from the values of the densities/potentials of a
 given  number  of previous iterations. This number is set by this variable.
 Must be greater than 1. 
END

Variable MixingRestart
Type integer
Default 20
Section SCF::Mixing
Description
 In the Broyden and Bowler_Gillan schemes, the mixing is restarted after the
 number  of  iterations  given by this variable. Set this to zero to disable
 restarting the mixing. 
END

Variable MixInterval
Type integer
Default 1
Section SCF::Mixing
Description
 When  this  variable  is  set  to  a value different than 1 (the default) a
 combined  mixing  scheme will be used, with MixInterval - 1 steps of linear
 mixing  followed  by  1  step  of  the selected mixing. For the moment this
 variable only works with DIIS mixing. 
END

Variable LCAOStart
Type integer
Section SCF::LCAO
Description
 Before starting a SCF calculation, Octopus can perform a linear combination
 of  atomic  orbitals  (LCAO)  calculation. These can provide Octopus with a
 good set of initial wavefunctions and with a new guess for the density. (Up
 to  the  current version, only a minimal basis set is used.) The default is
 lcao_states  if  at  least one species representing an atom is present. The
 default is lcao_none if all species are species_user_defined, 
 species_charge_density, species_from_file, or species_jellium_slab. 

 The initial guess densities for LCAO are taken from the atomic orbitals for
 pseudopotential  species;  from  the  natural  charge  density  for
 species_charge_density, species_point, 
 species_jellium,  and  species_jellium_slab;  or  uniform  for
 species_full_delta, species_full_gaussian, 
 species_user_defined, or species_from_file. Pseudopotential species use the
 pseudo-wavefunctions  as  orbitals,  full-potential  atomic  species
 (species_full_delta  and  species_full_gaussian)  use  hydrogenic
 wavefunctions, and others use harmonic-oscillator wavefunctions. 

 Note: Some pseudopotential files (CPI, FHI for example) do not contain full
 information  about  the  orbitals.  In  this  case,  Octopus  generates the
 starting density from the normalized square root of the local potential. If
 no  orbitals  are  available at all from the pseudopotential files, Octopus
 will  not  be  able  to  perform  an  LCAO  and  the initial states will be
 randomized. 

Option lcao_none 0
 Do  not perform a LCAO calculation before the SCF cycle. Instead use random
 wavefunctions. 
Option lcao_states 2
 Do  a  LCAO  calculation  before  the  SCF  cycle  and  use  the  resulting
 wavefunctions  as initial wavefunctions without changing the guess density.
 This  will speed up the convergence of the eigensolver during the first SCF
 iterations. 
Option lcao_full 3
 Do  a  LCAO calculation before the SCF cycle and use the LCAO wavefunctions
 to build a new guess density and a new KS potential. Using the LCAO density
 as  a  new  guess density may improve the convergence, but can also slow it
 down or yield wrong results (especially for spin-polarized calculations). 
END

Variable LCAOAlternative
Type logical
Default false
Section SCF::LCAO
Description
 If  this  variable  is set, the LCAO procedure will use an alternative (and
 experimental)  implementation.  It is faster for large systems and parallel
 in states. It is not working for spinors, however. 
END

Variable LCAOComplexYlms
Type logical
Default false
Section SCF::LCAO
Description
 If  set to true, and using complex states, complex spherical harmonics will
 be  used,  _i.e._ with e^{\pm i m \phi}. If false, real spherical harmonics
 with \sin(m \phi) or \cos(m \phi) are used. This variable will make it more
 likely  to  get  states  that  are eigenvectors of the L_z operator, with a
 definite angular momentum. 
END

Variable LCAOScaleFactor
Type float
Default 1.0
Section SCF::LCAO
Description
 The  coordinates  of the atomic orbitals used by the LCAO procedure will be
 rescaled by the value of this variable. 1.0 means no rescaling. 
END

Variable LCAOMaximumOrbitalRadius
Type float
Default 20.0 a.u.
Section SCF::LCAO
Description
 The  LCAO  procedure  will ignore orbitals that have an extent greater that
 this value. 
END

Variable LCAODimension
Type integer
Section SCF::LCAO
Description
 (Only  applies  if LCAOAlternative = no.) Before starting the SCF cycle, an
 initial  LCAO  calculation  can  be performed in order to obtain reasonable
 initial guesses for spin-orbitals and densities. For this purpose, the code
 calculates  a number of atomic orbitals. The number available for a species
 described  by  a pseudopotential is all the orbitals up the maximum angular
 momentum  in  the  pseudopotential, minus any orbitals that are found to be
 unbound.  For non-pseudopotential species, the number is equal to twice the
 valence  charge.  The  default dimension for the LCAO basis set will be the
 sum  of all these numbers, or twice the number of required orbitals for the
 full calculation, whichever is less. 

 This  dimension however can be changed by making use of this variable. Note
 that  LCAODimension cannot be smaller than the number of orbitals needed in
 the full calculation -- if 
 LCAODimension  is  smaller,  it  will  be  silently  increased to meet this
 requirement. In the same way, if LCAODimension is larger than the available
 number  of  atomic  orbitals,  it  will  be reduced. If you want to use the
 largest possible number, set 
 LCAODimension to a negative number. 
END

Variable LCAOKeepOrbitals
Type logical
Default yes
Section SCF::LCAO
Description
 Only applies if LCAOAlternative = true. If set to yes (the default) Octopus
 keeps  atomic  orbitals  in memory during the LCAO procedure. If set to no,
 the  orbitals  are  generated  each  time  that they are needed, increasing
 computational time but saving memory. 

 When  set  to  yes,  Octopus  prints  the amount of memory per node that is
 required to store the orbitals. 

END

Variable LCAOExtraOrbitals
Type logical
Default false
Section SCF::LCAO
Description
 Only  applies  if  LCAOAlternative  =  true,  and  all  species  are
 pseudopotentials.  (experimental)  If this variable is set to yes, the LCAO
 procedure  will  add  an  extra  set  of  numerical  orbitals (by using the
 derivative  of  the  radial  part of the original orbitals). Note that this
 corresponds  roughly  to  adding  orbitals  with  higher  principal quantum
 numbers,  but the same angular momentum. This option may cause problems for
 unoccupied  states  since  you  may  miss  some  lower-lying  states  which
 correspond  to  higher  angular momenta instead of higher principal quantum
 number. 
END

Variable LCAODiagTol
Type float
Default 1e-10
Section SCF::LCAO
Description
 Only  applies  if  LCAOAlternative  =  true.  The  tolerance  for  the
 diagonalization of the LCAO Hamiltonian. 
END

Variable GuessMagnetDensity
Type integer
Default ferromagnetic
Section SCF::LCAO
Description
 The  guess  density  for  the  SCF  cycle is just the sum of all the atomic
 densities.  When  performing  spin-polarized  or  non-collinear-spin
 calculations this option sets the guess magnetization density. 

 For  anti-ferromagnetic  configurations,  the user_defined option should be
 used. 

 Note  that  if the paramagnetic option is used, the final ground state will
 also be paramagnetic, but the same is not true for the other options. 
Option paramagnetic 1
 Magnetization density is zero. 
Option ferromagnetic 2
 Magnetization density is the sum of the atomic magnetization densities. 
Option random 3
 Each atomic magnetization density is randomly rotated. 
Option user_defined 77
 The  atomic  magnetization  densities are rotated so that the magnetization
 vector  has  the  same  direction as a vector provided by the user. In this
 case, the AtomsMagnetDirection block has to be set. 
END

Variable AtomsMagnetDirection
Type block
Section SCF::LCAO
Description
 This option is only used when GuessMagnetDensity is set to user_defined. It
 provides  a  direction  for  the  magnetization  vector  of  each atom when
 building  the  guess  density. In order to do that, the user should specify
 the  coordinates  of a vector that has the desired direction and norm. Note
 that  it  is  necessary  to maintain the ordering in which the species were
 defined in the coordinates specifications. 

 For  spin-polarized  calculations,  the  vectors  should  have  only  one
 component;  for  non-collinear-spin  calculations,  they  should have three
 components. If the norm of the vector is greater than the number of valence
 electrons  in  the  atom,  it will be rescaled to this number, which is the
 maximum possible magnetization. 
END

Variable OCTClassicalTarget
Type block
Section Calculation Modes::Optimal Control
Description
 If OCTTargetOperator = oct_tg_classical, the you must supply this block. It
 should contain a string (e.g. "(q[1,1]-q[1,2])*p[2,1]") with a mathematical
 expression in terms of two arrays, q and p, that represent the position and
 momenta  of  the  classical  variables.  The  first  index runs through the
 various  classical particles, and the second index runs through the spatial
 dimensions. 

 In  principle,  the block only contains one entry (string). However, if the
 expression  is  very  long, you can split it into various lines (one column
 each) that will be concatenated. 

 The  QOCT algorithm will attempt to maximize this expression, at the end of
 the propagation. 
END

Variable OCTMomentumDerivatives
Type block
Section Calculation Modes::Optimal Control
Description
 This block should contain the derivatives of the expression given in 
 OCTClassicalTarget  with  respect  to  the  p  array  components. Each line
 corresponds  to  a  different  classical  particle,  whereas  the  columns
 correspond to each spatial dimension: the (i,j) block component corresponds
 with the derivative wrt p[i,j]. 
END

Variable OCTPositionDerivatives
Type block
Section Calculation Modes::Optimal Control
Description
 This block should contain the derivatives of the expression given in 
 OCTClassicalTarget  with  respect  to  the  q  array  components. Each line
 corresponds  to  a  different  classical  particle,  whereas  the  columns
 correspond to each spatial dimension: the (i,j) block component corresponds
 with the derivative wrt q[i,j]. 
END

Variable OCTTargetTransformStates
Type block
Default no
Section Calculation Modes::Optimal Control
Description
 If OCTTargetOperator = oct_tg_gstransformation, you must specify a 
 OCTTargetTransformStates  block,  in  order  to  specify  which  linear
 combination  of  the  states  present  in  restart/gs is used to create the
 target state. 

 The syntax is the same as the TransformStates block. 
END

Variable OCTLocalTarget
Type string
Section Calculation Modes::Optimal Control
Description
 If  OCTTargetOperator  = oct_tg_local, then one must supply a function that
 defines  the  target.  This should be done by defining it through a string,
 using the variable OCTLocalTarget. 
END

Variable OCTTargetDensity
Type string
Section Calculation Modes::Optimal Control
Description
 If  OCTTargetOperator  =  oct_tg_density,  then  one must supply the target
 density  that should be searched for. This one can do by supplying a string
 through the variable OCTTargetDensity. Alternately, give the special string
 "OCTTargetDensityFromState"  to  specify  the  expression  via  the  block
 OCTTargetDensityFromState. 
END

Variable OCTTargetDensityFromState
Type block
Default no
Section Calculation Modes::Optimal Control
Description
 If  OCTTargetOperator  =  oct_tg_density,  and  OCTTargetDensity  =
 "OCTTargetDensityFromState",  you  must  specify  a  OCTTargetDensityState
 block,  in  order to specify which linear combination of the states present
 in restart/gs is used to create the target density. 

 The syntax is the same as the TransformStates block. 
END

Variable OCTCurrentFunctional
Type integer
Section Calculation Modes::Optimal Control
Default oct_no_curr
Description
 (Experimental)  The  variable  OCTCurrentFunctional describes which kind of
 current target functional J1_c[j] is to be used. 
Option oct_no_curr 0
 No current functional is used, no current calculated. 
Option oct_curr_square 1
 Calculates the square of current j: 
 J1_c[j]  =  {\tt  OCTCurrentWeight}  \int{\left|  j(r)  \right|^2  dr}. For
 OCTCurrentWeight  < 0, the current will be minimized (useful in combination
 with  target density in order to obtain stable final target density), while
 for 
 OCTCurrentWeight  >  0,  it will be maximized (useful in combination with a
 target density in order to obtain a high-velocity impact, for instance). It
 is a static target, to be reached at total time. 
Option oct_max_curr_ring 2
 Maximizes  the  current  of a quantum ring in one direction. The functional
 maximizes  the  z  projection  of  the  outer  product between the position
 \vec{r} and the current \vec{j}: 
 J1[j]  = {\tt OCTCurrentWeight} \int{(\vec{r} \times \vec{j}) \cdot \hat{z}
 dr}.  For  OCTCurrentWeight  >  0,  the  current flows in counter-clockwise
 direction, while for OCTCurrentWeight < 0, the current is clockwise. 
Option oct_curr_square_td 3
 The  time-dependent  version  of  oct_curr_square.  In fact, calculates the
 square  of  current  in  time  interval  [OCTStartTimeCurrTg,  total time =
 TDMaximumIter * TDTimeStep]. Set TDPropagator = crank_nicolson. 
END

Variable OCTCurrentWeight
Type float
Section Calculation Modes::Optimal Control
Default 0.0
Description
 In  the  case  of simultaneous optimization of density n and current j, one
 can  tune  the  importance  of  the  current  functional  J1_c[j],  as  the
 respective  functionals  might  not  provide  results  on the same scale of
 magnitude. J1[n,j]= J1_d[n]+ {\tt OCTCurrentWeight}\ J1_c[j]. Be aware that
 its sign is crucial for the chosen OCTCurrentFunctional as explained there.
 
END

Variable OCTStartIterCurrTg
Type integer
Section Calculation Modes::Optimal Control
Default 0
Description
 Allows  for a time-dependent target for the current without defining it for
 the  total  time-interval  of the simulation. Thus it can be switched on at
 the  iteration  desired,  OCTStartIterCurrTg  >= 0 and OCTStartIterCurrTg <
 TDMaximumIter.  Tip: If you would like to specify a real time for switching
 the functional on rather than the number of steps, just use something like:
 
 OCTStartIterCurrTg = 100.0 / TDTimeStep. 
END

Variable OCTSpatialCurrWeight
Type block
Section Calculation Modes::Optimal Control
Description
 Can  be  seen  as  a  position-dependent OCTCurrentWeight. Consequently, it
 weights  contribution  of  current j to its functional J1_c[j] according to
 the position in space. For example, oct_curr_square thus becomes 
 J1_c[j]  =  {\tt  OCTCurrentWeight}  \int{\left|  j(r)  \right|^2  {\tt
 OCTSpatialCurrWeight}(r) dr}. 

 It is defined as OCTSpatialCurrWeight(r) = g(x) g(y) g(z), where 
 g(x)  =  \sum_{i}  1/(1+e^{-{\tt  fact}  (x-{\tt  startpoint}_i)})  -
 1/(1+e^{-{\tt fact} (x-{\tt endpoint}_i)}). If not specified, g(x) = 1. 

 Each  g(x)  is  represented by one line of the block that has the following
 form 

 %OCTSpatialCurrWeight 
    dimension | fact | startpoint_1 | endpoint_1 | startpoint_2 | endpoint_2
 |... 
 % 

 There  are  no  restrictions  on  the number of lines, nor on the number of
 pairs  of  start- and endpoints. Attention: startpoint and endpoint have to
 be  supplied pairwise with startpoint < endpoint. dimension > 0 is integer,
 fact is float. 
END

Variable OCTVelocityTarget
Type block
Section Calculation Modes::Optimal Control
Description
 If  OCTTargetOperator = oct_tg_velocity, then one must supply the target to
 optimize  in  terms  of  the  ionic velocities. This is done by supplying a
 string  through  the  block  OCTVelocityTarget.  Each velocity component is
 supplied  by  "v[n_atom,vec_comp]",  where  n_atom  is  the  atom  number,
 corresponding to the 
 Coordinates  block,  and  vec_comp is the corresponding vector component of
 the  velocity.  The target string can be supplied by using several lines in
 this block. As an example, the following target can be used to maximize the
 velocity difference between atom 1 and 2 (in a 3D system): 

 %OCTVelocityTarget 
  "(v[1,1]-v[2,1])^2 + (v[1,2]-v[2,2])^2 + " 
  "(v[1,3]-v[2,3])^2" 
 % 

END

Variable OCTVelocityDerivatives
Type block
Section Calculation Modes::Optimal Control
Description
 If OCTTargetOperator = oct_tg_velocity, and 
 OCTScheme  = oct_cg or OCTScheme = oct_bfgs then you must supply the target
 in  terms  of  the  ionic velocities AND the derivatives of the target with
 respect  to the ionic velocity components. The derivatives are supplied via
 strings through the block 
 OCTVelocityDerivatives.  Each  velocity  component  is  supplied  by
 "v[n_atom,vec_comp]", while n_atom is the atom number, corresponding to the
 
 Coordinates  block,  and  vec_comp is the corresponding vector component of
 the velocity. The first line of the 
 OCTVelocityDerivatives  block  contains  the  derivatives  with  respect to
 v[1,*],  the  second  with  respect  to  v[2,*] and so on. The first column
 contains  all  derivatives  with respect v[*,1], the second with respect to
 v[*,2]  and  the  third  w.r.t.  v[*,3].  As  an  example,  we  show  the
 OCTVelocityDerivatives  block  corresponding  to  the  target  shown in the
 OCTVelocityTarget help section: 

 %OCTVelocityDerivatives 
  " 2*(v[1,1]-v[2,1])" | " 2*(v[1,2]-v[2,2])" | " 2*(v[1,3]-v[2,3])" 
  "-2*(v[1,1]-v[2,1])" | "-2*(v[1,2]-v[2,2])" | "-2*(v[1,3]-v[2,3])" 
 % 

END

Variable OCTTargetUserdefined
Type block
Section Calculation Modes::Optimal Control
Description
 Define  a  target  state.  Syntax  follows the one of the UserDefinedStates
 block. Example: 

 %OCTTargetUserdefined 
    1 | 1 | 1 | "exp(-r^2)*exp(-i*0.2*x)" 
 % 

END

Variable OCTEps
Type float
Section Calculation Modes::Optimal Control
Default 1.0e-6
Description
 Define  the  convergence  threshold. It computes the difference between the
 "input"  field  in the iterative procedure, and the "output" field. If this
 difference is less than OCTEps the iteration is stopped. This difference is
 defined as: 

  D[\varepsilon^{in},\varepsilon^{out}]  =  \int_0^T  dt  \left|
 \varepsilon^{in}(t)-\varepsilon^{out}(t)\right|^2 
  

 (If there are several control fields, this difference is defined as the sum
 over all the individual differences.) 

 Whenever  this  condition  is  satisfied,  it  means that we have reached a
 solution  point  of the QOCT equations, _i.e._ a critical point of the QOCT
 functional  (not  necessarily  a  maximum,  and  not necessarily the global
 maximum). 
END

Variable OCTMaxIter
Type integer
Section Calculation Modes::Optimal Control
Default 10
Description
 The maximum number of iterations. Typical values range from 10-100. 
END

Variable OCTDumpIntermediate
Type logical
Section Calculation Modes::Optimal Control
Default true
Description
 Writes  to  disk  the  laser  pulse  data  during  the  OCT  algorithm  at
 intermediate  steps.  These  are files called opt_control/laser.xxxx, where
 xxxx is the iteration number. 
END

Variable OCTScheme
Type integer
Section Calculation Modes::Optimal Control
Default oct_zbr98
Description
 Optimal  Control  Theory  can  be  performed with Octopus with a variety of
 different algorithms. Not all of them can be used with any choice of target
 or  control function representation. For example, some algorithms cannot be
 used if 
 OCTControlRepresentation  =  control_function_real_time  (OCTScheme  >
 oct_straight_iteration),  and  others  cannot  be  used  if
 OCTControlRepresentation  =  control_function_parametrized  (OCTScheme  <
 oct_straight_iteration). 
Option oct_zbr98 1
 Backward-Forward-Backward  scheme  described  in  _JCP_ *108*, 1953 (1998).
 Only  possible  if target operator is a projection operator. Provides fast,
 stable and monotonic convergence. 
Option oct_zr98  2
 Forward-Backward-Forward scheme described in _JCP_ *109*, 385 (1998). Works
 for  projection  and more general target operators also. The convergence is
 stable  but  slower than ZBR98. Note that local operators show an extremely
 slow convergence. It ensures monotonic convergence. 
Option oct_wg05  3
 Forward-Backward  scheme  described  in _J. Opt. B._ *7*, 300 (2005). Works
 for  all  kinds of target operators, can be used with all kinds of filters,
 and  allows a fixed fluence. The price is a rather unstable convergence. If
 the  restrictions  set  by  the  filter  and fluence are reasonable, a good
 overlap can be expected within 20 iterations. No monotonic convergence. 
Option oct_mt03 4
 Basically an improved and generalized scheme. Comparable to ZBR98/ZR98. See
 [Y. Maday and G. Turinici, _J. Chem. Phys._ *118*, 8191 (2003)]. 
Option oct_krotov 5
 The  procedure  reported  in  [D.  Tannor,  V.  Kazakov  and  V.  Orlov, in
 _Time-Dependent Quantum Molecular Dynamics_, edited by J. Broeckhove and L.
 Lathouweres (Plenum, New York, 1992), pp. 347-360]. 
Option oct_straight_iteration 6
 Straight  iteration:  one forward and one backward propagation is performed
 at  each  iteration,  both  with the same control field. An output field is
 calculated with the resulting wavefunctions. 
Option oct_cg 7
 Conjugate-gradients,  as implemented in the GNU GSL library. In particular,
 the  Fletcher-Reeves  version. The seed for the random number generator can
 be modified by setting 
 GSL_RNG_SEED environment variable. 
Option oct_bfgs 8
 The  methods  use  the  vector  Broyden-Fletcher-Goldfarb-Shanno  (BFGS)
 algorithm.  Also, it calls the GNU GSL library version of the algorithm. It
 is  a  quasi-Newton  method  which builds up an approximation to the second
 derivatives  of  the  function  using  the  difference  between  successive
 gradient  vectors.  By  combining  the  first  and  second  derivatives the
 algorithm  is  able to take Newton-type steps towards the function minimum,
 assuming quadratic behavior in that region. We have chosen to implement the
 "bfgs2"  version,  as  GSL  calls  it,  which  is  supposed  to be the most
 efficient  version  available,  and  a  faithful implementation of the line
 minimization  scheme  described  in  "Practical  Methods  of Optimization",
 (Fletcher), Algorithms 2.6.2 and 2.6.4. 
Option oct_direct 9
 This  is a "direct" optimization scheme. This means that we do not make use
 of  the "usual" QOCT equations (backward-forward propagations, etc), but we
 use some gradient-free maximization algorithm for the function that we want
 to  optimize.  In  this case, the maximization algorithm is the Nelder-Mead
 algorithm  as  implemeted  in  the GSL. The function values are obtained by
 successive  forward  propagations. The seed for the random number generator
 can be modified by setting 
 GSL_RNG_SEED environment variable. 
Option oct_nlopt_bobyqa 11
 The  BOBYQA  algorithm,  as  implemented in the NLOPT library -- therefore,
 octopus  has to be compiled with it in order to be able to use this option.
 The seed for the random number generator can be modified by setting 
 GSL_RNG_SEED environment variable. 
Option oct_nlopt_lbfgs 12
 The  local  BFGS, as implemented in the NLOPT library -- therefore, octopus
 has to be compiled with it in order to be able to use this option. The seed
 for the random number generator can be modified by setting 
 GSL_RNG_SEED environment variable. 
END

Variable OCTEta
Type float
Section Calculation Modes::Optimal Control
Default 1.0
Description
 If  OCTScheme  =  oct_mt03,  then  you  can  supply  the  "eta" and "delta"
 parameters  described in [Y. Maday and G. Turinici, _J. Chem. Phys._ *118*,
 8191 (2003)], using the 
 OCTEta and OCTDelta variables. 
END

Variable OCTDelta
Type float
Section Calculation Modes::Optimal Control
Default 0.0
Description
 If  OCTScheme  =  oct_mt03,  then  you  can  supply  the  "eta" and "delta"
 parameters  described in [Y. Maday and G. Turinici, _J. Chem. Phys._ *118*,
 8191 (2003)], using the 
 OCTEta and OCTDelta variables. 
END

Variable OCTDoubleCheck
Type logical
Section Calculation Modes::Optimal Control
Default true
Description
 In  order  to  make  sure that the optimized field indeed does its job, the
 code  may  run  a  normal  propagation  after  the  optimization  using the
 optimized field. 
END

Variable OCTCheckGradient
Type float
Section Calculation Modes::Optimal Control
Default 0.0
Description
 When  doing  QOCT  with  the  conjugate-gradient  optimization  scheme, the
 gradient  is  computed  thanks  to  a  forward-backwards  propagation.  For
 debugging  purposes,  this gradient can be compared with the value obtained
 "numerically" (_i.e._ by doing successive forward propagations with control
 fields separated by small finite differences). 

 In  order  to  activate this feature, set OCTCheckGradient to some non-zero
 value,  which will be the finite difference used to numerically compute the
 gradient. 
END

Variable OCTDirectStep
Type float
Section Calculation Modes::Optimal Control
Default 0.25
Description
 If  you  choose OCTScheme = oct_direct or OCTScheme = oct_nlopt_bobyqa, the
 algorithms  necessitate  an initial "step" to perform the direct search for
 the optimal value. The precise meaning of this "step" differs. 
END

Variable OCTNumberCheckPoints
Type integer
Section Calculation Modes::Optimal Control
Default 0
Description
 During  an  OCT  propagation,  the code may write the wavefunctions at some
 time  steps  (the  "check  points").  When  the inverse backward or forward
 propagation  is  performed  in  a  following  step, the wavefunction should
 reverse its path (almost) exactly. This can be checked to make sure that it
 is the case -- otherwise one should try reducing the time-step, or altering
 in some other way the variables that control the propagation. 

 If  the backward (or forward) propagation is not retracing the steps of the
 previous forward (or backward) propagation, the code will write a warning. 
END

Variable OCTRandomInitialGuess
Type logical
Section Calculation Modes::Optimal Control
Default false
Description
 The  initial field to start the optimization search is usually given in the
 inp  file,  through a TDExternalFields block. However, you can start from a
 random guess if you set this variable to true. 

 Note,  however,  that  this  is  only  valid  for the "direct" optimization
 schemes; moreover you still need to provide a TDExternalFields block. 
END

Variable OCTInitialState
Type integer
Section Calculation Modes::Optimal Control
Default oct_is_groundstate
Description
 Describes the initial state of the quantum system. Possible arguments are: 
Option oct_is_groundstate 1
 Start in the ground state. 
Option oct_is_excited 2
 Currently not in use. 
Option oct_is_gstransformation 3
 Start  in  a transformation of the ground-state orbitals, as defined in the
 block OCTInitialTransformStates. 
Option oct_is_userdefined 4
 Start in a user-defined state. 
END

Variable OCTInitialTransformStates
Type block
Section Calculation Modes::Optimal Control
Description
 If OCTInitialState = oct_is_gstransformation, you must specify an 
 OCTInitialTransformStates  block,  in  order  to  specify  which  linear
 combination  of  the  states  present  in  restart/gs is used to create the
 initial state. 

 The syntax is the same as the TransformStates block. 
END

Variable OCTInitialUserdefined
Type block
Section Calculation Modes::Optimal Control
Description
 Define  an  initial  state. Syntax follows the one of the UserDefinedStates
 block. Example: 

 %OCTInitialUserdefined 
    1 | 1 | 1 | "exp(-r^2)*exp(-i*0.2*x)" 
 % 

END

Variable OCTOptimizeHarmonicSpectrum
Type block
Default no
Section Calculation Modes::Optimal Control
Description
 (Experimental)  If  OCTTargetOperator  =  oct_tg_hhg,  the  target  is  the
 harmonic  emission  spectrum.  In  that  case,  you  must  supply  an
 OCTOptimizeHarmonicSpectrum  block in the inp file. The target is given, in
 general, by: 

 J_1 = \int_0^\infty d\omega \alpha(\omega) H(\omega), 

 where H(\omega) is the harmonic spectrum generated by the system, and 
 \alpha(\omega)  is  some  function  that determines what exactly we want to
 optimize. The role of the OCTOptimizeHarmonicSpectrum block is to determine
 this \alpha(\omega) function. Currently, this function is defined as: 

 \alpha(\omega)  =  \sum_{L=1}^{M}  \frac{\alpha_L}{a_L}  \sqcap(  (\omega -
 L\omega_0)/a_L ), 

 where  \omega_0 is the carrier frequency. M is the number of columns in the
 OCTOptimizeHarmonicSpectrum  block. The values of _L_ will be listed in the
 first row of this block; \alpha_L in the second row, and a_L in the third. 

 Example: 

 %OCTOptimizeHarmonicSpectrum 
    7 | 9 | 11 
    -1 | 1 | -1 
    0.01 | 0.01 | 0.01 
 % 

END

Variable OCTHarmonicWeight
Type string
Default "1"
Section Calculation Modes::Optimal Control
Description
 (Experimental)  If OCTTargetOperator = oct_tg_plateau, then the function to
 optimize  is the integral of the harmonic spectrum H(\omega), weighted with
 a  function f(\omega) that is defined as a string here. For example, if you
 set  OCTHarmonicWeight  =  "step(w-1)",  the  function  to  optimize is the
 integral of step(\omega-1)*H(\omega), _i.e._ 
 \int_1^{\infty}  H \left( \omega \right) d\omega. In practice, it is better
 if you also set an upper limit, _e.g._ 
 f(\omega) = step(\omega-1) step(2-\omega). 
END

Variable OCTControlFunctionRepresentation
Type integer
Section Calculation Modes::Optimal Control
Default control_fourier_series_h
Description
 If  OCTControlRepresentation  =  control_function_parametrized,  one  must
 specify  the  kind  of  parameters  that determine the control function. If
 OCTControlRepresentation  =  control_function_real_time, then this variable
 is ignored, and the control function is handled directly in real time. 
Option control_fourier_series_h 3
 The  control  function  is  expanded  as a full Fourier series (although it
 must, of course, be a real function). Then, the total fluence is fixed, and
 a  transformation  to hyperspherical coordinates is done; the parameters to
 optimize are the hyperspherical angles. 
Option control_zero_fourier_series_h 4
 The control function is expanded as a Fourier series, but assuming (1) that
 the  zero  frequency  component  is  zero,  and  (2)  the control function,
 integrated in time, adds up to zero (this essentially means that the sum of
 all the cosine coefficients is zero). Then, the total fluence is fixed, and
 a  transformation  to hyperspherical coordinates is done; the parameters to
 optimize are the hyperspherical angles. 
Option control_fourier_series 5
 The  control  function  is  expanded  as a full Fourier series (although it
 must,  of  course,  be  a  real  function).  The control parameters are the
 coefficients of this basis-set expansion. 
Option control_zero_fourier_series 6
 The  control  function  is  expanded  as a full Fourier series (although it
 must,  of  course,  be  a  real  function).  The control parameters are the
 coefficients  of  this  basis-set expansion. The difference with the option
 control_fourier_series  is  that  (1)  that the zero-frequency component is
 zero,  and  (2)  the  control function, integrated in time, adds up to zero
 (this  essentially  means  that  the  sum of all the cosine coefficients is
 zero). 
Option control_rt 7
 (experimental) 
END

Variable OCTControlFunctionOmegaMax
Type float
Section Calculation Modes::Optimal Control
Default -1.0
Description
 The Fourier series that can be used to represent the control functions must
 be  truncated;  the  truncation  is  given  by a cut-off frequency which is
 determined by this variable. 
END

Variable OCTFixFluenceTo
Type float
Section Calculation Modes::Optimal Control
Default 0.0
Description
 The  algorithm  tries  to obtain the specified fluence for the laser field.
 This  works  only  in  conjunction  with  either  the  WG05 or the straight
 iteration scheme. 

 If this variable is not present in the input file, by default the code will
 not  attempt a fixed-fluence QOCT run. The same holds if the value given to
 this variable is exactly zero. 

 If this variable is given a negative value, then the target fluence will be
 that  of  the  initial  laser pulse given as guess in the input file. Note,
 however,  that  first  the  code  applies  the  envelope  provided  by  the
 OCTLaserEnvelope input option, and afterwards it calculates the fluence. 
END

Variable OCTFixInitialFluence
Type logical
Section Calculation Modes::Optimal Control
Default yes
Description
 By default, when asking for a fixed-fluence optimization (OCTFixFluenceTo =
 whatever),  the initial laser guess provided in the input file is scaled to
 match  this fluence. However, you can force the program to use that initial
 laser  as  the  initial  guess,  no  matter  the  fluence,  by  setting
 OCTFixInitialFluence = no. 
END

Variable OCTControlFunctionType
Type integer
Section Calculation Modes::Optimal Control
Default controlfunction_mode_epsilon
Description
 The  control  function  may  fully determine the time-dependent form of the
 external  field,  or  only the envelope function of this external field, or
 its  phase.  Or,  we  may have two different control functions, one of them
 providing the phase and the other one, the envelope. 

 Note  that,  if OCTControlRepresentation = control_function_real_time, then
 the  control function must *always* determine the full external field (THIS
 NEEDS TO BE FIXED). 
Option controlfunction_mode_epsilon   1
 In  this  case,  the control function determines the full control function:
 namely,  if  we  are  considering  the  electric  field  of  a  laser,  the
 time-dependent electric field. 
Option controlfunction_mode_f         2
 The  optimization  process attempts to find the best possible envelope. The
 full  control  field  is  this  envelope  times  a  cosine  function with a
 "carrier"  frequency.  This  carrier  frequency  is  given  by  the carrier
 frequency of the TDExternalFields in the inp file. 
END

Variable OCTPenalty
Type float
Section Calculation Modes::Optimal Control
Default 1.0
Description
 The  variable  specifies the value of the penalty factor for the integrated
 field  strength  (fluence).  Large value = small fluence. A transient shape
 can  be specified using the block OCTLaserEnvelope. In this case OCTPenalty
 is  multiplied  with  time-dependent  function.  The  value  depends on the
 coupling between the states. A good start might be a value from 0.1 (strong
 fields) to 10 (weak fields). 

 Note  that  if  there  are  several control functions, one can specify this
 variable  as a one-line code, each column being the penalty factor for each
 of  the control functions. Make sure that the number of columns is equal to
 the  number  of  control  functions.  If  it  is  not  a block, all control
 functions will have the same penalty factor. 

 All penalty factors must be positive. 
END

Variable OCTLaserEnvelope
Type block
Section Calculation Modes::Optimal Control
Description
 Often  a  pre-defined  time-dependent  envelope  on the control function is
 desired.  This can be achieved by making the penalty factor time-dependent.
 Here, you may specify the required time-dependent envelope. 

 It  is  possible  to  choose  different  envelopes  for  different  control
 functions.  There  should  be one line for each control function. Each line
 should  have  only  one element: a string with the name of a time-dependent
 function, that should be correspondingly defined in a TDFunctions block. 
END

Variable OCTTargetOperator
Type integer
Section Calculation Modes::Optimal Control
Default oct_tg_gstransformation
Description
 The  variable  OCTTargetOperator prescribes which kind of target functional
 is to be used. 
Option oct_tg_groundstate 1
 The  target  operator  is a projection operator on the ground state, _i.e._
 the objective is to populate the ground state as much as possible. 
Option oct_tg_excited 2
 (Experimental)  The  target operator is an "excited state". This means that
 the  target  operator  is a linear combination of Slater determinants, each
 one formed by replacing in the ground-state Slater determinant one occupied
 state with one excited state (_i.e._ "single excitations"). The description
 of which excitations are used, and with which weights, should be given in a
 file called 
 oct-excited-state-target.  See  the  documentation  of  subroutine
 excited_states_elec_init in the source code in order to use this feature. 
Option oct_tg_gstransformation 3
 The  target  operator  is  a projection operator on a transformation of the
 ground-state orbitals defined by the block OCTTargetTransformStates. 
Option oct_tg_userdefined 4
 (Experimental) Allows to define target state by using OCTTargetUserdefined.
 
Option oct_tg_jdensity 5
 (Experimental) 
Option oct_tg_local 6
 (Experimental) The target operator is a local operator. 
Option oct_tg_td_local 7
 (Experimental) The target operator is a time-dependent local operator. 
Option oct_tg_exclude_state 8
 (Experimental)  Target  operator is the projection onto the complement of a
 given  state,  given by the block OCTTargetTransformStates. This means that
 the  target  operator  is  the unity operator minus the projector onto that
 state. 
Option oct_tg_hhg 9
 (Experimental)  The  target  is the optimization of the HHG yield. You must
 supply  the  OCTOptimizeHarmonicSpectrum block, and it attempts to optimize
 the maximum of the spectrum around each harmonic peak. You may use only one
 of the gradient-less optimization schemes. 
Option oct_tg_velocity 10
 (Experimental)  The target is a function of the velocities of the nuclei at
 the  end  of  the  influence  of  the  external  field,  defined  by
 OCTVelocityTarget 
Option oct_tg_hhgnew 12
 (Experimental)  The  target  is the optimization of the HHG yield. You must
 supply the 
 OCTHarmonicWeight  string.  It  attempts  to  optimize  the integral of the
 harmonic spectrum multiplied by some user-defined weight function. 
Option oct_tg_classical 13
 (Experimental) 
Option oct_tg_spin 14
 (Experimental) 
END

Variable OCTFilter
Type block
Section Calculation Modes::Optimal Control
Description
 The  block  OCTFilter  describes  the type and shape of the filter function
 that are applied to the optimized laser field in each iteration. The filter
 forces  the  laser  field to obtain the given form in frequency space. Each
 line  of  the block describes a filter; this way you can actually have more
 than  one  filter  function  (_e.g._  a filter in time and two in frequency
 space).  The  filters  are  applied  in  the given order, _i.e._, first the
 filter specified by the first line is applied, then second line. The syntax
 of each line is, then: 

 %OCTFilter 
   domain | function 
 % 


 Possible arguments for domain are: 

 (i) frequency_filter: Specifies a spectral filter. 

 (ii) time_filter: DISABLED IN THIS VERSION. 

 Example: 

 %OCTFilter 
   time | "exp(-80*( w + 0.1567 )^2 ) + exp(-80*( w - 0.1567 )^2 )" 
 % 

 Be careful that also the negative-frequency component is filtered since the
 resulting field has to be real-valued. 

Option frequency_filter 1
 The filter is applied in the frequency domain. 
END

Variable OCTTdTarget
Type block
Section Calculation Modes::Optimal Control
Description
 (Experimental) If OCTTargetOperator = oct_tg_td_local, then you must supply
 a  OCTTdTarget  block.  The block should only contain one element, a string
 cotaining  the  definition  of  the  time-dependent  local target, _i.e._ a
 function of x,y,z and t that is to be maximized along the evolution. 
END

Variable OCTExcludedStates
Type string
Section Calculation Modes::Optimal Control
Description
 If  the  target  is the exclusion of several targets, ("OCTTargetOperator =
 oct_exclude_states") then you must declare which states are to be excluded,
 by  setting  the  OCTExcludedStates variable. It must be a string in "list"
 format:  "1-8",  or  "2,3,4-9",  for example. Be careful to include in this
 list  only  states  that have been calculated in a previous "gs" or "unocc"
 calculation, or otherwise the error will be silently ignored. 
END

Variable OCTTargetSpin
Type block
Section Calculation Modes::Optimal Control
Description
 (Experimental)  Specify  the targeted spin as a 3-component vector. It will
 be normalized. 
END

Variable OutputWfsNumber
Type string
Default all states
Section Output
Description
 Which  wavefunctions  to  print,  in  list form: _i.e._, "1-5" to print the
 first  five  states, "2,3" to print the second and the third state, etc. If
 more states are specified than available, extra ones will be ignored. 
END

Variable CurrentThroughPlane
Type block
Section Output
Description
 The  code  can  calculate  current  traversing  a user-defined portion of a
 plane,  as  specified  by  this block. A small plain-text file current-flow
 will  be written containing this information. Only available for 1D, 2D, or
 3D. In the format below, origin is a point in the plane. 
 u  and  v  are the (dimensionless) vectors defining the plane; they will be
 normalized.  spacing  is the fineness of the mesh on the plane. Integers nu
 and  mu  are  the length and width of the portion of the plane, in units of
 spacing. Thus, the grid points included in the plane are 
 x_ij = origin + i*spacing*u + j*spacing*v, for nu <= i <= mu and nv <= j <=
 mv.  Analogously,  in the 2D case, the current flow is calculated through a
 line;  in the 1D case, the current flow is calculated through a point. Note
 that  the  spacing can differ from the one used in the main calculation; an
 interpolation will be performed. 

 Example (3D): 

 %CurrentThroughPlane 
    0.0 | 0.0 | 0.0 # origin 
    0.0 | 1.0 | 0.0 # u 
    0.0 | 0.0 | 1.0 # v 
    0.2 # spacing 
    0 | 50 # nu | mu 
    -50 | 50 # nv | mv 
 % 

 Example (2D): 

 %CurrentThroughPlane 
    0.0 | 0.0 # origin 
    1.0 | 0.0 # u 
    0.2 # spacing 
    0 | 50 # nu | mu 
 % 

 Example (1D): 

 %CurrentThroughPlane 
    0.0 # origin 
 % 

END

Variable OutputDuringSCF
Type logical
Default no
Section Output
Description
 During  gs  and  unocc runs, if this variable is set to yes, output will be
 written after every OutputInterval iterations. 
END

Variable RestartWriteInterval
Type integer
Default 50
Section Execution::IO
Description
 Restart  data  is  written  when  the iteration number is a multiple of the
 RestartWriteInterval  variable.  For  time-dependent runs this includes the
 update  of the output controlled by the TDOutput variable. (Other output is
 controlled by OutputInterval.) 
END

Variable OutputIterDir
Default "output_iter"
Type string
Section Output
Description
 The  name  of  the  directory  where Octopus stores information such as the
 density,  forces, etc. requested by variable Output in the format specified
 by  OutputFormat.  This  information  is  written  while  iterating
 CalculationMode  =  gs,  unocc, or td, according to OutputInterval, and has
 nothing to do with the restart information. 
END

Variable OutputMatrixElements
Type block
Default none
Section Output
Description
 Specifies  what  matrix  elements  to  print.  Enabled only if Output block
 includes  matrix_elements.  The  output files go into the static directory,
 except  when  running  a  time-dependent  simulation,  when  the  directory
 td.XXXXXXX is used. 

 Example: 
 %OutputMatrixElements 
   momentum 
   ks_multipoles 
 % 

 It  is possible to specify only compute the matrix elements for some of the
 states using the variables OutptMEStart and OutputMEEnd. 
Option momentum 1
 Momentum. Filename: ks_me_momentum. 
Option ang_momentum 2
 Dimensionless  angular  momentum  \vec{r}  \times  \vec{k}.  Filename:
 ks_me_angular_momentum. 
Option one_body 3
 \left<  i  \left|  \hat{T}  + V_{ext} \right| j \right>. Not available with
 states parallelization. 
Option two_body 4
 \left<  ij  \left|  \frac{1}{\left|\vec{r}_1-\vec{r}_2\right|}  \right|  kl
 \right>.  Not  available  with  states  parallelization. Not available with
 states  parallelization.  For  periodic  system,  this is not available for
 k-point parallelization neither. 
Option two_body_exc_k 5
 \left<  n1-k1,  n2-k2  \left|  \frac{1}{\left|\vec{r}_1-\vec{r}_2\right|}
 \right| n2-k1 n1-k2 \right>. Not available with states parallelization. For
 periodic system, this is not available for k-point parallelization neither.
 
Option ks_multipoles 6
 See OutputMEMultipoles. Not available with states parallelization. 
Option dipole 7
 Prints  the  dipole  matrix  elements.  Not  available  with  states
 parallelization.  For  periodic systems, the intraband terms (dipole matrix
 elements between degenerated states) are set to zero, and only the absolute
 value  of  the  dipole  matrix  element  is  printed. Not yet supported for
 spinors. 
END

Variable OutputMEMultipoles
Type integer
Default 1
Section Output
Description
 This variable decides which multipole moments are printed out for 
 OutputMatrixElements = ks_multipoles: 

 In 3D, if, for example, OutputMEMultipoles = 1, then the program will print
 three  files,  ks_me_multipoles.x  (x=1,2,3),  containing  respectively the
 (1,-1), (1,0) and (1,1) multipole matrix elements between Kohn-Sham states.
 

 In 2D, this variable is ignored: it will always print two files, 
 ks_me_multipoles.i (i=1,2), containing the x and 
 y dipole matrix elements. 

 In  1D, if, for example, OutputMEMultipoles = 2, the program will print two
 files, containing the 
 x and x^2 matrix elements between Kohn-Sham states. 
END

Variable OutputMEStart
Type integer
Default 1
Section Output
Description
 Specifies  the state/band index for starting to compute the matrix element.
 So far, this is only used for dipole matrix elements. 
END

Variable OutputMEEnd
Type integer
Default 1
Section Output
Description
 Specifies  the highest state/band index used to compute the matrix element.
 So far, this is only used for dipole matrix elements. 
END

Variable LinearMediumOutput
Type block
Default none
Section Output
Description
 Specifies  what  to print. The output files are written at the beginning of
 the  run  into the output directory for the linear medium. Each option must
 be  in  a separate row. Optionally individual output formats can be defined
 for  each row (VTK format is supported) or they can be read separately from
 OutputFormat in the input file. 

 Example: 
 %LinearMediumOutput 
   permittivity 
   permeability 
 % This block supports all the formats of the Output block. See Output. 
Option points 1
 Outputs  1 if the a given point is inside the medium, and 0 otherwise. This
 can be used to check the grid points of the medium region. 
Option permittivity 2
 Output of the (static) space-dependent relative permittivity 
Option permeability 3
 Output of the (static) space-dependent relative permeability 
Option speed_of_light 3
 Output of the speed of light in atomic units 
END

Variable LinearMediumOutputDir
Default "output_iter"
Type string
Section Output
Description
 The  name  of  the directory where Octopus stores the information about the
 linear medium system, as required by the LinearMediumOutput variable. 
END

Variable MaxwellOutput
Type block
Default none
Section Output
Description
 Specifies what to print. The output files are written at the end of the run
 into  the  output directory for the Maxwell run. Time-dependent simulations
 print  only  per  iteration,  including  always  the last. The frequency of
 output  per  iteration is set by OutputInterval and the directory is set by
 OutputIterDir. Each option must be in a separate row. Optionally individual
 output formats and output intervals can be defined for each row or they can
 be read separately from OutputFormat and MaxwellOutputInterval variables in
 the input file. 

 Example: 
 %MaxwellOutput 
   electric_field 
   magnetic_field 
 % This block supports all the formats of the Output block. See Output. 
Option electric_field 1
 Output of the electric field 
Option magnetic_field 2
 Output of the magnetic field 
Option trans_electric_field 3
 Output of the transversal electric field 
Option trans_magnetic_field 4
 Output of the transversal magnetic field 
Option long_electric_field 5
 Output of the longitudinal electric field 
Option long_magnetic_field 6
 Output of the longitudinal magnetic field 
Option div_electric_field 7
 Output of the divergence of the electric field 
Option div_magnetic_field 8
 Output of the divergence of the magnetic field 
Option poynting_vector 9
 Output of the Maxwell Poynting vector 
Option maxwell_energy_density 10
 Output of the electromagnetic density 
Option external_current 11
 Output of the external Maxwell current 
Option charge_density 12
 Output  of  the charge density calculated by the divergence of the electric
 field. 
Option orbital_angular_momentum 13
 Output of the orbital angular momentum 
Option vector_potential_mag 14
 Output of the vector potential from magnetic field 
Option magnetic_field_diff 15
 Output of the magnetic field difference 
END

Variable MaxwellOutputInterval
Type integer
Default 50
Section Output
Description
 The  output requested by variable MaxwellOutput is written to the directory
 MaxwellOutputIterDir  when  the  iteration  number  is  a  multiple  of the
 MaxwellOutputInterval  variable.  Subdirectories  are named Y.X, where Y is
 td,  scf,  or  unocc,  and  X  is  the iteration number. To use the working
 directory,  specify  "."  (Output of restart files is instead controlled by
 MaxwellRestartWriteInterval.)  Must  be >= 0. If it is 0, then no output is
 written.  This variable can also be defined inside the MaxwellOutput block.
 See MaxwellOutput. 
END

Variable MaxwellOutputIterDir
Default "output_iter"
Type string
Section Output
Description
 The  name  of  the  directory  where Octopus stores information such as the
 density,  forces,  etc.  requested  by variable MaxwellOutput in the format
 specified  by  OutputHow.  This  information  is  written  while  iterating
 CalculationMode  =  maxwell according to OutputInterval, and has nothing to
 do with the restart information. 
END

Variable MaxwellRestartWriteInterval
Type integer
Default 50
Section Execution::IO
Description
 Restart data is written when the iteration number is a multiple of the 
 MaxwellRestartWriteInterval  variable.  (Other  output  is  controlled  by
 MaxwellOutputInterval.) 
END

Variable BerkeleyGW_NumberBands
Type integer
Default all states
Section Output::BerkeleyGW
Description
 Wavefunctions  for  bands up to this number will be output. Must be between
 <= number of states. If < 1, no wavefunction file will be output. 
END

Variable BerkeleyGW_Vxc_diag_nmin
Type integer
Default 1
Section Output::BerkeleyGW
Description
 Lowest  band  for  which  to  write  diagonal  exchange-correlation  matrix
 elements. Must be <= number of states. If < 1, diagonals will be skipped. 
END

Variable BerkeleyGW_Vxc_diag_nmax
Type integer
Default nst
Section Output::BerkeleyGW
Description
 Highest  band  for  which  to  write  diagonal  exchange-correlation matrix
 elements.  Must  be  between <= number of states. If < 1, diagonals will be
 skipped. 
END

Variable BerkeleyGW_Vxc_offdiag_nmin
Type integer
Default 1
Section Output::BerkeleyGW
Description
 Lowest  band  for  which  to write off-diagonal exchange-correlation matrix
 elements.  Must  be  <=  number  of  states.  If < 1, off-diagonals will be
 skipped. 
END

Variable BerkeleyGW_Vxc_offdiag_nmax
Type integer
Default nst
Section Output::BerkeleyGW
Description
 Highest  band  for  which to write off-diagonal exchange-correlation matrix
 elements.  Must  be  <=  number  of  states.  If < 1, off-diagonals will be
 skipped. 
END

 !!%Variable  BerkeleyGW_Complex !!%Type logical !!%Default false !!%Section
 Output::BerkeleyGW !!%Description !!% Even when wavefunctions, density, and
 XC  potential could be real in reciprocal space, !!% they will be output as
 complex. 
END

Variable BerkeleyGW_WFN_filename
Type string
Default WFN
Section Output::BerkeleyGW
Description
 Filename for the wavefunctions. 
END

Variable BerkeleyGW_CalcExchange
Type logical
Default false
Section Output::BerkeleyGW
Description
 Whether  to  calculate  exchange  matrix  elements, to be written in x.dat.
 These  will  be  calculated  anyway  by BerkeleyGW Sigma, so this is useful
 mainly for comparison and testing. 
END

Variable BerkeleyGW_CalcDipoleMtxels
Type logical
Default false
Section Output::BerkeleyGW
Description
 Whether  to calculate dipole matrix elements, to be written in vmtxel. This
 should be done when calculating WFN_fi for Bethe-Salpeter calculations with
 light polarization in a finite direction. In that case, a shifted grid 
 WFNq_fi cannot be calculated, but we can instead use matrix elements of 
 r  in  a  more  exact  scheme.  In  absorption.inp,  set  read_vmtxel  and
 use_momentum.  Specify  the number of conduction and valence bands you will
 use  in  BSE  here  with  BerkeleyGW_VmtxelNumCondBands  and
 BerkeleyGW_VmtxelNumValBands. 
END

Variable BerkeleyGW_VmtxelPolarization
Type block
Default (1, 0, 0)
Section Output::BerkeleyGW
Description
 Polarization,  _i.e._  direction  vector, for which to calculate vmtxel, if
 you have set 
 BerkeleyGW_CalcDipoleMtxels = yes. May not have any component in a periodic
 direction. The vector will be normalized. 
END

Variable BerkeleyGW_VmtxelNumCondBands
Type integer
Default 0
Section Output::BerkeleyGW
Description
 Number of conduction bands for which to calculate vmtxel, if you have set 
 BerkeleyGW_CalcDipoleMtxels = yes. This should be equal to the number to be
 used in BSE. 
END

Variable BerkeleyGW_VmtxelNumValBands
Type integer
Default 0
Section Output::BerkeleyGW
Description
 Number of valence bands for which to calculate vmtxel, if you have set 
 BerkeleyGW_CalcDipoleMtxels = yes. This should be equal to the number to be
 used in BSE. 
END

Variable Units
Type virtual
Default atomic
Section Execution::Units
Description
 (Virtual) These are the units that can be used in the input file. 

Option angstrom        1.8897261328856432
Option pm              0.018897261328856432
Option picometer       0.018897261328856432
Option nm              18.897261328856432
Option nanometer       18.897261328856432
Option ry              0.5
Option rydberg         0.5
Option ev              0.03674932539796232
Option electronvolt    0.03674932539796232
Option invcm           4.5563353e-06
Option kelvin          3.1668105e-06
Option kjoule_mol      0.00038087988
Option kcal_mol        0.0015936014
Option as              0.0413413737896
Option attosecond      0.0413413737896
Option fs              41.3413737896
Option femtosecond     41.3413737896
Option ps              41341.3737896
Option picosecond      41341.3737896
Option c               137.035999139
END

Variable UnitsOutput
Type integer
Default atomic
Section Execution::Units
Description
 This variable selects the units that Octopus use for output. 

 Atomic  units  seem  to be the preferred system in the atomic and molecular
 physics community. Internally, the code works in atomic units. However, for
 output,  some  people like to use a system based on electron-Volts (eV) for
 energies and Angstroms (&Aring;) for length. 

 Normally  time  units  are  derived  from energy and length units, so it is
 measured in \hbar/Hartree or 
 \hbar/eV. 

 Warning  1: All files read on input will also be treated using these units,
 including XYZ geometry files. 

 Warning  2: Some values are treated in their most common units, for example
 atomic  masses  (a.m.u.),  electron  effective  masses  (electron  mass),
 vibrational  frequencies  (cm<sup>-1</sup>)  or  temperatures (Kelvin). The
 unit of charge is always the electronic charge _e_. 

Option atomic        0
 Atomic units. 
Option ev_angstrom   1
 Electronvolts  for  energy, Angstroms for length, the rest of the units are
 derived from these and \hbar=1. 
END

Variable UnitsXYZFiles
Type integer
Default angstrom_units
Section Execution::Units
Description
 This variable selects in which units I/O of XYZ files should be performed. 
Option bohr_units       0
 The XYZ will be assumed to be in Bohr atomic units. 
Option angstrom_units   1
 XYZ  files  will  be assumed to be always in Angstrom, independently of the
 units  used by Octopus. This ensures compatibility with most programs, that
 assume XYZ files have coordinates in Angstrom. 
END

Variable ProfilingMode
Default no
Type integer
Section Execution::Optimization
Description
 Use this variable to run Octopus in profiling mode. In this mode 
 Octopus  records the time spent in certain areas of the code and the number
 of  times  this  code  is  executed.  These  numbers  are  written  in
 ./profiling.NNN/profiling.nnn  with  nnn  being  the  node  number  (000 in
 serial)  and  NNN  the number of processors. This is mainly for development
 purposes. Note, however, that 
 Octopus  should  be  compiled  with --disable-debug to do proper profiling.
 Warning: you may encounter strange results with OpenMP. 
Option no 0
 No profiling information is generated. 
Option prof_time 1
 Profile the time spent in defined profiling regions. 
Option prof_memory 2
 As  well  as  the time, summary information on memory usage and the largest
 arrays are reported. 
Option prof_memory_full 4
 As  well  as  the time and summary memory information, a log is reported of
 every allocation and deallocation. 
Option likwid 8
 Enable instrumentation using LIKWID. 
Option prof_io 16
 Count the number of file open and close. 
END

Variable ProfilingAllNodes
Default no
Type logical
Section Execution::Optimization
Description
 This  variable  controls whether all nodes print the time profiling output.
 If  set  to  no, the default, only the root node will write the profile. If
 set to yes, all nodes will print it. 
END

Variable MemoryLimit
Default -1
Type integer
Section Execution::Optimization
Description
 If positive, Octopus will stop if more memory than MemoryLimit is requested
 (in kb). Note that this variable only works when 
 ProfilingMode = prof_memory(_full). 
END

Variable ProfilingOutputYAML
Default no
Type logical
Section Execution::Optimization
Description
 This variable controls whether the profiling output is additionally written
 to a YAML file. 
END

Variable ProfilingOutputTree
Default yes
Type logical
Section Execution::Optimization
Description
 This variable controls whether the profiling output is additionally written
 as a tree. 
END

Variable stdout
Type string
Default "-"
Section Execution::IO
Description
 The  standard output by default goes to, well, to standard output. This can
 be changed by setting this variable: if you give it a name (other than "-")
 the output stream is printed in that file instead. 
END

Variable stderr
Type string
Default "-"
Section Execution::IO
Description
 The standard error by default goes to, well, to standard error. This can be
 changed  by  setting  this variable: if you give it a name (other than "-")
 the output stream is printed in that file instead. 
END

Variable WorkDir
Type string
Default "."
Section Execution::IO
Description
 By default, all files are written and read from the working directory, 
 _i.e._  the directory from which the executable was launched. This behavior
 can be changed by setting this variable. If you set WorkDir to a name other
 than ".", the following directories are written and read in that directory:
 
<ul>
  *) "casida/" 
  *) "em_resp_fd/" 
  *) "em_resp/" 
  *) "geom/" 
  *) "kdotp/" 
  *) "local.general" 
  *) "pcm/" 
  *) "profiling/" 
  *) "restart/" 
  *) "static/" 
  *) "td.general/" 
  *) "vdw/" 
  *) "vib_modes/" 
</ul>
 Furthermore,  some  of the debug information (see Debug) is also written to
 WorkDir and the non-absolute paths defined in OutputIterDir are relative to
 WorkDir. 
END

Variable LatticeParameters
Type block
Section Mesh::Simulation Box
Description
 The  lattice  parameters (a, b, c). This variable is mandatory for periodic
 systems  and  is  ignored  otherwise. When PeriodicDimensions = 3, a second
 optional line can be used to define the angles between the lattice vectors.
 If  the  angles  are not provided, then the variable LatticeVectors must be
 set. The number of parameters specified in the block must be at least equal
 to  the  number  of periodic dimensions, but it is not mandatory to specify
 parameters  for  the  non-periodic dimensions (in that case they are set to
 1). 
END

Variable LatticeVectors
Type block
Default simple cubic
Section Mesh::Simulation Box
Description
 Primitive lattice vectors. Vectors are stored in rows. Default: 
 %LatticeVectors 
   1.0 | 0.0 | 0.0 
   0.0 | 1.0 | 0.0 
   0.0 | 0.0 | 1.0 
 % 
END

Variable DisableAccel
Type logical
Default yes
Section Execution::Accel
Description
 If  Octopus  was  compiled  with  OpenCL  or  CUDA  support, it will try to
 initialize  and  use an accelerator device. By setting this variable to yes
 you force Octopus not to use an accelerator even it is available. 
END

Variable AccelPlatform
Type integer
Default 0
Section Execution::Accel
Description
 This  variable  selects  the OpenCL platform that Octopus will use. You can
 give  an  explicit  platform number or use one of the options that select a
 particular vendor implementation. Platform 0 is used by default. 

 This variable has no effect for CUDA. 
Option amd -2
 Use the AMD OpenCL platform. 
Option nvidia -3
 Use the Nvidia OpenCL platform. 
Option ati -4
 Use the ATI (old AMD) OpenCL platform. 
Option intel -5
 Use the Intel OpenCL platform. 
END

Variable AccelDevice
Type integer
Default gpu
Section Execution::Accel
Description
 This  variable  selects  the OpenCL or CUDA accelerator device that Octopus
 will  use.  You  can  specify one of the options below or a numerical id to
 select a specific device. 

 Values  >=  0  select  the  device  to be used. In case of MPI enabled runs
 devices are distributed in a round robin fashion, starting at this value. 
Option gpu -1
 If available, Octopus will use a GPU. 
Option cpu -2
 If available, Octopus will use a CPU (only for OpenCL). 
Option accelerator -3
 If available, Octopus will use an accelerator (only for OpenCL). 
Option accel_default -4
 Octopus  will  use  the  default  device  specified  by the implementation.
 implementation. 
END

Variable AccelBenchmark
Type logical
Default no
Section Execution::Accel
Description
 If this variable is set to yes, Octopus will run some routines to benchmark
 the performance of the accelerator device. 
END

Variable CudaAwareMPI
Type logical
Section Execution::Accel
Description
 If  Octopus  was  compiled with CUDA support and MPI support and if the MPI
 implementation  is CUDA-aware (i.e., it supports communication using device
 pointers),  this  switch  can  be  set  to  true  to use the CUDA-aware MPI
 features.  The  advantage  of  this  approach  is  that  it  can  do, e.g.,
 peer-to-peer copies between devices without going through the host memmory.
 The  default is false, except when the configure switch --enable-cudampi is
 set, in which case this variable is set to true. 
END

Variable AllowCPUonly
Type logical
Section Execution::Accel
Description
 In  order  to  prevent waste of resources, the code will normally stop when
 the GPU is disabled due to incomplete implementations or incompatibilities.
 AllowCPUonly  =  yes  overrides  this and allows the code execution also in
 these cases. 
END

Variable InitializeGPUBuffers
Type logical
Section Execution::Accel
Description
 Initialize  new GPU buffers to zero on creation (use only for debugging, as
 it has a performance impact!). 
END

Variable Walltime
Type float
Default 0
Section Execution::IO
Description
 Time  in  minutes before which the restart file will be written. This is to
 make  sure  that  at  least one restart file can be written before the code
 might  be  killed  to to exceeding the given CPU time. If a finite time (in
 minutes)  is  specified, the code will write the restart file when the next
 iteration  (plus the RestartWriteTime) would exceed the given time. A value
 less than 1 second (1/60 minutes) will disable the timer. 
END

Variable RestartWriteTime
Type float
Default 5
Section Execution::IO
Description
 The  RestartWriteTime  (in minutes) will be subtracted from the WallTime to
 allow  time  for writing the restart file. In huge calculations, this value
 should be increased. 
END

Variable RestartWallTimePeriod
Type float
Default 120
Section Execution::IO
Description
 Period  Time  (in  minutes) at which the restart file will be written. If a
 finite time (in minutes) is specified, the code will write the restart file
 every period. 
END

Variable Debug
Type flag
Default no
Section Execution::Debug
Description
 This  variable  controls  the  amount of debugging information generated by
 Octopus. You can use include more than one option with the + operator. 
Option no 0
 (default) Octopus does not enter debug mode. 
Option info 1
 Octopus prints additional information to the terminal. 
Option trace 2
 Octopus  generates  a  stack trace as it enters end exits subroutines. This
 information is reported if Octopus stops with an error. 
Option trace_term 4
 The  trace  is  printed  to  the  terminal  as  Octopus  enters  or  exits
 subroutines. This slows down execution considerably. 
Option trace_file 8
 The  trace  is written to files in the debug directory. For each node (when
 running in parallel) there is a file called 
 debug_trace.&lt;rank&gt;. Writing these files slows down the code by a huge
 factor and it is usually only necessary for parallel runs. 
Option extra_checks 16
 This  enables  Octopus  to  perform  some  extra  checks,  to  ensure  code
 correctness, that might be too costly for regular runs. 
Option interaction_graph 32
 Octopus generates a dot file containing the graph for a multisystem run. 
Option interaction_graph_full 64
 Octopus  generates  a  dot  file containing the graph for a multisystem run
 including ghost interactions. 
Option propagation_graph 128
 Octopus generates a file with information for the propagation diagram. 
END

Variable MPIDebugHook
Type logical
Default no
Section Execution::Debug
Description
 When  debugging  the  code  in parallel it is usually difficult to find the
 origin  of race conditions that appear in MPI communications. This variable
 introduces a facility to control separate MPI processes. If set to yes, all
 nodes  will  start  up,  but  will get trapped in an endless loop. In every
 cycle of the loop each node is sleeping for one second and is then checking
 if  a  file with the name node_hook.xxx (where xxx denotes the node number)
 exists.  A  given  node  can  only  be  released  from  the  loop  if  the
 corresponding  file  is  created. This allows to selectively run, _e.g._, a
 compute  node  first followed by the master node. Or, by reversing the file
 creation  of  the node hooks, to run the master first followed by a compute
 node. 
END

Variable ExperimentalFeatures
Type logical
Default no
Section Execution::Debug
Description
 If  true,  allows the use of certain parts of the code that are still under
 development  and  are  not suitable for production runs. This should not be
 used unless you know what you are doing. See details on 
 <a href=http://octopus-code.org/experimental_features>wiki page</a>. 
END

Variable DebugTrapSignals
Type logical
Default yes
Section Execution::Debug
Description
 If  true,  trap signals to handle them in octopus itself and print a custom
 backtrace.  If false, do not trap signals; then, core dumps can be produced
 or  gdb  can  be  used  to  stop at the point a signal was produced (e.g. a
 segmentation fault). 
END

Variable ReorderRanks
Default no
Type logical
Section Execution::Parallelization
Description
 This  variable  controls  whether  the ranks are reorganized to have a more
 compact  distribution with respect to domain parallelization which needs to
 communicate  most  often.  Depending  on  the  system,  this  can  improve
 communication speeds. 
END

Variable ParDomains
Type integer
Default auto
Section Execution::Parallelization
Description
 This  variable  controls  the  number  of  processors  used  for  the
 parallelization  in  domains.  The  special  value  auto, the default, lets
 Octopus  decide  how many processors will be assigned for this strategy. To
 disable parallelization in domains, you can use 
 ParDomains = no (or set the number of processors to 1). 

 The  total  number  of  processors  required  is  the multiplication of the
 processors assigned to each parallelization strategy. 
Option auto -1
 The number of processors is assigned automatically. 
Option no 0
 This parallelization strategy is not used. 
END

Variable ParStates
Type integer
Section Execution::Parallelization
Description
 This  variable  controls  the  number  of  processors  used  for  the
 parallelization  in  states. The special value auto lets Octopus decide how
 many  processors  will  be  assigned  for  this  strategy.  To  disable
 parallelization in states, you can use 
 ParStates = no (or set the number of processors to 1). 

 The default value depends on the CalculationMode. For 
 CalculationMode  =  td  the  default is auto, while for for other modes the
 default is no. 

 The  total  number  of  processors  required  is  the multiplication of the
 processors assigned to each parallelization strategy. 
Option auto -1
 The number of processors is assigned automatically. 
Option no 0
 This parallelization strategy is not used. 
END

Variable ParKPoints
Type integer
Default auto
Section Execution::Parallelization
Description
 This  variable  controls  the  number  of  processors  used  for  the
 parallelization  in  K-Points  and/or  spin.  The  special  value auto lets
 Octopus  decide  how many processors will be assigned for this strategy. To
 disable parallelization in KPoints, you can use ParKPoints = no (or set the
 number of processors to 1). 

 The  total  number  of  processors  required  is  the multiplication of the
 processors assigned to each parallelization strategy. 
Option auto -1
 The number of processors is assigned automatically. 
Option no 0
 This parallelization strategy is not used. 
END

Variable ParOther
Type integer
Default auto
Section Execution::Parallelization
Description
 This  variable  controls  the  number  of  processors  used for the 'other'
 parallelization mode, that is CalculatioMode dependent. For CalculationMode
 = casida, it means parallelization in electron-hole pairs. 

 The  special  value  auto,  the  default,  lets  Octopus  decide  how  many
 processors  will  be assigned for this strategy. To disable parallelization
 in Other, you can use ParOther = no (or set the number of processors to 1).
 

 The  total  number  of  processors  required  is  the multiplication of the
 processors assigned to each parallelization strategy. 
Option auto -1
 The number of processors is assigned automatically. 
Option no 0
 This parallelization strategy is not used. 
END

Variable ParallelizationNumberSlaves
Type integer
Default 0
Section Execution::Parallelization
Description
 Slaves are nodes used for task parallelization. The number of such nodes is
 given  by  this variable multiplied by the number of domains used in domain
 parallelization. 
END

Variable Dimensions
Type integer
Section System
Default 3
Description
 Octopus  can  run  in  1, 2 or 3 dimensions, depending on the value of this
 variable  (or  more,  if  configured with --with-max-dim=4 or higher). Note
 that not all input variables may be available in all cases. 
END

Variable PeriodicDimensions
Type integer
Default 0
Section System
Description
 Define  how  many  directions are to be considered periodic. It has to be a
 number between zero and Dimensions. 
Option 0
 No direction is periodic (molecule). 
Option 1
 The _x_ direction is periodic. 
Option 2
 The _x_ and _y_ directions are periodic. 
Option 3
 The _x_, _y_, and _z_ directions are periodic. 
END

Variable ParticleCharge
Type float
Section ClassicalParticles
Description
 Charge of classical particle 
END

Variable ParticleMass
Type float
Section ClassicalParticles
Description
 Mass of classical particle in Kg. 
END

Variable ParticleInitialPosition
Type block
Section ClassicalParticles
Description
 Initial position of classical particle, in Km. 
END

Variable ParticleInitialVelocity
Type block
Section ClassicalParticles
Description
 Initial velocity of classical particle in Km/s. 
END

Variable TDTDMFrequencies
Type block
Section Utilities::oct-tdtdm
Description
 This block defines for which frequencies the analysis is performed. 

 Each row of the block indicates a frequency. 
END

Variable SupercellDimensions
Type block
Default KPointsGrid
Section Utilities::oct-tdtdm
Description
 This  block  allows  to  specify  the  size  of  the supercell used to plot
 excitonic  wavefunctions.  If  not  specified,  the code uses the number of
 k-points for defining the size of the supercell. 
END

Variable TDTDMHoleCoordinates
Type float
Section Utilities::oct-tdtdm
Description
 The  position  of  the  hole  used  to  compute  the  TDTDM,  in  Cartesian
 coordinates. Note that the code will use the closest grid point. 

 The coordinates of the hole are specified in the following way 
 %TDTDMHoleCoordinates 
   hole_x | hole_y | hole_z 
 % 

 If  TDTDMHoleCoordinates  or TDTDMHoleReducedCoordinates are not specified,
 the code will use the coordinate of the first atom in the cell. 
END

Variable TDTDMHoleReducedCoordinates
Type float
Section Utilities::oct-tdtdm
Description
 Same  as TDTDMHoleCoordinates, except that coordinates are given in reduced
 coordinates 
END

Variable MainAxis
Type block
Section Utilities::oct-center-geom
Description
 A  vector  of  reals  defining  the  axis  to  which the molecule should be
 aligned.  If not present, the default value will be the x-axis. For example
 in 3D: 
  
 %MainAxis 
  1 | 0 | 0 
 % 
END

Variable AxisType
Type integer
Default inertia
Section Utilities::oct-center-geom
Description
 After  the structure is centered, it is also aligned to a set of orthogonal
 axes.  This variable decides which set of axes to use. Only implemented for
 3D, in which case the default is inertia; otherwise none is default and the
 only legal value. 
Option none 0
 Do  not  rotate. Will still give output regarding center of mass and moment
 of inertia. 
Option inertia 1
 The axis of inertia. 
Option pseudo_inertia 2
 Pseudo-axis  of  inertia,  calculated considering all species to have equal
 mass. 
Option large_axis 3
 The larger axis of the molecule. 
END

Variable TransientAbsorptionReference
Type string
Default "."
Section Utilities::oct-propagation_spectrum
Description
 In  case  of  delayed  kick,  the  calculation  of the transient absorption
 requires  to  substract a reference calculation, containing the gauge-field
 without  the  kick  This  reference  must  be  computed  using
 GaugeFieldPropagate=yes  and to have TDOutput = gauge_field. This variables
 defined the directory in which the reference gauge_field field is, relative
 to the current folder 
END

Variable LDOutput
Type flag
Default multipoles
Section Utilities::oct-local_multipoles
Description
 Defines  what should be output during the local domains simulation. Many of
 the  options can increase the computational cost of the simulation, so only
 use  the  ones that you need. In most cases the default value is enough, as
 it is adapted to the details. 
Option multipoles 1
 Outputs  the  (electric)  multipole  moments  of  the  density  to the file
 ld.general/multipoles.  This  is  required  to,  _e.g._,  calculate optical
 absorption  spectra  of  finite  systems. The maximum value of l can be set
 with the variable LDMultipoleLmax. 
Option density 2
 If set, octopus outputs the densities corresponding to the local domains to
 the  folder  ld.general/densities.  The  output  format  is  set  by  the
 LDOutputFormat input variable. 
Option local_v 4
 If  set,  octopus  outputs the different components of the potential to the
 folder ld.general/potential. The output format is set by the LDOutputFormat
 input variable. 
Option energy 8
 If set, octopus outputs the different components of the energy of the local
 domains to the folder ld.general/energy. 
END

Variable LDOutputFormat
Type flag
Default none
Section Utilities::oct-local_multipoles
Description
 Describes  the  format  of the output files (see LDOutput). It can take the
 same values as OutputFormat flag. 
END

Variable LDMultipoleLmax
Type integer
Default 1
Section Utilities::oct-local_multipoles
Description
 Maximum  electric  multipole  of  the  density  output  to  the  file
 local.multipoles/<>domain%<>.multipoles during a time-dependent simulation.
 Must be non-negative. 
END

Variable LDIonicDipole
Type logical
Default yes
Section Utilities::oct-local_multipoles
Description
 Describes  if  the  ionic dipole has to be take into account when computing
 the multipoles. 
END

Variable TransientMagnetizationReference
Type string
Default "."
Section Utilities::oct-spin_susceptibility
Description
 In  case  of  delayed  kick,  the  calculation  of  the  transient  spin
 susceptibility  requires  to  substract a reference calculation, containing
 dynamics  of  the  magnetization  without  the  kick This reference must be
 computed  having TDOutput = total_magnetization. This variables defined the
 directory  in  which the reference total_magnetization file is, relative to
 the current folder 
END

Variable ConductivitySpectrumTimeStepFactor
Type integer
Default 1
Section Utilities::oct-conductivity_spectrum
Description
 In  the  calculation  of  the conductivity, it is not necessary to read the
 velocity  at  every  time  step.  This variable controls the integer factor
 between  the  simulation  time step and the time step used to calculate the
 conductivity. 
END

Variable ConductivityFromForces
Type logical
Default no
Section Utilities::oct-conductivity_spectrum
Description
 (Experimental)  If  enabled,  Octopus  will  attempt  to  calculate  the
 conductivity from the forces instead of the current. 
END

Variable Wannier90Prefix
Type string
Default w90
Section Utilities::oct-wannier90
Description
 Prefix for wannier90 files 
END

Variable Wannier90Mode
Type integer
Default 0
Section Utilities::oct-wannier90
Description
 Specifies which stage of the Wannier90 interface to use 
Option none 0
 Nothing is done. 
Option w90_setup 1
 Writes  parts  of  the wannier90 input file w90_prefix.win corresponding to
 the  octopus  inp  file.  Importantly  it  generates  the  correct  form of
 Monkhorst-Pack  mesh written to the file w90_kpoints that has to be used in
 a  gs  calculation  of  Octopus  by as  include w90_kpoints  instead of the
 %KpointsGrid block. 
Option w90_output 2
 Generates the relevant files for a wannier90 run, specified by the variable
 W90_interface_files.  This  needs files previously generated by wannier90.x
 -pp w90  
Option w90_wannier 3
 Parse  the  output  of  wannier90  to  generate  the  Wannier states on the
 real-space  grid.  The  states  will  be  written in the folder wannier. By
 default,  the  states are written as binary files, similar to the Kohn-Sham
 states. 

 Not implemented for spinor states. 
END

Variable Wannier90Files
Type flag
Default w90_mmn + w90_amn + w90_eig
Section Utilities::oct-wannier90
Description
 Specifies which files to generate. Example: w90_mmn + w90_unk 
Option w90_mmn bit(1)
 (see Wannier90 documentation) 
Option w90_unk bit(2)
 (see Wannier90 documentation) 
Option w90_amn bit(3)
 (see Wannier90 documentation) 
Option w90_eig bit(4)
 Eigenvalues. See Wannier90 documentation for more details. 
END

Variable Wannier90UseTD
Type logical
Default no
Section Utilities::oct-wannier90
Description
 By  default  oct-wannier90  uses  the  ground-state  states  to compute the
 necessary  information. By setting this variable to yes, oct-wannier90 will
 use the TD states instead. 
END

Variable Wannier90UseSCDM
Type logical
Default no
Section Utilities::oct-wannier90
Description
 By  default  oct-wannier90  uses the projection method to generate the .amn
 file.  By  setting this variable to yes, oct-wannier90 will use SCDM method
 instead. 
END

Variable SCDMsigma
Type float
Default 0.2
Section Utilities::oct-wannier90
Description
 Broadening of SCDM smearing function. 
END

Variable SCDMmu
Type float
Section Utilities::oct-wannier90
Description
 Energy range up to which states are considered for SCDM. 
END

Variable ConvertFilename
Type string
Default "density"
Section Utilities::oct-convert
Description
 Input filename. The original filename which is going to be converted in the
 format  specified in OutputFormat. It is going to convert various files, it
 should only contain the beginning of the name. For instance, in the case of
 the restart files, it should be one space ' '. 
END

Variable ConvertHow
Type integer
Default convert_format
Section Utilities::oct-convert
Description
 Select how the mesh function will be converted. 
Option format 1
 The  format  of the mesh function will be convert from the binary file.obf.
 The format of the output function is set by OutputHow variable. 
Option fourier_transform 2
 A  fourier  transform  of  the mesh function will be computed. It requieres
 that ConvertStart and ConvertEnd have to be set. 
Option operation 3
 Convert  utility  will  generate  a new mesh function constructed by linear
 combination of scalar function of different mesh functions, 
END

Variable ConvertIterateFolder
Type logical
Default true
Section Utilities::oct-convert
Description
 This  variable  decides if a folder is going to be iterated or the filename
 is going to be iterated. 
END

Variable ConvertFolder
Type string
Section Utilities::oct-convert
Description
 The folder name where the input files are. The default is 
 td. if ConvertIterateFolder = true, otherwise restart. 
END

Variable ConvertStart
Type integer
Section Utilities::oct-convert
Description
 The  starting  number  of  the  filename  or  folder.  Default  is  0  if
 ConvertIterateFolder = true, otherwise 1. 
END

Variable ConvertEnd
Type integer
Default 1
Section Utilities::oct-convert
Description
 The last number of the filename or folder. 
END

Variable ConvertStep
Type integer
Default 1
Section Utilities::oct-convert
Description
 The padding between the filenames or folder. 
END

Variable ConvertSubtractFilename
Type string
Default density
Section Utilities::oct-convert
Description
 Input filename. The file which is going to subtracted to rest of the files.
 
END

Variable ConvertSubtract
Type logical
Default false
Section Utilities::oct-convert
Description
 Decides if a reference file is going to be subtracted. 
END

Variable ConvertSubtractFolder
Type string
Default .
Section Utilities::oct-convert
Description
 The folder name which is going to be subtracted. 
END

Variable ConvertEnergyMin
Type float
Default 0.0
Section Utilities::oct-convert
Description
 Minimum energy to output from Fourier transform. 
END

Variable ConvertReadSize
Type integer
Default mesh%np
Section Utilities::oct-convert
Description
 How  many  points  are read at once. For the parallel run this has not been
 yet  tested,  so it should be one. For the serial run, a number of 100-1000
 will speed-up the execution time by this factor. 
END

Variable ConvertEnergyMax
Type float
Default w_max
Section Utilities::oct-convert
Description
 Maximum energy to output from Fourier transform. 
END

Variable ConvertFTMethod
Type integer
Default FAST_FOURIER
Section Utilities::oct-convert
Description
 Describes the method used to perform the Fourier Transform 
Option fast_fourier 1
 Uses Fast Fourier Transform as implemented in the external library. 
Option standard_fourier 2
 Uses  polinomial approach to the computation of discrete Fourier Transform.
 It  uses  the  same  variable  described  in  how to obtain spectrum from a
 time-propagation calculation. 
END

Variable ConvertEnergyStep
Type float
Default <math>2 \pi / T</math>, where <math>T</math> is the total propagation time
Section Utilities::oct-convert
Description
 Energy step to output from Fourier transform. Sampling rate for the Fourier
 transform.  If  you  supply  a  number equal or smaller than zero, then the
 sampling rate will be 2 \pi / T, where T is the total propagation time. 
END

Variable ConvertScalarOperation
Type block
Section Utilities::oct-convert
Description
 This  variable  is  used  to  generate  a  new  mesh  function  as a linear
 combination  different mesh function having the same mesh. Each row defines
 an operation for for a single mesh function. The format of the block is the
 following:  'variable name' | 'folder' | 'file' | 'operation' 
END

Variable ConvertOutputFolder
Type string
Section Utilities::oct-convert
Description
 The folder name where the output files will be write. The default is 
 convert. 
END

Variable ConvertOutputFilename
Type string
Default "density"
Section Utilities::oct-convert
Description
 Output  filename. The name of the file in which the converted mesh function
 will be written in the format specified in OutputFormat. 
END

Variable UnfoldMode
Type flag
Default none
Section Utilities::oct-unfold
Description
 Specifies which stage of the unfolding tool to use 
Option unfold_setup bit(1)
 Writes  the  list  of  k-points  corresponding  to  the  path  specified by
 UnfoldKPointPath. This list of k-point (unfold_kpt.dat) must be used for an
 unocc  calculation  of  the  supercell,  adding  the  line  "include
 'unfold_kpt.dat'" to the inp file and removing the KPointGrid information. 
Option unfold_run bit(2)
 Perform  the  actual  unfolding,  based  on  the  states  obtained from the
 previous unocc run. 
END

Variable UnfoldLatticeParameters
Type block
Section Utilities::oct-unfold
Description
 The  lattice  parameters  of  the  primitive  cell,  on  which unfolding is
 performed.  See  the  LatticeParameters  variable  for  a  more  detailed
 description. 
END

Variable UnfoldLatticeVectors
Type block
Default simple cubic
Section Utilities::oct-unfold
Description
 Lattice  vectors of the primitive cell on which the unfolding is performed.
 See the LatticeVectors variable for a more detailed description. 
END

Variable UnfoldKPointsPath
Type block
Section Utilities::oct-unfold
Description
 Specifies  the  k-point  path  for which the unfolding need to be done. The
 syntax is identical to KPointsPath. 
END

Variable UnfoldEnergyStep
Type float
Default 0
Section Utilities::oct-unfold
Description
 Specifies  the  energy  resolution  for the unfolded band structure. If you
 specify  0,  the  resolution  will  be  set  to  be  1/1000  points between
 UnfoldMinEnergy and UnfoldMaxEnergy 
END

Variable UnfoldMinEnergy
Type float
Section Utilities::oct-unfold
Description
 Specifies  the  start  of the energy range for the unfolded band structure.
 The default value correspond to the samllest eigenvalue. 
END

Variable UnfoldMaxEnergy
Type float
Section Utilities::oct-unfold
Description
 Specifies  the end of the energy range for the unfolded band structure. The
 default value correspond to the largest eigenvalue. 
END

Variable VibrationalSpectrumTimeStepFactor
Type integer
Default 10
Section Utilities::oct-vibrational_spectrum
Description
 In the calculation of the vibrational spectrum, it is not necessary to read
 the  velocity at every time step. This variable controls the integer factor
 between  the  simulation  time step and the time step used to calculate the
 vibrational spectrum. 
END

Variable VibrationalSpectrumTime
Type integer
Section Utilities::oct-vibrational_spectrum
Description
 This variable controls the maximum time for the calculation of the velocity
 autocorrelation function. The default is the total propagation time. 
END

Variable LDFolder
Type string
Section Utilities::oct-local_multipoles
Description
 The folder name where the density used as input file is. 
END

Variable LDFilename
Type string
Default 'density'
Section Utilities::oct-local_multipoles
Description
 Input  filename. The original filename for the density which is going to be
 fragmented into domains. 
END

Variable LDUpdate
Type logical
Default false
Section Utilities::oct-local_multipoles
Description
 Controls  if  the  calculation  of  the  local  domains  is desired at each
 iteration. 
END

Variable LDOverWrite
Type logical
Default true
Section Utilities::oct-local_multipoles
Description
 Controls whether to over-write existing files. 
END

Variable LDRadiiFile
Type string
Default 'default'
Section Utilities::oct-local_multipoles
Description
 Full  path  for  the radii file. If set, def_rsize will be reset to the new
 values. This file should have the same format as share/PP/default. 
END

Variable LDRestart
Type logical
Default false
Section Utilities::oct-local_multipoles
Description
 Restart information will be read from LDRestartFolder. 
END

Variable LDRestartFolder
Type string
Default "ld.general"
Section Utilities::oct-local_multipoles
Description
 The folder name where the density used as input file is. 
END

Variable LDIterateFolder
Type logical
Default false
Section Utilities::oct-local_multipoles
Description
 This variable decides if a folder is going to be iterated. 
END

Variable LDStart
Type integer
Default 0
Section Utilities::oct-local_multipoles
Description
 The starting number of the filename or folder. 
END

Variable LDEnd
Type integer
Default 0
Section Utilities::oct-local_multipoles
Description
 The last number of the filename or folder. 
END

Variable LDStep
Type integer
Default 1
Section Utilities::oct-local_multipoles
Description
 The padding between the filenames or folder. 
END

Variable LocalDomains
Type block
Section Utilities::oct-local_multipoles
Description
 The LocalDomains are by definition part of the global grid. The domains are
 defined by selecting a type shape. The domain box will be constructed using
 the  given  parameters.  A  local  domain could be construct by addition of
 several  box  centered  on  the  ions. The grid points inside this box will
 belong to the local domain. 

 The format of this block is the following: 
  'Label' | Shape | %< | Shape dependencies >%  
 The first field is the label of the domain. Label = string with the name of
 the  new  local  domain.  The  second  is the shape type of the box used to
 define  the  domain.  Shape  =  SPHERE,  CYLINDER, PARALLELEPIPED, MINIMUM,
 BADER. Some types may need some parameters given in the remaining fields of
 the row. (the valid options are detailed below). 

 %LocalDomains 
 case (SPHERE): | rsize | %<dim origin coordinates> 
 case (CYLINDER): | rsize | xsize | %<origin coordinates> 
 case (PARALLELEPIPED): | %<lsize> | %<origin coordinates> 
 case (MINIMUM): | rsize | 'center_list' 
 case (BADER): | 'center_list' 
 % 
 rsize: Radius in input length units 
 xsize: the length of the cylinder in the x-direction 
 origin  coordinates: in input length units separated by |, where the box is
 centered. 
 lsize: half of the length of the parallelepiped in each direction. 
 center_list:  string  containing  the  list  of  atoms in xyz file for each
 domain in the form "2,16-23" 
END

Variable LDBaderThreshold
Type float
Default 0.01
Section Utilities::oct-local_multipoles
Description
 This  variable  sets the threshold for the basins calculations. Recommended
 values: 0.01 -> intramolecular volumes; 0.2 -> intermolecular volumes. 
END

Variable LDUseAtomicRadii
Type logical
Default false
Section Utilities::oct-local_multipoles
Description
 If set, atomic radii will be used to assign lone pairs to ion. 
END

Variable PhotoelectronSpectrumOutput
Type block
Default none
Section Utilities::oct-photoelectron_spectrum
Description
 Specifies  what  to  output  extracting  the  photoelectron  cross-section
 informations.  When  we use polar coordinates the zenith axis is set by vec
 (default  is  the  first  laser  field  polarization  vector), theta is the
 inclination  angle  measured  from  vec  (from  0  to  \pi), and phi is the
 azimuthal  angle  on  a  plane  perpendicular to vec (from 0 to 2\pi). Each
 option  must be in a separate row. Optionally individual output formats can
 be  defined  for  each row or they can be read separately from OutputFormat
 variable in the input file. 

 Example (minimal): 
 %PhotoelectronSpectrumOutput 
   energy_tot 
   velocity_map 
 % 

 Example (with OutputFormat): 
 %PhotoelectronSpectrumOutput 
   arpes | vtk 
   velocity_map | ncdf 
 % 

Option energy_tot 1
 Output the energy-resolved photoelectron spectrum: E. 
Option energy_angle 2
 Output  the  energy  and  angle resolved spectrum: (theta, E) The result is
 integrated over phi. 
Option velocity_map_cut 3
 Velocity  map  on a plane orthogonal to pvec: (px, py). The allowed cutting
 planes (pvec) can only be parallel to the x,y,z=0 planes. Space is oriented
 so that the z-axis is along vec. Supports the -I option. 
Option energy_xy 4
 Angle  and energy-resolved spectrum on the inclination plane: (Ex, Ey). The
 result is integrated over ph; 
Option energy_th_ph 5
 Ionization probability integrated on spherical cuts: (theta, phi). 
Option velocity_map 6
 Full  momentum-resolved  ionization  probability:  (px, py, pz). The output
 format can be controlled with OutputHow and can be vtk, ncdf or ascii. 
Option arpes 7
 Full ARPES for semi-periodic systems (vtk). 
Option arpes_cut 8
 ARPES cut on a plane following a zero-weight path in reciprocal space. 
END

Variable PhotoelectronSpectrumResolveStates
Type block
Default
Section Utilities::oct-photoelectron_spectrum
Description
 If  yes  calculate  the photoelectron spectrum resolved in each K.S. state.
 Optionally a range of states can be given as two slot block where the first
 slot  is  the  lower  state  index  and  the second is the highest one. For
 example to calculate the spectra from state i to state j: 

 %PhotoelectronSpectrumResolveStates 
  i | j 
 % 
END

Variable AnimationSampling
Type integer
Default 100
Section Utilities::oct-xyz-anim
Description
 Sampling rate of the animation. The animation will be constructed using the
 iteration numbers that are multiples of AnimationSampling. 
END

Variable AnimationMultiFiles
Type logical
Default false
Section Utilities::oct-xyz-anim
Description
 If true, each iteration written will be in a separate file. 
END

Variable CasidaSpectrumBroadening
Type float
Default 0.005 Ha
Section Utilities::oct-casida_spectrum
Description
 Width of the Lorentzian used to broaden the excitations. 
END

Variable CasidaSpectrumEnergyStep
Type float
Default 0.001 Ha
Section Utilities::oct-casida_spectrum
Description
 Sampling rate for the spectrum. 
END

Variable CasidaSpectrumMinEnergy
Type float
Default 0.0
Section Utilities::oct-casida_spectrum
Description
 The broadening is done for energies greater than CasidaSpectrumMinEnergy. 
END

Variable CasidaSpectrumMaxEnergy
Type float
Default 1.0 Ha
Section Utilities::oct-casida_spectrum
Description
 The broadening is done for energies smaller than CasidaSpectrumMaxEnergy. 
END

Variable CasidaSpectrumRotationMatrix
Type block
Default identity
Section Utilities::oct-casida_spectrum
Description
 Supply  a  rotation matrix to apply to the transition dipoles in generating
 the  spectrum.  The  rotated  atomic structure will also be output. Size of
 matrix must be Dimensions. 
END

Variable NParticleModelmb
Type integer
Section States::ModelMB
Default  0
Description
 Number  of  particles  in  modelmb  space.  Full  Ndim  =
 NDimModelmb*NParticleModelmb 
END

Variable NDimModelmb
Type integer
Section States::ModelMB
Default 1
Description
 Number  of  dimensions  for  modelmb  space.  Full  Ndim  =
 NDimModelmb*NParticleModelmb 

END

Variable NTypeParticleModelmb
Type integer
Section States::ModelMB
Default 1
Description
 Number of different types of particles in modelmb space. 
END

Variable DescribeParticlesModelmb
Type block
Section States::ModelMB
Description
 Characterization  of  different  modelmb particles in space%dim dimensional
 space. 

 %DescribeParticlesModelmb 
    "proton" | 1 | 1800. | 1. | fermion 
    "proton" | 1 | 1800. | 1. | fermion 
    "electron" | 2 | 1. | 1. | fermion 
 % 

 would  tell  Octopus  that  there are presently 3 particles, called proton,
 proton,  and electron, with types 1, 1, and 2, and corresponding masses and
 charges.  All  particles should be fermions, and this can be later enforced
 on  the  spatial  part  of  the  wavefunctions.  The  label  and charge are
 presently  only  for  informational purposes and are not checked or used in
 Octopus. The interaction has to take the actual charge into account. 

Option fermion 1
 Particle is a fermion. 
Option boson 2
 Particle is a boson. 
Option anyon 3
 Particle is neither fermion nor boson. 
END

Variable SmearingFunction
Type integer
Default semiconducting
Section States
Description
 This  is  the  function  used  to  smear  the electronic occupations. It is
 ignored if the Occupations block is set. 
Option semiconducting 1
 Semiconducting  occupations,  _i.e._  the  lowest lying states are occupied
 until no more electrons are left. 
Option fermi_dirac 2
 Simple  Fermi-Dirac distribution. In this case, Smearing has the meaning of
 an electronic temperature. DN Mermin, _Phys. Rev._ *137*, A1441 (1965). 
Option cold_smearing 3
 N  Marzari, D Vanderbilt, A De Vita, and MC Payne, _Phys. Rev. Lett._ *82*,
 3296 (1999). 
Option methfessel_paxton 4
 M Methfessel and AT Paxton, _Phys. Rev. B_ *40*, 3616 (1989). In this case,
 the  variable  SmearingMPOrder  sets the order of the smearing. Occupations
 may be negative. 
Option spline_smearing 5
 Nearly  identical  to  Gaussian smearing. JM Holender, MJ Gillan, MC Payne,
 and AD Simpson, _Phys. Rev. B_ *52*, 967 (1995). 
END

Variable Smearing
Type float
Default 0.1 eV
Section States
Description
 If  Occupations  is  not  set,  Smearing  is the smearing width used in the
 SmearingFunction to distribute the electrons among the existing states. 
END

Variable SmearingMPOrder
Type integer
Default 1
Section States
Description
 Sets the order of the Methfessel-Paxton smearing function. 
END

Variable DensitytoCalc
Type block
Section States::ModelMB
Description
 Choice  of  which particle density (event. matrices) will be calculated and
 output, in the modelmb particles scheme. 

 %DensitytoCalc 
    "proton" | 1 | 10 
    "electron" | 2 | 15 
 % 

 would  ask octopus to calculate the density matrix corresponding to the 1st
 particle  (whose  coordinates  correspond to dimensions 1 to ndim_modelmb),
 which  is  an proton, then that corresponding to the 2nd particle (electron
 with  dimensions  ndim_modelmb+1  to  2*ndim_modelmb),  printing 10 natural
 orbitals for the first and 15 for the second. 

 %DensitytoCalc 
    "proton" | 1 | -1 
    "electron" | 2 | -1 
 % 

 would  ask  octopus  to  print out just the densities for particles 1 and 2
 without any density matrix output. 

END

Variable SpinComponents
Type integer
Default unpolarized
Section States
Description
 The  calculations  may  be  done  in  three different ways: spin-restricted
 (TD)DFT  (_i.e._,  doubly  occupied  "closed shells"), spin-unrestricted or
 "spin-polarized"  (TD)DFT  (_i.e._ we have two electronic systems, one with
 spin up and one with spin down), or making use of two-component spinors. 
Option unpolarized 1
 Spin-restricted calculations. 
Option polarized 2
Option spin_polarized 2
 (Synonym  polarized.) Spin-unrestricted, also known as spin-DFT, SDFT. This
 mode  will  double  the  number  of  wavefunctions  necessary  for  a
 spin-unpolarized calculation. 
Option non_collinear 3
Option spinors 3
 (Synonym: non_collinear.) The spin-orbitals are two-component spinors. This
 effectively  allows the spin-density to be oriented non-collinearly: _i.e._
 the  magnetization  vector  is  allowed  to  take  different  directions at
 different points. This vector is always in 3D regardless of Dimensions. 
END

Variable ExcessCharge
Type float
Default 0.0
Section States
Description
 The  net  charge  of  the system. A negative value means that we are adding
 electrons,  while  a  positive value means we are taking electrons from the
 system. 
END

Variable TotalStates
Type integer
Default 0
Section States
Description
 This  variable  sets the total number of states that Octopus will use. This
 is  normally  not  necessary  since  by  default Octopus sets the number of
 states  to  the  minimum  necessary  to  hold  the electrons present in the
 system. (This default behavior is obtained by setting TotalStates to 0). 

 If  you  want to add some unoccupied states, probably it is more convenient
 to use the variable 
 ExtraStates. 
END

Variable ExtraStates
Type integer
Default 0
Section States
Description
 The  number  of  states  is in principle calculated considering the minimum
 numbers  of  states  necessary to hold the electrons present in the system.
 The number of electrons is in turn calculated considering the nature of the
 species supplied in the 
 Species block, and the value of the ExcessCharge variable. However, one may
 command  Octopus to use more states, which is necessary if one wants to use
 fractional  occupational  numbers,  either fixed from the beginning through
 the  Occupations  block  or  by  prescribing an electronic temperature with
 Smearing,  or  in  order  to  calculate  excited  states  (including  with
 CalculationMode = unocc). 
END

Variable ExtraStatesToConverge
Type integer
Default 0
Section States
Description
 Only for unocc calculations. Specifies the number of extra states that will
 be  considered for reaching the convergence. Together with ExtraStates, one
 can  have some more states which will not be considered for the convergence
 criteria,  thus  making the convergence of the unocc calculation faster. By
 default, all extra states need to be converged. 
END

Variable StatesBlockSize
Type integer
Section Execution::Optimization
Description
 Some  routines work over blocks of eigenfunctions, which generally improves
 performance  at  the expense of increased memory consumption. This variable
 selects the size of the blocks to be used. If GPUs are used, the default is
 32; otherwise it is 4. 
END

Variable OnlyUserDefinedInitialStates
Type logical
Default no
Section States
Description
 If  true,  then  only  user-defined states from the block UserDefinedStates
 will  be  used as initial states for a time-propagation. No attempt is made
 to load ground-state orbitals from a previous ground-state run. 
END

Variable StatesRandomization
Type integer
Default par_independent
Section States
Description
 The  randomization  of states can be done in two ways: i) a parallelisation
 independent  way  (default),  where  the  random  states  are  identical,
 irrespectively  of  the number of tasks and ii) a parallelisation dependent
 way, which can prevent linear dependency to occur for large systems. 
Option par_independent 1
 Parallelisation-independent randomization of states. 
Option par_dependent 2
 The randomization depends on the number of taks used in the calculation. 
END

Variable SymmetrizeDensity
Type logical
Default no
Section States
Description
 When  enabled  the density is symmetrized. Currently, this can only be done
 for periodic systems. (Experimental.) 
END

Variable ForceComplex
Type logical
Default no
Section Execution::Debug
Description
 Normally  Octopus  determines  automatically  the  type  necessary  for the
 wavefunctions.  When set to yes this variable will force the use of complex
 wavefunctions. 

 Warning:  This variable is designed for testing and benchmarking and normal
 users need not use it. 
END

Variable RestartFixedOccupations
Type logical
Default yes
Section States
Description
 Setting  this  variable will make the restart proceed as if the occupations
 from the previous calculation had been set via the Occupations block, 
 _i.e._ fixed. Otherwise, occupations will be determined by smearing. 
END

Variable Occupations
Type block
Section States
Description
 The occupation numbers of the orbitals can be fixed through the use of this
 variable. For example: 

 %Occupations 
   2 | 2 | 2 | 2 | 2 
 % 

 would  fix the occupations of the five states to 2. There can be at most as
 many  columns as states in the calculation. If there are fewer columns than
 states,  then  the  code  will  assume  that  the  user  is  indicating the
 occupations  of  the  uppermost  states  where  all  lower states have full
 occupation  (i.e. 2 for spin-unpolarized calculations, 1 otherwise) and all
 higher states have zero occupation. The first column will be taken to refer
 to  the lowest state such that the occupations would be consistent with the
 correct  total  charge. For example, if there are 8 electrons and 10 states
 (from 
 ExtraStates = 6), then an abbreviated specification 

 %Occupations 
   1 | 0 | 1 
 % 

 would be equivalent to a full specification 

 %Occupations 
   2 | 2 | 2 | 1 | 0 | 1 | 0 | 0 | 0 | 0 
 % 

 This  is  an  example  of  use  for  constrained density-functional theory,
 crudely  emulating  a  HOMO->LUMO+1  optical excitation. The number of rows
 should  be  equal  to the number of k-points times the number of spins. For
 example,  for  a  finite system with SpinComponents == spin_polarized, this
 block  should  contain  two lines, one for each spin channel. All rows must
 have the same number of columns. 

 The  Occupations  block  is useful for the ground state of highly symmetric
 small  systems  (like an open-shell atom), to fix the occupation numbers of
 degenerate  states in order to help octopus to converge. This is to be used
 in  conjuction with ExtraStates. For example, to calculate the carbon atom,
 one would do: 

 ExtraStates = 2 
 %Occupations 
   2 | 2/3 | 2/3 | 2/3 
 % 

 If  you want the calculation to be spin-polarized (which makes more sense),
 you could do: 

 ExtraStates = 2 
 %Occupations 
    2/3 | 2/3 | 2/3 
    0 | 0 | 0 
 % 

 Note  that  in this case the first state is absent, the code will calculate
 four  states  (two  because  there  are  four  electrons,  plus two because
 ExtraStates = 2), and since it finds only three columns, it will occupy the
 first state with one electron for each of the spin options. 

 If  the  sum  of  occupations  is  not  equal  to  the  total charge set by
 ExcessCharge,  an  error  message  is  printed.  If  FromScratch  =  no and
 RestartFixedOccupations = yes, this block will be ignored. 
END

Variable RestartReorderOccs
Type logical
Default no
Section States
Description
 Consider  doing  a  ground-state  calculation, and then restarting with new
 occupations  set  with the Occupations block, in an attempt to populate the
 orbitals  of the original calculation. However, the eigenvalues may reorder
 as the density changes, in which case the occupations will now be referring
 to  different orbitals. Setting this variable to yes will try to solve this
 issue  when  the  restart data is being read, by reordering the occupations
 according  to  the  order  of  the  expectation  values  of  the  restart
 wavefunctions. 
END

Variable InitialSpins
Type block
Section States
Description
 The  spin  character  of  the initial random guesses for the spinors can be
 fixed  by  making  use of this block. Note that this will not "fix" the the
 spins during the calculation (this cannot be done in spinors mode, in being
 able  to  change  the  spins  is  why  the spinors mode exists in the first
 place). 

 This  block  is  meaningless  and ignored if the run is not in spinors mode
 (SpinComponents = spinors). 

 The structure of the block is very simple: each column contains the desired
 
 \left<  S_x  \right>,  \left<  S_y  \right>,  \left<  S_z \right>  for each
 spinor.  If the calculation is for a periodic system and there is more than
 one _k_-point, the spins of all the _k_-points are the same. 

 For  example,  if  we  have  two spinors, and we want one in the S_x "down"
 state, and another one in the S_x "up" state: 

 %InitialSpins 
     0.5 | 0.0 | 0.0 
    -0.5 | 0.0 | 0.0 
 % 

 WARNING:  if  the calculation is for a system described by pseudopotentials
 (as  opposed  to  user-defined potentials or model systems), this option is
 meaningless  since  the  random  spinors  are  overwritten  by  the  atomic
 orbitals. 

 This constraint must be fulfilled: 
  \left<  S_x  \right>^2  +  \left<  S_y  \right>^2 + \left< S_z \right>^2 =
 \frac{1}{4}  
END

Variable StatesPack
Type logical
Section Execution::Optimization
Description
 When  set  to  yes,  states  are  stored  in  packed  mode,  which improves
 performance  considerably. Not all parts of the code will profit from this,
 but should nevertheless work regardless of how the states are stored. 

 If  GPUs  are  used and this variable is set to yes, Octopus will store the
 wave-functions  in  device  (GPU)  memory. If there is not enough memory to
 store all the wave-functions, execution will stop with an error. 

 See also the related HamiltonianApplyPacked variable. 

 The default is yes. 
END

Variable StatesOrthogonalization
Type integer
Section SCF::Eigensolver
Description
 The full orthogonalization method used by some eigensolvers. The default is
 cholesky_serial,  except  with  state  parallelization,  the  default  is
 cholesky_parallel. 
Option cholesky_serial 1
 Cholesky  decomposition  implemented  using  BLAS/LAPACK.  Can be used with
 domain parallelization but not state parallelization. 
Option cholesky_parallel 2
 Cholesky  decomposition implemented using ScaLAPACK. Compatible with states
 parallelization. 
Option cgs 3
 Classical  Gram-Schmidt  (CGS)  orthogonalization.  Can be used with domain
 parallelization  but not state parallelization. The algorithm is defined in
 Giraud et al., Computers and Mathematics with Applications 50, 1069 (2005).
 
Option mgs 4
 Modified  Gram-Schmidt  (MGS)  orthogonalization.  Can  be used with domain
 parallelization  but not state parallelization. The algorithm is defined in
 Giraud et al., Computers and Mathematics with Applications 50, 1069 (2005).
 
Option drcgs 5
 Classical  Gram-Schmidt  orthogonalization  with  double-step
 reorthogonalization.  Can be used with domain parallelization but not state
 parallelization.  The  algorithm is taken from Giraud et al., Computers and
 Mathematics with Applications 50, 1069 (2005). According to this reference,
 this is much more precise than CGS or MGS algorithms. The MGS version seems
 not  to  improve  much  the stability and would require more communications
 over the domains. 
END

Variable StatesCLDeviceMemory
Type float
Section Execution::Optimization
Default -512
Description
 This  variable selects the amount of OpenCL device memory that will be used
 by Octopus to store the states. 

 A  positive  number smaller than 1 indicates a fraction of the total device
 memory.  A number larger than one indicates an absolute amount of memory in
 megabytes.  A  negative  number  indicates an amount of memory in megabytes
 that would be subtracted from the total device memory. 
END

Variable ScaLAPACKCompatible
Type logical
Section Execution::Parallelization
Description
 Whether to use a layout for states parallelization which is compatible with
 ScaLAPACK.  The  default is yes for CalculationMode = gs, unocc, go without
 k-point  parallelization,  and no otherwise. (Setting to other than default
 is  experimental.)  The  value  must  be  yes if any ScaLAPACK routines are
 called  in  the  course  of  the  run;  it  must be set by hand for td with
 TDDynamics  =  bo.  This variable has no effect unless you are using states
 parallelization  and  have  linked  ScaLAPACK.  Note:  currently,  use  of
 ScaLAPACK is not compatible with task parallelization (_i.e._ slaves). 
END

Variable CasidaKSEnergyWindow
Type float
Section Linear Response::Casida
Description
 An  alternative  to  CasidaKohnShamStates  for  specifying  which
 occupied-unoccupied  transitions  will  be used: all those whose eigenvalue
 differences  are  less  than  this number will be included. If a value less
 than 0 is supplied, this criterion will not be used. 
END

Variable CasidaKohnShamStates
Type string
Section Linear Response::Casida
Default all states
Description
 The  calculation  of  the  excitation  spectrum  of  a system in the Casida
 frequency-domain  formulation  of  linear-response  time-dependent  density
 functional  theory  (TDDFT)  implies  the  use  of  a  basis  set  of
 occupied/unoccupied  Kohn-Sham  orbitals.  This  basis  set  should,  in
 principle, include all pairs formed by all occupied states, and an infinite
 number  of  unoccupied  states. In practice, one has to truncate this basis
 set,  selecting  a  number of occupied and unoccupied states that will form
 the  pairs.  These  states  are specified with this variable. If there are,
 say,  15  occupied states, and one sets this variable to the value "10-18",
 this  means  that occupied states from 10 to 15, and unoccupied states from
 16 to 18 will be considered. 

 This  variable  is  a  string  in  list  form,  _i.e._  expressions such as
 "1,2-5,8-15"  are valid. You should include a non-zero number of unoccupied
 states and a non-zero number of occupied states. 
END

Variable UserDefinedInitialMaxwellStates
Type block
Section MaxwellStates
Description
 The  initial  electromagnetic  fields  can  be  set  by  the  user with the
 UserDefinedMaxwellStates block variable. The electromagnetic fields have to
 fulfill the Maxwells equations in vacuum. 

 Example: 

 %UserDefinedMaxwellStates 
    formula | 2 | "magnetic_field" | "-1/P_c * sin(x)" 
    formula | 3 | "electric_field" | " sin(x) " 
 % 

 The  second column specifies the component of the dimension of the electric
 field  and  magnetic  field.  The  first  column indicates that column four
 should  be interpreted as a formula for the corresponding state. P_c is the
 speed of light constant. 

 Alternatively,  if  column  one states file the electric field and magnetic
 field will be read from the files given in column four. 

 %UserDefinedMaxwellStates 
    file  |  3  |  electric_field  |
 "/path/to/file_electric_field_of_dimension_3" 
    file  |  2  |  magnetic_field  |
 "/path/to/file_magnetic_field_of_dimension_2" 
 % 

 The  third  option  to define the initial state inside the box is to extend
 the  plane  waves used as incident waves in the MaxwellIncidentWaves block,
 as follows: 

 %UserDefinedMaxwellStates 
    use_incident_waves 
 % 

Option file -10010
 Read initial orbital from file. Accepted file formats: obf, ncdf and csv. 
Option formula 1
 Calculate initial orbital by given analytic expression. 
Option use_incident_waves 2
 Extend  the  plane waves given in the MaxwellIncidentWaves block inside the
 box. 
Option electric_field 1
 This  row  defines  the  electric  field  component  of  the  corresponding
 dimension 
Option magnetic_field 2
 This  row  defines  the  magnetic  field  component  of  the  corresponding
 dimension 
END

Variable RiemannSilbersteinSign
Type integer
Default plus
Section Hamiltonian
Description
 Sign  for  the  imaginary  part  of  the  Riemann  Silberstein vector which
 represents the magnetic field 
Option plus 1
 Riemann Silberstein sign is plus 
Option minus -1
 Riemann Silberstein sign is minus 
END

Variable MaxwellFieldsCoordinate
Type block
Section Maxwell::Coordinates
Description
 The  Maxwell  MaxwellFieldsCoordinate block allows to output Maxwell fields
 at particular points in space. For each point a new line with three columns
 has  to  be  added  to  the block, where the columns denote the x, y, and z
 coordinate of the point. 

 %MaxwellFieldsCoordinate 
    -1.0 | 2.0 | 4.0 
    0.0 | 1.0 | -2.0 
 % 

END

Variable MomentumTransfer
Type block
Section Output
Description
 Momentum-transfer  vector  \vec{q}  to  be  used  when  calculating  matrix
 elements 
 \left< f \left| e^{i \vec{q} \cdot \vec{r}} \right| i \right>. This enables
 the calculation of the dynamical structure factor, which is closely related
 to  generalized  oscillator  strengths. If the vector is not given, but TPA
 output  is  requested  (Output  =  TPA),  only the oscillator strengths are
 written  in the output file. For example, to use \vec{q} = (0.1, 0.2, 0.3),
 set 

 %MomentumTransfer 
    0.1 | 0.2 | 0.3 
 % 
END

Variable BandStructureComputeProjections
Type logical
Default false
Section Output
Description
 Determines  if  projections  of  wavefunctions  on  the atomic orbitals are
 computed or not for obtaining the orbital resolved band-structure. 
END

Variable UserDefinedStates
Type block
Section States
Description
 Instead of using the ground state as initial state for time-propagations it
 might  be  interesting in some cases to specify alternate states. Like with
 user-defined  potentials, this block allows you to specify formulas for the
 orbitals at _t_=0. 

 Example: 

 %UserDefinedStates 
    1 | 1 | 1 | formula | "exp(-r^2)*exp(-i*0.2*x)" | normalize_yes 
 % 

 The  first  column specifies the component of the spinor, the second column
 the  number  of the state and the third contains _k_-point and spin quantum
 numbers.  Column four indicates that column five should be interpreted as a
 formula for the corresponding orbital. 

 Alternatively,  if  column four states file the state will be read from the
 file given in column five. 

 %UserDefinedStates 
    1 | 1 | 1 | file | "/path/to/file" | normalize_no 
 % 

 Octopus  reads  first  the  ground-state  orbitals  from  the  restart/gs
 directory.  Only  the  states that are specified in the above block will be
 overwritten with the given analytic expression for the orbital. 

 The  sixth  (optional)  column indicates whether Octopus should renormalize
 the orbital. The default (no sixth column given) is to renormalize. 

Option file -10010
 Read  initial  orbital  from  file.  Accepted  file  formats,  detected  by
 extension: obf, ncdf and csv (real only). 
Option formula 1
 Calculate initial orbital by given analytic expression. 
Option normalize_yes 1
 Normalize orbitals (default). 
Option normalize_no 0
 Do not normalize orbitals. 
END

Variable TransformStates
Type block
Default no
Section States
Description
 Before  starting the td calculation, the initial states (that are read from
 the  restart/gs  directory,  which should have been generated in a previous
 ground-state  calculation) can be "transformed" among themselves. The block
 TransformStates  gives  the transformation matrix to be used. The number of
 rows  and  columns  of  the  matrix  should  equal the number of the states
 present  in  the  time-dependent  calculation  (the  independent  spin  and
 _k_-point  subspaces  are  all  transformed equally); the number of columns
 should be equal to the number of states present in the 
 restart/gs  directory. This number may be different: for example, one could
 have  run  previously in unocc mode in order to obtain unoccupied Kohn-Sham
 states, and therefore restart/gs will contain more states. These states can
 be used in the transformation. 

 Note that the code will not check the orthonormality of the new states! 

 Each  line provides the coefficients of the new states, in terms of the old
 ones.  The coefficients are complex, but the imaginary part will be ignored
 for real wavefunctions. Note: This variable cannot be used when parallel in
 states. 
END

Variable MaxwellFunctions
Type block
Section Time-Dependent
Description
 This  block  specifies the shape of a "spatial-dependent function", such as
 the envelope needed when using the MaxwellFunctions block. Each line in the
 block  specifies  one  function.  The  first element of each line will be a
 string  that defines the name of the function. The second element specifies
 which type of function we are using; in the following we provide an example
 for each of the possible types: 

Option mxf_const_wave 10002

 %MaxwellFunctions 
    "function-name" | mxf_const_wave | kx | ky | kz | x0 | y0 | z0 
 % 

 The  function  is  constant  plane  wave  f(x,y,z) = a0 * \cos( kx*(x-x0) +
 ky*(y-y0) + kz*(z-z0) )  

Option mxf_const_phase 10004

 %MaxwellFunctions 
    "function-name" | mxf_const_phase | kx | ky | kz | x0 | y0 | z0 
 % 

 The  function  is a constant phase of  f(x,y,z) = a0 * (kx * x0 + ky * y0 +
 kz * z0)  

Option mxf_gaussian_wave 10005

 %MaxwellFunctions 
    "function-name"  |  mxf_gaussian_wave  |  kx  | ky | kz | x0 | y0 | z0 |
 width 
 % 

 The function is a Gaussian,  f(x,y,z) = a0 * \exp( -( kx*(x-x0) + ky*(y-y0)
 + kz*(z-z0) )^2 / (2 width^2) )  

Option mxf_cosinoidal_wave 10006

 %MaxwellFunctions 
    "function-name"  |  mxf_cosinoidal_wave  | kx | ky | kz | x0 | y0 | z0 |
 width 
 % 

  f(x,y,z)  =  \cos(  \frac{\pi}{2}  \frac{kx*(x-x0)+ky*(y-y0)+kz*(z-z0)-2
 width}{width} + \pi )  

 If  | kx*x + ky*y + kz*z - x0 | > \xi\_0 , then  f(x,y,z) = 0 . 

Option mxf_logistic_wave 10007

 %MaxwellFunctions 
    "function-name"  |  mxf_logistic_wave  |  kx  | ky | kz | x0 | y0 | z0 |
 growth | width 
 % 

 The  function  is  a  logistic  function,  f(x,y,z)  =  a0  *
 1/(1+\exp(growth*(kx*(x-x0)+ky*(y-y0)+kz*(kz*(z-z0))+width/2)))  *
 1/(1+\exp(-growth*(kx*(x-x0)+ky*(y-y0)+kz*(kz*(z-z0))-width/2)))  

Option mxf_trapezoidal_wave 10008

 %MaxwellFunctions 
    "function-name"  |  mxf_trapezoidal_wave | kx | ky | kz | x0 | y0 | z0 |
 growth | width 
 % 

 The  function  is  a  logistic  function,   f(x,y,z)  =  a0  *  (  (
 1-growth*(k*(r-r0)-width/2)*\Theta(k*(r-r0)-width/2))*\Theta(-(k*(r-r0)+width/2+1/growth))
    \qquad  \qquad  \qquad  +
 (-1+growth*(k*(r-r0)+width/2)*\Theta(k*(r-r0)+width/2))*\Theta(-(k*(r-r0)-width/2+1/growth))
 )  

Option mxf_from_expr 10011

 %MaxwellFunctions 
    "function-name" | mxf_from_expr | "expression" 
 % 

 The  temporal  shape  of  the  field  is  given  as  an  expression  (e.g.,
 cos(2.0*x-3*y+4*z).  The  letter  _x_,  _y_, _z_ means spatial coordinates,
 obviously.  The  expression  is  used  to  construct  the function _f_ that
 defines the field. 
END

Variable PNFFTCutoff
Type integer
Default 6
Section Mesh::FFTs
Description
 Cut-off parameter of the window function. 
END

Variable PNFFTOversampling
Type float
Default 2.0
Section Mesh::FFTs
Description
 PNFFT oversampling factor (sigma). This will rule the size of the FFT under
 the hood. 
END

Variable TDFunctions
Type block
Section Time-Dependent
Description
 This  block specifies the shape of a "time-dependent function", such as the
 envelope  needed  when  using  the TDExternalFields block. Each line in the
 block  specifies  one  function.  The  first element of each line will be a
 string  that defines the name of the function. The second element specifies
 which type of function we are using; in the following we provide an example
 for each of the possible types: 

Option tdf_cw 10002

 %TDFunctions 
    "function-name" | tdf_cw | amplitude 
 % 

 The function is just a constant of value amplitude:  f(t)  = amplitude 

Option tdf_gaussian 10003

 %TDFunctions 
    "function-name" | tdf_gaussian | amplitude | tau0 | t0 
 % 

 The  function  is a Gaussian,  f(t) = F_0 \exp( - (t-t_0)^2/(2\tau_0^2) ) ,
 where F_0 = amplitude. 

Option tdf_cosinoidal 10004

 %TDFunctions 
    "function-name" | tdf_cosinoidal | amplitude | tau0 | t0 
 % 

  f(t) = F_0 \cos( \frac{\pi}{2} \frac{t-2\tau_0-t_0}{\tau0} )  

 If  | t - t_0 | > \tau_0 , then  f(t) = 0 . 

Option tdf_trapezoidal 10005

 %TDFunctions 
    "function-name" | tdf_trapezoidal | amplitude | tau0 | t0 | tau1 
 % 

 This  function is a trapezoidal centered around t0. The shape is determined
 by  tau0  and  tau1. The function ramps linearly for tau1 time units, stays
 constant  for  tau0  time units, and then decays to zero linearly again for
 tau1 time units. 

Option tdf_from_file 10006

 %TDFunctions 
    "function-name" | tdf_from_file | "filename" 
 % 

 The  temporal shape of the function is contained in a file called filename.
 This  file  should  contain three columns: first column is time, second and
 third  column  are  the  real  part  and the imaginary part of the temporal
 function _f_(_t_). 

Option tdf_from_expr 10008

 %TDFunctions 
    "function-name" | tdf_from_expr | "expression" 
 % 

 The  temporal  shape  of  the  field  is  given  as  an  expression  (e.g.,
 cos(2.0*t). The letter _t_ means time, obviously. The expression is used to
 construct the function _f_ that defines the field. 
END

Variable FFTOptimize
Type logical
Default yes
Section Mesh::FFTs
Description
 Should  octopus  optimize  the  FFT dimensions? This means that the mesh to
 which FFTs are applied is not taken to be as small as possible: some points
 may  be  added  to  each  direction in order to get a "good number" for the
 performance of the FFT algorithm. The best FFT grid dimensions are given by
 2^a  3^b  5^c 7^d 11^e 13^f where a,b,c,d are arbitrary and e,f are 0 or 1.
 (<a href=http://www.fftw.org/doc/Complex-DFTs.html>ref</a>). In some cases,
 namely  when  using the split-operator, or Suzuki-Trotter propagators, this
 option  should  be turned off. For spatial FFTs in periodic directions, the
 grid is never optimized, but a warning will be written if the number is not
 good,  with a suggestion of a better one to use, so you can try a different
 spacing if you want to get a good number. 
END

Variable FFTPreparePlan
Type integer
Default fftw_measure
Section Mesh::FFTs
Description
 The  FFTs  are  performed  in  octopus  with  the  help  of  <a
 href=http://www.fftw.org>FFTW</a>  and  similar  packages. Before doing the
 actual  computations,  this package prepares a "plan", which means that the
 precise  numerical  strategy  to  be  followed  to  compute  the  FFT  is
 machine/compiler-dependent,  and  therefore the software attempts to figure
 out  which  is  this  precise  strategy  (see  the  FFTW  documentation for
 details).  This  plan preparation, which has to be done for each particular
 FFT  shape,  can  be  done  exhaustively  and  carefully  (slow), or merely
 estimated. Since this is a rather critical numerical step, by default it is
 done  carefully,  which implies a longer initial initialization, but faster
 subsequent  computations.  You  can  change this behaviour by changing this
 FFTPreparePlan  variable,  and  in this way you can force FFTW to do a fast
 guess or estimation of which is the best way to perform the FFT. 
Option fftw_measure 0
 This  is  the  default, and implies a longer initialization, but involves a
 more  careful  analysis  of  the  strategy  to  follow,  and therefore more
 efficient FFTs. 
Option fftw_estimate 64
 This  is  the  "fast  initialization"  scheme,  in which the plan is merely
 guessed from "reasonable" assumptions. 
Option fftw_patient 32
 It  is  like  fftw_measure,  but  considers a wider range of algorithms and
 often produces a "more optimal" plan (especially for large transforms), but
 at  the expense of several times longer planning time (especially for large
 transforms). 
Option fftw_exhaustive 8
 It  is  like fftw_patient, but considers an even wider range of algorithms,
 including  many  that we think are unlikely to be fast, to produce the most
 optimal plan but with a substantially increased planning time. 
END

Variable FFTLibrary
Type integer
Section Mesh::FFTs
Default fftw
Description
 (experimental) You can select the FFT library to use. 
Option fftw 1
 Uses FFTW3 library. 
Option pfft 2
 (experimental) Uses PFFT library, which has to be linked. 
Option accel 3
 (experimental)  Uses  a GPU accelerated library. This only works if Octopus
 was compiled with Cuda or OpenCL support. 
END

Variable RootSolver
Type integer
Default root_newton
Section Math::RootSolver
Description
 Specifies what kind of root solver will be used. 
Option root_newton 3
 Newton method. 
END

Variable RootSolverMaxIter
Type integer
Default 100
Section Math::RootSolver
Description
 In  case  of an iterative root solver, this variable determines the maximum
 number of iteration steps. 
END

Variable RootSolverRelTolerance
Type float
Default 1e-8
Section Math::RootSolver
Description
 Relative tolerance for the root-finding process. 
END

Variable RootSolverAbsTolerance
Type float
Default 1e-8
Section Math::RootSolver
Description
 Relative tolerance for the root-finding process. 
END

Variable SPARSKITSolver
Type integer
Default sk_bcg
Section Math::SPARSKIT
Description
 Specifies what kind of linear solver will be used. 
Option sk_cg 1
 Conjugate Gradient Method 
Option sk_cgnr 2
 Conjugate Gradient Method (Normal Residual equation) 
Option sk_bcg 3
 Bi-Conjugate Gradient Method 
Option sk_dbcg 4
 BCG with partial pivoting 
Option sk_bcgstab 5
 BCG stabilized 
Option sk_tfqmr 6
 Transpose-Free Quasi-Minimum Residual method 
Option sk_fom 7
 Full Orthogonalization Method 
Option sk_gmres 8
 Generalized Minimum Residual method 
Option sk_fgmres 9
 Flexible version of Generalized Minimum Residual method 
Option sk_dqgmres 10
 Direct versions of the Quasi-Generalized Minimum Residual method 
END

Variable SPARSKITKrylovSubspaceSize
Type integer
Default 15
Section Math::SPARSKIT
Description
 Some  of  the  SPARSKIT  solvers are Krylov subspace methods. This variable
 determines what size the solver will use for the subspace. 
END

Variable SPARSKITMaxIter
Type integer
Default 50000
Section Math::SPARSKIT
Description
 This  variable  controls the maximum number of iteration steps that will be
 performed by the (iterative) linear solver. 
END

Variable SPARSKITIterOut
Type integer
Default -1
Section Math::SPARSKIT
Description
 Determines  how  often  status info of the solver is printed. If <= 0, will
 never be printed. 
END

Variable SPARSKITRelTolerance
Type float
Default 1e-8
Section Math::SPARSKIT
Description
 Some  SPARSKIT solvers use a relative tolerance as a stopping criterion for
 the  iterative  solution  process. This variable can be used to specify the
 tolerance. 
END

Variable SPARSKITAbsTolerance
Type float
Default 1e-10
Section Math::SPARSKIT
Description
 Some SPARSKIT solvers use an absolute tolerance as a stopping criterion for
 the  iterative  solution  process. This variable can be used to specify the
 tolerance. 
END

Variable SPARSKITVerboseSolver
Type logical
Default no
Section Math::SPARSKIT
Description
 When set to yes, the SPARSKIT solver will write more detailed output. 
END

Variable NFFTGuruInterface
Type logical
Default false
Section Mesh::FFTs
Description
 Perform  NFFT  with guru interface. This permits the fine tuning of several
 critical parameters. 
END

Variable NFFTCutoff
Type integer
Default 6
Section Mesh::FFTs
Description
 Cut-off parameter of the window function. See NFFT manual for details. 
END

Variable NFFTOversampling
Type float
Default 2
Section Mesh::FFTs
Description
 NFFT  oversampling factor (sigma). This will rule the size of the FFT under
 the hood. 
END

Variable NFFTPrecompute
Type integer
Default NFFT_PRE_PSI
Section Mesh::FFTs
Description
 NFFT precomputation strategy. 
Option NFFT_PRE_LIN_PSI 4
 This method implements a linear interpolation from a lookup table. 
Option NFFT_PRE_PSI 16
 This  method  uses  a  medium  amount  of  memory to store d*(2*m+1)*M real
 numbers  and  requires  at  most  2(2m + 1)d extra multiplications for each
 node. This is the default option. 
Option NFFT_PRE_FULL_PSI 32
 Is  the fastest method but requires a large amount of memory as it requires
 to  store  (2*m+1)^d*M  real numbers. No extra operations are needed during
 matrix vector multiplication. 
END

Variable PropagationSpectrumType
Type integer
Default AbsorptionSpectrum
Section Utilities::oct-propagation_spectrum
Description
 Type of spectrum to calculate. 
Option AbsorptionSpectrum 1
 Photoabsorption spectrum. 
Option EnergyLossSpectrum 2
 Dynamic structure factor (also known as energy-loss function or spectrum). 
Option DipolePower 3
 Power spectrum of the dipole moment. 
Option RotatoryStrength 4
 Rotatory strength spectrum. 
END

Variable SpectrumMethod
Type integer
Default fourier
Section Utilities::oct-propagation_spectrum
Description
 Decides which method is used to obtain the spectrum. 
Option fourier 1
 The  standard  Fourier  transform.  Further  specified  by
 PropagationSpectrumTransform. 
Option compressed_sensing 2
 (Experimental) Uses the compressed sensing technique. 
END

Variable SpectrumSignalNoise
Type float
Default 0.0
Section Utilities::oct-propagation_spectrum
Description
 For compressed sensing, the signal to process, the time-dependent dipole in
 this  case,  is  assumed  to  have  some  noise  that  is  given  by  this
 dimensionless quantity. 
END

Variable PropagationSpectrumDampMode
Type integer
Section Utilities::oct-propagation_spectrum
Description
 Decides  which  damping/filtering  is  to  be applied in order to calculate
 spectra  by  calculating  a  Fourier  transform.  The default is polynomial
 damping,  except when SpectrumMethod = compressed_sensing. In that case the
 default is none. 
Option none 0
 No filtering at all. 
Option exponential 1
 Exponential filtering, corresponding to a Lorentzian-shaped spectrum. 
Option polynomial 2
 Third-order polynomial damping. 
Option gaussian 3
 Gaussian damping. 
END

Variable PropagationSpectrumTransform
Type integer
Default sine
Section Utilities::oct-propagation_spectrum
Description
 Decides which transform to perform, if SpectrumMethod = fourier. 
Option sine 2
 Sine  transform:  \int dt \sin(wt) f(t). Produces the imaginary part of the
 polarizability. 
Option cosine 3
 Cosine  transform:  \int  dt  \cos(wt)  f(t). Produces the real part of the
 polarizability. 
Option laplace 1
 Real exponential transform: \int dt e^{-wt} f(t). Produces the real part of
 the  polarizability  at imaginary frequencies, _e.g._ for Van der Waals C_6
 coefficients. This is the only allowed choice for complex scaling. 
END

Variable PropagationSpectrumStartTime
Type float
Default 0.0
Section Utilities::oct-propagation_spectrum
Description
 Processing  is  done for the given function in a time-window that starts at
 the value of this variable. 
END

Variable PropagationSpectrumEndTime
Type float
Default -1.0 au
Section Utilities::oct-propagation_spectrum
Description
 Processing is done for the given function in a time-window that ends at the
 value  of this variable. If set to a negative value, the maximum value from
 the corresponding multipole file will used. 
END

Variable PropagationSpectrumEnergyStep
Type float
Default 0.01 eV
Section Utilities::oct-propagation_spectrum
Description
 Sampling  rate  for  the  spectrum. If you supply a number equal or smaller
 than  zero,  then the sampling rate will be 2 \pi / T, where T is the total
 propagation time. 
END

Variable PropagationSpectrumMinEnergy
Type float
Default 0
Section Utilities::oct-propagation_spectrum
Description
 The Fourier transform is calculated for energies larger than this value. 
END

Variable PropagationSpectrumMaxEnergy
Type float
Default 20 eV
Section Utilities::oct-propagation_spectrum
Description
 The Fourier transform is calculated for energies smaller than this value. 
END

Variable PropagationSpectrumDampFactor
Type float
Default -1.0
Section Utilities::oct-propagation_spectrum
Description
 If  PropagationSpectrumDampMode  =  exponential,  gaussian,  the  damping
 parameter  of the exponential is fixed through this variable. Default value
 ensure  that the damping function adquires a 0.0001 value at the end of the
 propagation time. 
END

Variable PropagationSpectrumSigmaDiagonalization
Type logical
Default .false.
Section Utilities::oct-propagation_spectrum
Description
 If PropagationSpectrumSigmaDiagonalization = yes, the polarizability tensor
 is diagonalizied. This variable is only used if the cross_section_tensor is
 computed. 
END

Variable PropagationSpectrumSymmetrizeSigma
Type logical
Default .false.
Section Utilities::oct-propagation_spectrum
Description
 The  polarizablity  tensor  has  to be real and symmetric. Due to numerical
 accuracy,  that  is not extricly conserved when computing it from different
 time-propations.  If  PropagationSpectrumSymmetrizeSigma  =  yes,  the
 polarizability  tensor  is  symmetrized  before  its  diagonalizied.  This
 variable is only used if the cross_section_tensor is computed. 
END

Variable PESMaskMode
Type integer
Default mask_mode
Section Time-Dependent::PhotoElectronSpectrum
Description
 PES calculation mode. 
Option mask_mode 1
 Mask method. 
Option fullmask_mode 2
 Full  mask method. This includes a back action of the momentum-space states
 on  the  interaction  region.  This enables electrons to come back from the
 continuum. 
Option passive_mode 3
 Passive analysis of the wf. Simply analyze the plane-wave components of the
 wavefunctions  on  the  region _r_ > _R1_. This mode employs a step masking
 function by default. 
END

Variable PESMaskStartTime
Type float
Default -1.0
Section Time-Dependent::PhotoElectronSpectrum
Description
 The  time  photoelectrons  start to be recorded. In pump-probe simulations,
 this  allows  getting  rid of an unwanted ionization signal coming from the
 pump. NOTE: This will enforce the mask boundary conditions for all times. 
END

Variable PESMaskPlaneWaveProjection
Type integer
Default fft_map
Section Time-Dependent::PhotoElectronSpectrum
Description
 With  the  mask method, wavefunctions in the continuum are treated as plane
 waves. This variable sets how to calculate the plane-wave projection in the
 buffer  region.  We  perform  discrete Fourier transforms (DFT) in order to
 approximate  a  continuous  Fourier  transform.  The major drawback of this
 approach  is  the  built-in periodic boundary condition of DFT. Choosing an
 appropriate  plane-wave  projection  for  a given simulation in addition to
 PESMaskEnlargeFactor and 
 PESMask2PEnlargeFactorwill help to converge the results. 

 NOTE: depending on the value of PESMaskMode PESMaskPlaneWaveProjection, may
 affect not only performance but also the time evolution of the density. 
Option fft_out 2
 FFT filtered in order to keep only outgoing waves. 1D only. 
Option fft_map 3
 FFT transform. 
Option nfft_map 5
 Non-equispaced FFT map. 
Option pfft_map 6
 Use PFFT library. 
Option pnfft_map 7
 Use PNFFT library. 
END

Variable PESMaskEnlargeFactor
Type float
Default 1
Section Time-Dependent::PhotoElectronSpectrum
Description
 Mask  box  enlargement  level.  Enlarges  the  mask  bounding  box  by  a
 PESMaskEnlargeFactor.  This  helps  to  avoid  wavefunction wrapping at the
 boundaries. 
END

Variable PESMask2PEnlargeFactor
Type float
Default 1.0
Section Time-Dependent::PhotoElectronSpectrum
Description
 Mask  two  points  enlargement  factor. Enlarges the mask box by adding two
 points  at  the  edges  of  the box in each direction (x,y,z) at a distance
 L=Lb*PESMask2PEnlargeFactor  where _Lb_ is the box size. This allows to run
 simulations  with an additional void space at a price of adding few points.
 The  Fourier  space  associated  with the new box is restricted by the same
 factor. 

 Note: needs  PESMaskPlaneWaveProjection = nfft_map or pnfft_map . 
END

Variable PESMaskShape
Type integer
Default m_sin2
Section Time-Dependent::PhotoElectronSpectrum
Description
 The mask function shape. 
Option m_sin2 1
 sin2 mask. 
Option m_step 2
step function.
Option m_erf 3
Error function. Not Implemented.
END

Variable PESMaskSize
Type block
Section Time-Dependent::PhotoElectronSpectrum
Description
 Set  the  size  of  the  mask function. Here you can set the inner (R1) and
 outer (R2) radius by setting the block as follows: 

 %PESMaskSize 
    R1 | R2 | "user-defined" 
 % 

 The optional 3rd column is a user-defined expression for the mask function.
 For  example,  _r_  creates  a  spherical  mask  (which  is the default for
 BoxShape  =  sphere).  Note, values R2 larger than the box size may lead in
 this case to unexpected reflection behaviours. 
END

Variable PESMaskFilterCutOff
Type float
Default -1
Section Time-Dependent::PhotoElectronSpectrum
Description
 In  calculation  with  PESMaskMode  =  fullmask_mode  and  NFFT,  spurious
 frequencies may lead to numerical instability of the algorithm. This option
 gives  the  possibility to filter out the unwanted components by setting an
 energy cut-off. If PESMaskFilterCutOff = -1 no filter is applied. 
END

Variable PESMaskIncludePsiA
Type logical
Default false
Section Time-Dependent::PhotoElectronSpectrum
Description
 Add  the  contribution  of  \Psi_A in the mask region to the photo-electron
 spectrum. Literally adds the Fourier components of: 
 \Theta(r-R1)  \Psi_A(r) with \Theta being the Heaviside step function. With
 this  option PES will contain all the contributions starting from the inner
 radius  R1.  Use this option to improve convergence with respect to the box
 size and total simulation time. Note: Carefully choose R1 in order to avoid
 contributions from returning electrons. 
END

Variable PESMaskSpectEnergyMax
Type float
Default maxval(mask%Lk)<math>^2/2</math>
Section Time-Dependent::PhotoElectronSpectrum
Description
 The maximum energy for the PES spectrum. 
END

Variable PESMaskSpectEnergyStep
Type float
Section Time-Dependent::PhotoElectronSpectrum
Description
 The PES spectrum energy step. 
END

Variable PES_spm_points
Type block
Section Time-Dependent::PhotoElectronSpectrum
Description
 List  of  points  at  which  to calculate the photoelectron spectrum by the
 sample  point method. If no points are given, a spherical grid is generated
 automatically. The exact syntax is: 

 %PES_spm_points 
   x1 | y1 | z1 
 % 
  
END

Variable PES_spm_recipe
Type integer
Default phase
Section Time-Dependent::PhotoElectronSpectrum
Description
 The  type  for  calculating  the photoelectron spectrum in the sample point
 method. 
Option raw 1
 Calculate  the photoelectron spectrum according to A. Pohl, P.-G. Reinhard,
 and E. Suraud, _Phys. Rev. Lett._ *84*, 5090 (2000). 
Option phase 2
 Calculate  the  photoelectron  spectrum  by  including  the  Volkov  phase
 (approximately),  see  P.  M.  Dinh,  P. Romaniello, P.-G. Reinhard, and E.
 Suraud, _Phys. Rev. A._ *87*, 032514 (2013). 
END

Variable PES_spm_OmegaMax
Type float
Default 0.0
Section Time-Dependent::PhotoElectronSpectrum
Description
 If  PES_spm_OmegaMax > 0, the photoelectron spectrum is directly calculated
 during  time-propagation, evaluated by the PES_spm method. PES_spm_OmegaMax
 is  then  the  maximum  frequency  (approximate  kinetic  energy)  and
 PES_spm_DeltaOmega the spacing in frequency domain of the spectrum. 
END

Variable PES_spm_DeltaOmega
Type float
Section Time-Dependent::PhotoElectronSpectrum
Description
 The  spacing  in  frequency  domain  for  the  photoelectron  spectrum  (if
 PES_spm_OmegaMax > 0). The default is PES_spm_OmegaMax/500. 
END

Variable PES_spm_StepsThetaR
Type integer
Default 45
Section Time-Dependent::PhotoElectronSpectrum
Description
 Number of steps in \theta (0 \le \theta \le \pi) for the spherical grid (if
 no 
 PES_spm_points are given). 
END

Variable PES_spm_StepsPhiR
Type integer
Default 90
Section Time-Dependent::PhotoElectronSpectrum
Description
 Number  of  steps in \phi (0 \le \phi \le 2 \pi) for the spherical grid (if
 no 
 PES_spm_points are given). 
END

Variable PES_spm_Radius
Type float
Section Time-Dependent::PhotoElectronSpectrum
Description
 The  radius  of the sphere for the spherical grid (if no PES_spm_points are
 given). 
END

Variable PES_Flux_Shape
Type integer
Section Time-Dependent::PhotoElectronSpectrum
Description
 The shape of the surface. 
Option cub 1
 Uses  a  parallelepiped  as  surface.  All  surface points are grid points.
 Choose  the  location  of the surface with variable PES_Flux_Lsize (default
 for 1D and 2D). 
Option sph 2
 Constructs  a  sphere with radius PES_Flux_Radius. Points on the sphere are
 interpolated by trilinear interpolation (default for 3D). 
Option pln 3
 This  option  is  for periodic systems. Constructs a plane perpendicular to
 the non-periodic dimension at PES_Flux_Lsize. 
END

Variable PES_Flux_AnisotropyCorrection
Type logical
Section Time-Dependent::PhotoElectronSpectrum
Description
 Apply anisotropy correction. 

END

Variable PES_Flux_Offset
Type block
Section Time-Dependent::PhotoElectronSpectrum
Description
 Shifts the surface for PES_Flux_Shape = cub. The syntax is: 

 %PES_Flux_Offset 
   xshift | yshift | zshift 
 % 
  
END

Variable PES_Flux_Lmax
Type integer
Default 80
Section Time-Dependent::PhotoElectronSpectrum
Description
 Maximum  order of the spherical harmonic to be integrated on an equidistant
 spherical grid (to be changed to Gauss-Legendre quadrature). 
END

Variable PES_Flux_Lsize
Type block
Section Time-Dependent::PhotoElectronSpectrum
Description
 For  PES_Flux_Shape  =  cub  sets  the dimensions along each direction. The
 syntax is: 

 %PES_Flux_Lsize 
   xsize | ysize | zsize 
 % 
  

 where  xsize,  ysize, and zsize are with respect to the origin. The surface
 can be shifted with PES_Flux_Offset. If PES_Flux_Shape = pln, specifies the
 position  of  two  planes  perpendicular  to  the  non-periodic  dimension
 symmetrically placed at PES_Flux_Lsize distance from the origin. 
END

Variable PES_Flux_Face_Dens
Type block
Section Time-Dependent::PhotoElectronSpectrum
Description
 Define the number of points density per unit of area (in au) on the face of
 the 'cub' surface. 
END

Variable PES_Flux_Radius
Type float
Section Time-Dependent::PhotoElectronSpectrum
Description
 The radius of the sphere, if PES_Flux_Shape == sph. 
END

Variable PES_Flux_StepsThetaR
Type integer
Default: 2 <tt>PES_Flux_Lmax</tt> + 1
Section Time-Dependent::PhotoElectronSpectrum
Description
 Number of steps in \theta (0 \le \theta \le \pi) for the spherical surface.
 
END

Variable PES_Flux_StepsPhiR
Type integer
Default: 2 <tt>PES_Flux_Lmax</tt> + 1
Section Time-Dependent::PhotoElectronSpectrum
Description
 Number of steps in \phi (0 \le \phi \le 2 \pi) for the spherical surface. 
END

Variable PES_Flux_Parallelization
Type flag
Section Time-Dependent::PhotoElectronSpectrum
Description
 The parallelization strategy to be used to calculate the PES spectrum using
 the  resources available in the domain parallelization pool. This option is
 not available without domain parallelization. Parallelization over k-points
 and states is always enabled when available. 
Option pf_none bit(1)
 No parallelization. 
Option pf_time bit(2)
 Parallelize time integration. This requires to store some quantities over a
 number of time steps equal to the number of cores available. 
Option pf_momentum bit(3)
 Parallelize  over  the  final momentum grid. This strategy has a much lower
 memory  footprint  than the one above (time) but seems to provide a smaller
 speedup. 
Option pf_surface bit(4)
 Parallelize over surface points. 


 Option pf_time and pf_surface can be combined: pf_time + pf_surface. 

END

Variable PES_Flux_UseSymmetries
Type logical
Section Time-Dependent::PhotoElectronSpectrum
Description
 Use  surface and momentum grid symmetries to speed up calculation and lower
 memory  footprint. By default available only when the surface shape matches
 the  grid  symmetry  i.e.:  PES_Flux_Shape  =  m_cub  or  m_pln  and
 PES_Flux_Momenutum_Grid  =  m_cartesian  or  PES_Flux_Shape  =  m_sph  and
 PES_Flux_Momenutum_Grid = m_polar 
END

Variable PES_Flux_RuntimeOutput
Type logical
Section Time-Dependent::PhotoElectronSpectrum
Description
 Write output in ascii format at runtime. 

END

Variable PES_Flux_Momenutum_Grid
Type integer
Section Time-Dependent::PhotoElectronSpectrum
Description
 Decides how the grid in momentum space is generated. 
Option polar 1
 The  grid is in polar coordinates with the zenith axis is along z. The grid
 parameters  are  defined  by  PES_Flux_Kmax,  PES_Flux_DeltaK,
 PES_Flux_StepsThetaK,  PES_Flux_StepsPhiK.  This  is the default choice for
 PES_Flux_Shape = sph or cub. 
Option cartesian 2
 The  grid  is  in  cartesian  coordinates  with  parameters  defined  by
 PES_Flux_ARPES_grid,  PES_Flux_EnergyGrid.  This  is the default choice for
 PES_Flux_Shape = sph or cub. 
END

Variable PES_Flux_EnergyGrid
Type block
Section Time-Dependent::PhotoElectronSpectrum
Description
 The block PES_Flux_EnergyGrid specifies the energy grid in momentum space. 
 %PES_Flux_EnergyGrid 
    Emin | Emax | DeltaE 
 % 
END

Variable PES_Flux_Kmax
Type float
Default 1.0
Section Time-Dependent::PhotoElectronSpectrum
Description
 The  maximum  value  of  the photoelectron momentum. For cartesian momentum
 grids  one  can  specify  a value different for cartesian direction using a
 block input. 
END

Variable PES_Flux_Kmin
Type float
Default 0.0
Section Time-Dependent::PhotoElectronSpectrum
Description
 The  minimum  value  of  the photoelectron momentum. For cartesian momentum
 grids  one  can  specify  a value different for cartesian direction using a
 block input. 
END

Variable PES_Flux_DeltaK
Type float
Default 0.02
Section Time-Dependent::PhotoElectronSpectrum
Description
 Spacing of the the photoelectron momentum grid. 
END

Variable PES_Flux_ThetaK
Type block
Section Time-Dependent::PhotoElectronSpectrum
Description
 Define  the  grid  points  on  theta  (0  \le  \theta \le \pi) when using a
 spherical  grid  in  momentum.  The  block  defines the maximum and minimum
 values of theta and the number of of points for the discretization. 

 %PES_Flux_ThetaK 
    theta_min | theta_max | npoints 
 % 
  

 By default theta_min=0, theta_max = pi, npoints = 45. 
END

Variable PES_Flux_StepsThetaK
Type integer
Default 45
Section Time-Dependent::PhotoElectronSpectrum
Description
 Number  of steps in \theta (0 \le \theta \le \pi) for the spherical grid in
 k. 
END

Variable PES_Flux_PhiK
Type block
Section Time-Dependent::PhotoElectronSpectrum
Description
 Define  the  grid  points  on  theta  (0  \le \theta \le 2\pi) when using a
 spherical  grid  in  momentum.  The  block  defines the maximum and minimum
 values of theta and the number of of points for the discretization. 

 %PES_Flux_PhiK 
    theta_min | theta_max | npoints 
 % 
  

 By default theta_min=0, theta_max = pi, npoints = 90. 
END

Variable PES_Flux_StepsPhiK
Type integer
Default 90
Section Time-Dependent::PhotoElectronSpectrum
Description
 Number of steps in \phi (0 \le \phi \le 2 \pi) for the spherical grid in k.
 
END

Variable PES_Flux_ARPES_grid
Type logical
Section Time-Dependent::PhotoElectronSpectrum
Description
 Use  a  curvilinear momentum space grid that compensates the transformation
 used  to  obtain  ARPES.  With  this  choice  ARPES  data  is laid out on a
 Cartesian  regular  grid.  By  default true when PES_Flux_Shape = pln and a
 KPointsPath is specified. 
END

Variable PES_Flux_GridTransformMatrix
Type block
Section Time-Dependent::PhotoElectronSpectrum
Description
 Define an optional transformation matrix for the momentum grid. 

 %PES_Flux_GridTransformMatrix 
    M_11 | M_12 | M_13 
    M_21 | M_22 | M_23 
    M_31 | M_32 | M_33 
 % 
  
END

Variable TDOutput
Type block
Default multipoles + energy (+ others depending on other options)
Section Time-Dependent::TD Output
Description
 Defines what should be output during the time-dependent simulation. Many of
 the  options can increase the computational cost of the simulation, so only
 use  the  ones that you need. In most cases the default value is enough, as
 it  is  adapted to the details of the TD run. If the ions are allowed to be
 moved, additionally the geometry and the temperature are output. If a laser
 is included it will output by default. 

 Note:  the  output  files  generated  by  this  option  are  updated  every
 RestartWriteInterval steps. 

 Example: 
 %TDOutput 
   multipoles 
   energy 
 % 

Option multipoles 1
 Outputs  the  (electric)  multipole  moments  of  the  density  to the file
 td.general/multipoles.  This  is  required  to,  _e.g._,  calculate optical
 absorption  spectra  of  finite  systems. The maximum value of l can be set
 with the variable TDMultipoleLmax. 
Option angular 2
 Outputs  the  orbital angular momentum of the system to td.general/angular,
 which can be used to calculate circular dichroism. 
Option spin 3
 (Experimental) Outputs the expectation value of the spin, which can be used
 to calculate magnetic circular dichroism. 
Option populations 4
 (Experimental)  Outputs  the  projection  of  the  time-dependent Kohn-Sham
 Slater  determinant onto the ground state (or approximations to the excited
 states) to the file 
 td.general/populations.  Note  that  the  calculation  of  populations  is
 expensive  in  memory and computer time, so it should only be used if it is
 really needed. See TDExcitedStatesToProject. 
Option geometry 5
 If  set  (and  if  the atoms are allowed to move), outputs the coordinates,
 velocities, and forces of the atoms to the the file td.general/coordinates.
 On by default if MoveIons = yes. 
Option dipole_acceleration 6
 When  set,  outputs  the  acceleration of the electronic dipole, calculated
 from  the Ehrenfest theorem, in the file td.general/acceleration. This file
 can  then  be  processed  by  the utility oct-harmonic-spectrum in order to
 obtain the harmonic spectrum. 
Option laser 7
 If set, outputs the laser field to the file td.general/laser. On by default
 if TDExternalFields is set. 
Option energy 8
 If  set, octopus outputs the different components of the energy to the file
 td.general/energy.  Will  be  zero  except  for  every  TDEnergyUpdateIter
 iterations. 
Option td_occup 9
 (Experimental)  If  set,  outputs  the  projections  of  the time-dependent
 Kohn-Sham  wavefunctions  onto  the static (zero-time) wavefunctions to the
 file 
 td.general/projections.XXX.  Only use this option if you really need it, as
 it  might  be  computationally  expensive. See TDProjStateStart. The output
 interval  of  this  quantity  is  controled  by  the  variable
 TDOutputComputeInterval  In  case  of  states  parallelization,  all  the
 ground-state states are stored by each task. 
Option local_mag_moments 10
 If  set,  outputs the local magnetic moments, integrated in sphere centered
 around  each  atom.  The  radius  of  the  sphere  can  be  set  with
 LocalMagneticMomentsSphereRadius. 
Option gauge_field 11
 If set, outputs the vector gauge field corresponding to a spatially uniform
 (but  time-dependent) external electrical potential. This is only useful in
 a time-dependent periodic run. On by default if GaugeVectorField is set. 
Option temperature 12
 If  set,  the  ionic  temperature at each step is printed. On by default if
 MoveIons = yes. 
Option ftchd 13
 Write  Fourier transform of the electron density to the file ftchd.X, where
 X  depends  on  the kick (e.g. with sin-shaped perturbation X=sin). This is
 needed  for  calculating the dynamic structure factor. In the case that the
 kick  mode  is  qbessel,  the  written  quantity  is integral over density,
 multiplied  by  spherical Bessel function times real spherical harmonic. On
 by default if TDMomentumTransfer is set. 
Option dipole_velocity 14
 When  set,  outputs  the  dipole  velocity,  calculated  from the Ehrenfest
 theorem,  in  the file td.general/velocity. This file can then be processed
 by  the  utility  oct-harmonic-spectrum  in  order  to  obtain the harmonic
 spectrum. 
Option eigenvalues 15
 Write the KS eigenvalues. 
Option ionization_channels 16
 Write  the  multiple-ionization  channels using the KS orbital densities as
 proposed  in  C. Ullrich, Journal of Molecular Structure: THEOCHEM 501, 315
 (2000). 
Option total_current 17
 Output the total current (average of the current density over the cell). 
Option partial_charges 18
 Bader  and  Hirshfeld  partial  charges.  The  output  file  is  called
 'td.general/partial_charges'. 
Option td_kpoint_occup 19
 Project  propagated  Kohn-Sham  states  to  the  states at t=0 given in the
 directory restart_proj (see %RestartOptions). This is an alternative to the
 option td_occup, with a formating more suitable for k-points and works only
 in k- and/or state parallelization 
Option td_floquet 20
 Compute non-interacting Floquet bandstructure according to further options:
 TDFloquetFrequency,  TDFloquetSample, TDFloquetDimension. This is done only
 once per td-run at t=0. works only in k- and/or state parallelization 
Option n_excited_el 21
 Output  the  number  of  excited electrons, based on the projections of the
 time  evolved wave-functions on the ground-state wave-functions. The output
 interval  of  this  quantity  is  controled  by  the  variable
 TDOutputComputeInterval 
Option coordinates_sep 22
 Writes geometries in a separate file. 
Option velocities_sep 23
 Writes velocities in a separate file. 
Option forces_sep 24
 Writes forces in a separate file. 
Option total_heat_current 25
 Output the total heat current (average of the heat current density over the
 cell). 
Option total_magnetization 26
 Writes the total magnetization, where the total magnetization is calculated
 at  the momentum defined by TDMomentumTransfer. This is used to extract the
 magnon frequency in case of a magnon kick. 
Option photons_q 27
 Writes photons_q in a separate file. 
END

Variable TDOutputResolveStates
Type logical
Default No
Section Time-Dependent::TD Output
Description
 Defines whether the output should be resolved by states. 

 So far only TDOutput = multipoles is supported. 

END

Variable TDMultipoleLmax
Type integer
Default 1
Section Time-Dependent::TD Output
Description
 Maximum  electric  multipole  of  the  density  output  to  the  file
 td.general/multipoles  during  a  time-dependent  simulation.  Must  be
 non-negative. 
END

Variable TDProjStateStart
Type integer
Default 1
Section Time-Dependent::TD Output
Description
 To  be  used  with  TDOutput  =  td_occup.  Not  available  if  TDOutput  =
 populations.  Only  output  projections  to  states above TDProjStateStart.
 Usually  one  is  only  interested  in particle-hole projections around the
 HOMO,  so  there is no need to calculate (and store) the projections of all
 TD  states onto all static states. This sets a lower limit. The upper limit
 is  set  by  the  number  of  states  in  the propagation and the number of
 unoccupied states available. 
END

Variable TDExcitedStatesToProject
Type block
Section Time-Dependent::TD Output
Description
 *[WARNING: This is a *very* experimental feature]* To be used with TDOutput
 =  populations.  The  population  of  the  excited  states  (as  defined by
 <Phi_I|Phi(t)> where |Phi(t)> is the many-body time-dependent state at time
 _t_,  and  |Phi_I> is the excited state of interest) can be approximated --
 it is not clear how well -- by substituting for those real many-body states
 the  time-dependent  Kohn-Sham  determinant  and  some  modification of the
 Kohn-Sham  ground-state  determinant  (_e.g._,  a  simple  HOMO-LUMO
 substitution,  or  the  Casida ansatz for excited states in linear-response
 theory.  If  you set TDOutput to contain populations, you may ask for these
 approximated  populations  for  a  number  of excited states, which will be
 described  in  the  files  specified in this block: each line should be the
 name of a file that contains one excited state. 

 This file structure is the one written by the casida run mode, in the files
 in  the  directory  *_excitations. The file describes the "promotions" from
 occupied  to  unoccupied  levels that change the initial Slater determinant
 structure  specified  in  ground_state.  These  promotions  are  a  set  of
 electron-hole  pairs.  Each line in the file, after an optional header, has
 four columns: 

 _i a \sigma weight_ 

 where  _i_  should  be an occupied state, _a_ an unoccupied one, and \sigma
 the  spin of the corresponding orbital. This pair is then associated with a
 creation-annihilation pair a^{\dagger}_{a,\sigma} a_{i,\sigma}, so that the
 excited state will be a linear combination in the form: 

 \left|{\rm  ExcitedState}\right>  =  \sum  weight(i,a,\sigma)
 a^{\dagger}_{a,\sigma} a_{i,\sigma} \left|{\rm GroundState}\right> 

 where  _weight_ is the number in the fourth column. These weights should be
 normalized  to  one; otherwise the routine will normalize them, and write a
 warning. 
END

Variable TDOutputComputeInterval
Type integer
Default 50
Section Time-Dependent::TD Output
Description
 The  TD  output  requested  are  computed  when  the  iteration number is a
 multiple of the TDOutputComputeInterval variable. Must be >= 0. If it is 0,
 then  no  output is written. Implemented only for projections and number of
 excited electrons for the moment. 
END

Variable TDOutputDFTU
Type flag
Default none
Section Time-Dependent::TD Output
Description
 Defines what should be output during the time-dependent simulation, related
 to LDA+U. 

 Note:  the  output  files  generated  by  this  option  are  updated  every
 RestartWriteInterval steps. 
Option effective_u 1
 Writes the effective U for each orbital set as a function of time. 
END

Variable TDFloquetFrequency
Type float
Default 0
Section Time-Dependent::TD Output
Description
 Frequency for the Floquet analysis, this should be the carrier frequency or
 integer multiples of it. Other options will work, but likely be nonsense. 

END

Variable TDFloquetSample
Type integer
Default 20
Section Time-Dependent::TD Output
Description
 Number of points on which one Floquet cycle is sampled in the time-integral
 of the Floquet analysis. 

END

Variable TDFloquetDimension
Type integer
Default -1
Section Time-Dependent::TD Output
Description
 Order  of  Floquet Hamiltonian. If negative number is given, downfolding is
 performed. 
END

Variable MaxwellTDOutput
Type flag
Default maxwell_energy
Section Time-Dependent::TD Output
Description
 Defines what should be output during the time-dependent Maxwell simulation.
 Many  of the options can increase the computational cost of the simulation,
 so  only  use  the  ones  that you need. In most cases the default value is
 enough,  as  it  is  adapted  to  the  details  of the TD run. WARNING: the
 calculation  of  the  longitudinal or transverse E and B fields can be very
 expensive,  so  please  consider using the MaxwellOutput block to calculate
 and output these quantities at certain timesteps. 
Option maxwell_total_e_field 1
 Output  of  the  total (longitudinal plus transverse) electric field at the
 points specified in the MaxwellFieldsCoordinate block 
Option maxwell_total_b_field 8
 Output  of  the  total (longitudinal plus transverse) magnetic field at the
 points specified in the MaxwellFieldsCoordinate block 
Option maxwell_longitudinal_e_field 64
 Output  of  the  longitudinal electric field at the points specified in the
 MaxwellFieldsCoordinate block (can slow down the run) 
Option maxwell_longitudinal_b_field 512
 Output  of  the  longitudinal magnetic field at the points specified in the
 MaxwellFieldsCoordinate block (can slow down the run) 
Option maxwell_transverse_e_field 4096
 Output  of  the  transverse  electric  field at the points specified in the
 MaxwellFieldsCoordinate block (can slow down the run) 
Option maxwell_transverse_b_field 32768
 Output  of  the  transverse  magnetic  field at the points specified in the
 MaxwellFieldsCoordinate block (can slow down the run) 
Option maxwell_energy 262144
 Output  of  the  electromagnetic  field  energy  into  the  folder
 td.general/maxwell.  WARNING: the transverse and longitudinal energies will
 be  correct  only  if  you  request  the longitudinal and transverse E or B
 fields as output. Otherwise they will be set to zero. 
Option e_field_surface_x 524288
 Output of the E field sliced along the plane x=0 for each field component 
Option e_field_surface_y 1048576
 Output of the E field sliced along the plane y=0 for each field component 
Option e_field_surface_z 2097152
 Output of the E field sliced along the plane z=0 for each field component 
Option b_field_surface_x 4194304
 Output of the B field sliced along the plane x=0 for each field component 
Option b_field_surface_y 8388608
 Output of the B field sliced along the plane y=0 for each field component 
Option b_field_surface_z 16777216
 Output of the B field sliced along the plane z=0 for each field component 
END

Variable TDPropagator
Type integer
Default etrs
Section Time-Dependent::Propagation
Description
 This  variable  determines  which algorithm will be used to approximate the
 evolution operator U(t+\delta t, t). That is, given 
 \psi(\tau)  and  H(\tau) for \tau \le t, calculate t+\delta t. Note that in
 general  the  Hamiltonian  is  not  known  at  times in the interior of the
 interval  [t,t+\delta  t]. This is due to the self-consistent nature of the
 time-dependent  Kohn-Sham  problem: the Hamiltonian at a given time \tau is
 built from the "solution" wavefunctions at that time. 

 Some  methods, however, do require the knowledge of the Hamiltonian at some
 point  of the interval [t,t+\delta t]. This problem is solved by making use
 of extrapolation: given a number l of time steps previous to time 
 t,  this  information  is  used to build the Hamiltonian at arbitrary times
 within [t,t+\delta t]. To be fully precise, one should then proceed 
 _self-consistently_:  the  obtained Hamiltonian at time t+\delta t may then
 be  used to interpolate the Hamiltonian, and repeat the evolution algorithm
 with this new information. Whenever iterating the procedure does not change
 the  solution  wavefunctions, the cycle is stopped. In practice, in Octopus
 we  perform  a second-order extrapolation without a self-consistency check,
 except  for  the first two iterations, where obviously the extrapolation is
 not reliable. 

 The  proliferation  of methods is certainly excessive. The reason for it is
 that  the propagation algorithm is currently a topic of active development.
 We  hope  that in the future the optimal schemes are clearly identified. In
 the mean time, if you do not feel like testing, use the default choices and
 make sure the time step is small enough. 
Option etrs 2
 The idea is to make use of time-reversal symmetry from the beginning: 

  \exp  \left(-i\delta  t  H_{n}  /  2  \right)\psi_n = \exp \left(i\delta t
 H_{n+1} / 2 \right)\psi_{n+1}, 
  

 and then invert to obtain: 

  \psi_{n+1} = \exp \left(-i\delta t H_{n+1} / 2 \right) \exp \left(-i\delta
 t H_{n} / 2 \right)\psi_{n}. 
  

 But  we  need  to know H_{n+1}, which can only be known exactly through the
 solution 
 \psi_{n+1}.  What  we  do  is  to  estimate  it  by  performing  a  single
 exponential: 
 \psi^{*}_{n+1}=\exp \left( -i\delta t H_{n} \right) \psi_n, and then 
 H_{n+1}  =  H[\psi^{*}_{n+1}].  Thus  no extrapolation is performed in this
 case. 
Option aetrs 3
 Approximated  Enforced  Time-Reversal  Symmetry  (AETRS). A modification of
 previous  method  to  make  it  faster. It is based on extrapolation of the
 time-dependent  potentials.  It is faster by about 40%. The only difference
 is the procedure to estimate H_{n+1}: in this case it is extrapolated via a
 second-order  polynomial by making use of the Hamiltonian at time t-2\delta
 t, t-\delta t and t. 
Option caetrs 12
 (experimental)  Corrected  Approximated  Enforced  Time-Reversal  Symmetry
 (AETRS), this is the previous propagator but including a correction step to
 the exponential. 
Option exp_mid 4
 Exponential  Midpoint  Rule (EM). This is maybe the simplest method, but it
 is  very  well grounded theoretically: it is unitary (if the exponential is
 performed  correctly)  and  preserves  time-reversal  symmetry  (if  the
 self-consistency problem is dealt with correctly). It is defined as: 
  U_{\rm  EM}(t+\delta  t,  t)  =  \exp  \left(  -i\delta  t  H_{t+\delta
 t/2}\right)\,. 
  
Option crank_nicholson 5
Option crank_nicolson 5
 Classical Crank-Nicolson propagator. 
  (1  +  i\delta t H_{n+1/2} / 2) \psi_{n+1} = (1 - i\delta t H_{n+1/2} / 2)
 \psi_{n} 
  
Option crank_nicholson_sparskit 6
Option crank_nicolson_sparskit 6
 Classical Crank-Nicolson propagator. Requires the SPARSKIT library. 
  (1  +  i\delta t H_{n+1/2} / 2) \psi_{n+1} = (1 - i\delta t H_{n+1/2} / 2)
 \psi_{n} 
  
Option magnus 7
 Magnus  Expansion  (M4).  This  is the most sophisticated approach. It is a
 fourth-order  scheme  (a  feature  which  it shares with the ST scheme; the
 other schemes are in principle second-order). It is tailored for making use
 of  very  large time steps, or equivalently, dealing with problem with very
 high-frequency time-dependence. It is still in a experimental state; we are
 not yet sure of when it is advantageous. 
Option qoct_tddft_propagator 10
 WARNING: EXPERIMENTAL 
Option runge_kutta4 13
 WARNING: EXPERIMENTAL. Implicit Gauss-Legendre 4th order Runge-Kutta. 
Option runge_kutta2 14
 WARNING:  EXPERIMENTAL.  Implicit 2nd order Runge-Kutta (trapezoidal rule).
 Similar, but not identical, to Crank-Nicolson method. 
Option expl_runge_kutta4 15
 WARNING: EXPERIMENTAL. Explicit RK4 method. 
Option cfmagnus4 16
 WARNING EXPERIMENTAL 
END

Variable TDStepsWithSelfConsistency
Type integer
Default 0
Section Time-Dependent::Propagation
Description
 Since  the  KS  propagator  is  non-linear, each propagation step should be
 performed  self-consistently.  In  practice,  for most purposes this is not
 necessary,  except perhaps in the first iterations. This variable holds the
 number  of  propagation  steps  for  which  the  propagation  is  done
 self-consistently. 

 The  special  value  all_steps forces self-consistency to be imposed on all
 propagation  steps.  A  value  of 0 means that self-consistency will not be
 imposed. The default is 0. 
Option all_steps -1
 Self-consistency is imposed for all propagation steps. 
END

Variable TDSCFThreshold
Type float
Default 1.0e-6
Section Time-Dependent::Propagation
Description
 Since  the  KS  propagator  is  non-linear, each propagation step should be
 performed  self-consistently.  In  practice,  for most purposes this is not
 necessary,  except perhaps in the first iterations. This variable holds the
 number  of  propagation  steps  for  which  the  propagation  is  done
 self-consistently. 

 The  self  consistency  has to be measured against some accuracy threshold.
 This variable controls the value of that threshold. 
END

Variable TDTimeStep
Type float
Section Time-Dependent::Propagation
Description
 The  time-step  for  the time propagation. For most propagators you want to
 use  the  largest  value  that  is  possible without the evolution becoming
 unstable. 

 The  default value is the maximum value that we have found empirically that
 is stable for the spacing h: 
 dt  =  0.0426  -  0.207  h  +  0.808  h^2  (from parabolic fit to Fig. 4 of
 http://dx.doi.org/10.1021/ct800518j,  probably  valid for 3D systems only).
 However, you might need to adjust this value. 
END

Variable TDPropagationTime
Type float
Section Time-Dependent::Propagation
Description
 The  length  of  the  time propagation. You cannot set this variable at the
 same time as TDMaxSteps. By default this variable will not be used. 

 The  units for this variable are \hbar/Hartree (or \hbar/eV if you selected
 ev_angstrom  as  input  units). The approximate conversions to femtoseconds
 are 1 fs = 41.34 \hbar/Hartree = 1.52 \hbar/eV. 
END

Variable TDMaxSteps
Type integer
Default 1500
Section Time-Dependent::Propagation
Description
 Number  of  time-propagation  steps  that will be performed. You cannot use
 this variable together with TDPropagationTime. 
END

Variable TDDynamics
Type integer
Default ehrenfest
Section Time-Dependent::Propagation
Description
 Type  of dynamics to follow during a time propagation. For BO, you must set
 MoveIons = yes. 
Option ehrenfest 1
 Ehrenfest dynamics. 
Option bo 2
 Born-Oppenheimer (Experimental). 
END

Variable RecalculateGSDuringEvolution
Type logical
Default no
Section Time-Dependent::Propagation
Description
 In order to calculate some information about the system along the evolution
 (e.g.  projection  onto  the ground-state KS determinant, projection of the
 TDKS  spin-orbitals  onto  the  ground-state  KS  spin-orbitals),  the
 ground-state KS orbitals are needed. If the ionic potential changes -- that
 is,  the ions move -- one may want to recalculate the ground state. You may
 do this by setting this variable. 

 The recalculation is not done every time step, but only every 
 RestartWriteInterval time steps. 
END

Variable TDScissor
Type float
Default 0.0
Section Time-Dependent
Description
 (experimental)  If  set,  a  scissor  operator  will  be  applied  in  the
 Hamiltonian,  shifting  the excitation energies by the amount specified. By
 default, it is not applied. 
END

Variable TDEnergyUpdateIter
Type integer
Section Time-Dependent::Propagation
Description
 This  variable controls after how many iterations Octopus updates the total
 energy  during  a  time-propagation run. For iterations where the energy is
 not  updated,  the  last  calculated  value  is  reported.  If you set this
 variable to 1, the energy will be calculated in each step. 
END

Variable TDFreezeOrbitals
Type integer
Default 0
Section Time-Dependent
Description
 (Experimental)  You have the possibility of "freezing" a number of orbitals
 during  a  time-propagation. The Hartree and exchange-correlation potential
 due  to these orbitals (which will be the lowest-energy ones) will be added
 during the propagation, but the orbitals will not be propagated. 
Option sae -1
 Single-active-electron  approximation.  This  option  is  only  valid  for
 time-dependent calculations (CalculationMode = td). Also, the nuclei should
 not move. The idea is that all orbitals except the last one are frozen. The
 orbitals  are  to  be  read  from  a previous ground-state calculation. The
 active  orbital  is  then  treated  as independent (whether it contains one
 electron  or  two)  --  although  it  will  feel  the  Hartree  and
 exchange-correlation  potentials  from  the  ground-state  electronic
 configuration. 

 It  is  almost equivalent to setting TDFreezeOrbitals = N-1, where N is the
 number of orbitals, but not completely. 
END

Variable TDFreezeHXC
Type logical
Default no
Section Time-Dependent
Description
 The  electrons are evolved as independent particles feeling the Hartree and
 exchange-correlation  potentials  from  the  ground-state  electronic
 configuration. 
END

Variable TDFreezeDFTUOccupations
Type logical
Default no
Section Time-Dependent
Description
 The  occupation matrices than enters in the LDA+U potential are not evolved
 during the time evolution. 
END

Variable TDFreezeU
Type logical
Default no
Section Time-Dependent
Description
 The effective U of LDA+U is not evolved during the time evolution. 
END

Variable PhotoElectronSpectrum
Type integer
Default none
Section Time-Dependent::PhotoElectronSpectrum
Description
 This  variable  controls  the  method  used  for  the  calculation  of  the
 photoelectron  spectrum. You can specify more than one value by giving them
 as a sum, for example: 
 PhotoElectronSpectrum = pes_spm + pes_mask 
Option none 0
 The photoelectron spectrum is not calculated. This is the default. 
Option pes_spm 2
 Store  the  wavefunctions  at  specific  points  in  order to calculate the
 photoelectron  spectrum  at  a point far in the box as proposed in A. Pohl,
 P.-G. Reinhard, and E. Suraud, _Phys. Rev. Lett._ *84*, 5090 (2000). 
Option pes_mask 4
 Calculate  the  photo-electron  spectrum  using  the  mask  method.  U.  De
 Giovannini,  D. Varsano, M. A. L. Marques, H. Appel, E. K. U. Gross, and A.
 Rubio, 
 _Phys. Rev. A_ *85*, 062515 (2012). 
Option pes_flux 8
 Calculate  the photo-electron spectrum using the t-surff technique, _i.e._,
 spectra  are computed from the electron flux through a surface close to the
 absorbing  boundaries  of  the  box. (Experimental.) L. Tao and A. Scrinzi,
 _New Journal of Physics_ *14*, 013021 (2012). 
END

Variable LinearMediumProperties
Type block
Section Maxwell
Description
 Defines electromagnetic parameters for a linear medium box. 

 Example: 

 %LinearMediumProperties 
    epsilon_factor | mu_factor | sigma_e | sigma_m 
 % 

 Permittivity  factor,  permeability  factor,  electric  conductivity  and
 magnetic conductivity of the medium box. 
END

Variable LinearMediumEdgeProfile
Type integer
Section Maxwell
Description
 Defines the type of numerical approximation used for the derivatives at the
 edges  of the medium box. Default is edged. When the box shape is read from
 file, only the edged profile is supported. 

Option edged 1
 Medium box edges are considered steep for derivatives. 
Option smooth 2
 Medium box edged and softened for derivatives. 
END

Variable LinearMediumBoxShape
Type integer
Section Maxwell
Description
 This  variable  defines  the shape of the linear medium box. The default is
 medium_parallelepiped. 
Option medium_parallelepiped 1
 The  medium  box  will  be a parallelepiped whose center and dimensions are
 taken from the variable LinearMediumBoxSize. 
Option medium_box_file 2
 The  simulation  box  will  be  read  from  an external file in OFF format,
 defined by the variable LinearMediumBoxFile. 
END

Variable LinearMediumBoxSize
Type block
Section Maxwell
Description
 Defines center and size of a parallelepiped linear medium box. 

 Example: 

 %LinearMediumBoxSize 
    center_x | center_y | center_z | x_length | y_length | z_length 
 % 
END

Variable LinearMediumBoxFile
Type string
Section Maxwell
Description
 File in OFF format with the shape of the linear medium. 
END

Variable CheckPointsMediumFromFile
Type logical
Default no
Section Maxwell
Description
 Whether  to  re-calculate  the  points  map  by  artificially shrinking the
 coordinate  system  by  a  factor of 0.99 to check if the points inside the
 medium  surface  are  properly  detected.  This  works  for only one medium
 surface which is centered in the origin of the coordinate system. 
END

Variable MaxwellHamiltonianOperator
Type integer
Default faraday_ampere
Section Hamiltonian
Description
 With this variable the the Maxwell Hamiltonian operator can be selected 
Option faraday_ampere_old 0
 old version 
Option faraday_ampere 1
 The  propagation operation in vacuum with Spin 1 matrices without Gauss law
 condition. 
Option faraday_ampere_medium 2
 The  propagation operation in medium with Spin 1 matrices without Gauss law
 condition 
Option faraday_ampere_gauss 3
 The  propagation  operation  is  done  by 4x4 matrices also with Gauss laws
 constraint. 
Option faraday_ampere_gauss_medium 4
 The  propagation  operation  is  done  by 4x4 matrices also with Gauss laws
 constraint in medium 
END

Variable ExternalCurrent
Type logical
Default no
Section Hamiltonian
Description
 If an external current density will be used. 
END

Variable MaxwellMediumCalculation
Type integer
Default RS
Section Hamiltonian
Description
 For  linear  media the calculation of the Maxwell Operator acting on the RS
 state  can be done directly using the Riemann-Silberstein representation or
 by calculating the curl of the electric and magnetic fields. 
Option RS 1
 Medium calculation directly via Hamiltonian 
Option EM 2
 Medium calculation via curl of electric field and magnetic field 
END

Variable MaxwellAbsorbingBoundaries
Type block
Section Time-Dependent::Propagation
Description
 Type  of  absorbing  boundaries  used  for  Maxwell  propagation  in  each
 direction. 

 Example: 

 %MaxwellAbsorbingBoundaries 
    cpml | cpml | cpml 
 % 

Option not_absorbing 0
 No absorbing boundaries. 
Option mask 1
 A  mask equal to the wavefunctions mask is applied to the Maxwell states at
 the boundaries 
Option cpml 2
 Perfectly matched layer absorbing boundary 
Option mask_zero 7
 Absorbing boundary region is set to zero 
END

Variable MediumWidth
Type float
Default 0.0 a.u.
Section Time-Dependent::Absorbing Boundaries
Description
 Width of the boundary region with medium 
END

Variable MediumEpsilonFactor
Type float
Default 1.0.
Section Time-Dependent::Absorbing Boundaries
Description
 Linear medium electric susceptibility. 
END

Variable MediumMuFactor
Type float
Default 1.0
Section Time-Dependent::Absorbing Boundaries
Description
 Linear medium magnetic susceptibility. 
END

Variable MediumElectricSigma
Type float
Default 0.
Section Time-Dependent::Absorbing Boundaries
Description
 Electric conductivity of the linear medium. 
END

Variable MediumMagneticSigma
Type float
Default 0.
Section Time-Dependent::Absorbing Boundaries
Description
 Magnetic conductivity of the linear medium. 
END

Variable MaxwellABWidth
Type float
Section Time-Dependent::Absorbing Boundaries
Description
 Width  of  the  region  used to apply the absorbing boundaries. The default
 value is twice the derivative order. 
END

Variable MaxwellABPMLPower
Type float
Default 3.5
Section Time-Dependent::Absorbing Boundaries
Description
 Exponential  of the polynomial profile for the non-physical conductivity of
 the PML. Should be between 2 and 4 
END

Variable MaxwellABPMLReflectionError
Type float
Default 1.0e-16
Section Time-Dependent::Absorbing Boundaries
Description
 Tolerated reflection error for the PML 
END

Variable PlaneWavesOnOneSide
Type logical
Default No
Section Maxwell
Description
 If PlaneWaves should be fed to the box only from one side. 
END

Variable PlaneWavesSide
Type string
Section Maxwell
Description
 Side  of  the  box  in  which  plane waves are evaluated on the boundaries:
 negative  would mean on boundaries which are towards negative values in the
 selected directions (e.g. -x). 
Option negative -1
 Negative side. 
Option positive 1
 Positive side. 
END

Variable MaxwellIncidentWaves
Type block
Section MaxwellStates
Description
 The  initial  electromagnetic  fields  can  be  set  by  the  user with the
 MaxwellIncidentWaves  block  variable.  The  electromagnetic fields have to
 fulfill the Maxwells equations in vacuum. 

 Example: 

 %MaxwellIncidentWaves 
    plane_wave_parser | "k1x" | "k1y" | "k1z" | "E1x" | "E1z" | "E1x" 
    plane_wave_parser | "k2x" | "k2y" | "k2z" | "E2x" | "E2y" | "E2z" 
    plane_wave_gauss  |  "k3x"  |  "k3y"  |  "k3z" | "E3x" | "E3y" | "E3z" |
 "width" | "shift" 
    plane_wave_mx_function | "E4x" | "E4y" | "E4z" | mx_envelope_name 
 % 

 Description about MaxwellIncidentWaves follows 

Option plane_wave_parser 0
 Parser input modus 
Option plane_wave_mx_function 1
 The incident wave envelope is defined by an mx_function 
END

Variable UserDefinedMaxwellExternalCurrent
Type block
Section MaxwellStates
Description

 Example: 

 %UserDefinedMaxwellExternalCurrent 
    current_parser  |  "expression_x_dir1"  |  "expression_y_dir1"  |
 "expression_z_dir1" 
    current_parser  |  "expression_x_dir2"  |  "expression_y_dir2"  |
 "expression_z_dir2" 
    current_td_function  |  "amplitude_j0_x"  |  "amplitude_j0_y"  |
 "amplitude_j0_z" | omega | envelope_td_function_name | phase 
 % 

 Description about UserDefinedMaxwellExternalCurrent follows 

Option current_parser 0
 description follows 
Option current_td_function 1
 description follows 
END

Variable MaxwellBoundaryConditions
Type block
Section Time-Dependent::Propagation
Description
 Defines boundary conditions for the electromagnetic field propagation. 

 Example: 

 %MaxwellBoundaryConditions 
    zero | mirror_pec | consant 
 % 


Option zero 0
 Boundaries are set to zero. 
Option constant 1
 Boundaries are set to a constant. 
Option mirror_pec 2
 Perfect electric conductor. 
Option mirror_pmc 3
 Perfect magnetic conductor. 
Option plane_waves 4
 Boundaries feed in plane waves. 
Option periodic 5
 Periodic boundary conditions (not yet implemented). 
Option medium 6
 Boundaries as linear medium (not yet implemented). 
END

Variable MaxwellTDETRSApprox
Type integer
Default no
Section Time-Dependent::Propagation
Description
 Whether to perform aproximations to the ETRS propagator. 
Option no 0
 No approximations. 
Option const_steps 1
 Use constant current density. 
END

Variable MaxwellTDOperatorMethod
Type integer
Default op_fd
Section Time-Dependent::Propagation
Description
 The  Maxwell  Operator  e.g.  the  curl  operation  can  be obtained by two
 different methods, the finid-difference or the fast fourier transform. 
Option op_fd 1
 Maxwell operator calculated by finite differnce method 
Option op_fft 2
 Maxwell operator calculated by fast fourier transform 
END

Variable MaxwellTDSCFThreshold
Type float
Default 1.0e-6
Section Time-Dependent::Propagation
Description
 Since the Maxwell-KS propagator is non-linear, each propagation step should
 be  performed self-consistently. In practice, for most purposes this is not
 necessary,  except perhaps in the first iterations. This variable holds the
 number  of  propagation  steps  for  which  the  propagation  is  done
 self-consistently. 

 This variable controls the accuracy threshold for the self consistency. 
END

Variable MaxwellPlaneWavesInBox
Type logical
Default no
Section States
Description
 Analytic  evaluation  of  the  incoming waves inside the box, not doing any
 numerical propagation of Maxwells equations. 
END

Variable UserDefinedConstantSpatialMaxwellField
Type block
Section MaxwellStates
Description
 Define parameters of spatially constant field. 

 Example: 

 %UserDefinedConstantSpatialMaxwellFields 
    plane_wave_parser | E_x | E_y | E_z | B_x | B_y | B_z | "tdf_function" 
 % 

 This  block  defines  three  components  of  E field, three components of B
 field, and reference to the TD function. 

END

Variable PropagateSpatialMaxwellField
Type logical
Default yes
Section MaxwellStates
Description
 Allow for numerical propagation of Maxwells equations of spatially constant
 field.  If  set  to no, do only analytic evaluation of the field inside the
 box. 
END

Variable MediumDispersionType
Type integer
Default drude_medium
Section Maxwell
Description
 Dispersion  model  used  for the medium (only Drude model available for the
 moment). 
Option drude_medium 0
 Drude type of dispersion. 
END

Variable MediumPoleEnergy
Type float
Default 0
Section Maxwell
Description
 Energy of the pole. 
END

Variable MediumPoleDamping
Type float
Default 0
Section Maxwell
Description
 Damping factor (inverse relaxation time) of the medium. 
END

Variable MediumPoleStrength
Type float
Default 1.0
Section Maxwell
Description
 Strength of the pole (unitless). 
END

Variable MediumCurrentCoordinates
Type block
Section Maxwell
Description
 This allows to output phasor current vectors at particular points in space.
 

 %MediumCurrentCoordinates 
    -1.0 | 2.0 | 4.0 
    0.0 | 1.0 | -2.0 
 % 

END

Variable vdWNPoints
Type integer
Default 6
Section Linear Response::Polarizabilities
Description
 How  many points to use in the Gauss-Legendre integration to obtain the van
 der Waals coefficients. 
END

Variable EMFreqs
Type block
Section Linear Response::Polarizabilities
Description
 This  block  defines  for  which  frequencies  the polarizabilities will be
 calculated.  If  it  is  not  present,  the static (\omega = 0) response is
 calculated. 

 Each  row  of the block indicates a sequence of frequency values, the first
 column  is an integer that indicates the number of steps, the second number
 is  the initial frequency, and the third number the final frequency. If the
 first  number  is one, then only the initial value is considered. The block
 can have any number of rows. Consider the next example: 

 %EMFreqs 
 31 | 0.0 | 1.0 
  1 | 0.32 
 % 

END

Variable EMFreqsSort
Type logical
Default true
Section Linear Response::Polarizabilities
Description
 If true, the frequencies specified by the EMFreqs block are sorted, so that
 they  are  calculated  in  increasing order. Can be set to false to use the
 order  as  stated,  in  case  this  makes  better  use of available restart
 information. 
END

Variable EMEta
Type float
Default 0.0
Section Linear Response::Polarizabilities
Description
 The  imaginary  part  of the frequency, effectively a Lorentzian broadening
 for peaks in the spectrum. It can help convergence of the SCF cycle for the
 Sternheimer  equation when on a resonance, and it can be used as a positive
 infinitesimal to get the imaginary parts of response functions at poles. In
 units of energy. Cannot be negative. 
END

Variable EMPerturbationType
Type integer
Default electric
Section Linear Response::Polarizabilities
Description
 Which perturbation to consider for electromagnetic linear response. 
Option electric 1
 Electric  perturbation  used  to  calculate  electric  polarizabilities and
 hyperpolarizabilities. 
Option magnetic 2
 Magnetic perturbation used to calculate magnetic susceptibilities. 
Option none 0
 Zero perturbation, for use in testing. 
END

Variable EMCalcRotatoryResponse
Type logical
Default false
Section Linear Response::Polarizabilities
Description
 Calculate circular-dichroism spectrum from electric perturbation, and write
 to file rotatory_strength. 
END

Variable EMHyperpol
Type block
Section Linear Response::Polarizabilities
Description
 This  block  describes  the multiples of the frequency used for the dynamic
 hyperpolarizability.  The  results  are  written  to  the  file beta in the
 directory  for  the first multiple. There must be three factors, summing to
 zero:  \omega_1 + \omega_2 + \omega_3 = 0. For example, for second-harmonic
 generation, you could use 
 1 | 1 | -2. 
END

Variable EMCalcMagnetooptics
Type logical
Default false
Section Linear Response::Polarizabilities
Description
 Calculate magneto-optical response. 
END

Variable EMMagnetoopticsNoHVar
Type logical
Default true
Section Linear Response::Polarizabilities
Description
 Exclude  corrections  to  the  exchange-correlation  and Hartree terms from
 consideration of perturbations induced by a magnetic field 
END

Variable EMKPointOutput
Type logical
Default false
Section Linear Response::Polarizabilities
Description
 Give  in  the  output contributions of different k-points to the dielectric
 constant. Can be also used for magneto-optical effects. 
END

Variable EMForceNoKdotP
Type logical
Default false
Section Linear Response::Polarizabilities
Description
 If  the  system is periodic, by default wavefunctions from a previous kdotp
 run  will  be  read,  to be used in the formulas for the polarizability and
 hyperpolarizability  in  the  quantum  theory  of polarization. For testing
 purposes, you can set this variable to true to disregard the kdotp run, and
 use  the  formulas for the finite system. This variable has no effect for a
 finite system. 
END

Variable EMCalcBornCharges
Type logical
Default false
Section Linear Response::Polarizabilities
Description
 Calculate linear-response Born effective charges from electric perturbation
 (experimental). 
END

Variable EMOccupiedResponse
Type logical
Default false
Section Linear Response::Polarizabilities
Description
 Solve  for  full  response  without projector into unoccupied subspace. Not
 possible  if  there  are  partial occupations. When EMHyperpol is set for a
 periodic  system,  this variable is ignored and the full response is always
 calculated. 
END

Variable EMWavefunctionsFromScratch
Type logical
Default false
Section Linear Response::Polarizabilities
Description
 Do  not  use  saved  linear-response  wavefunctions  from a previous run as
 starting  guess.  Instead initialize to zero as in FromScratch, but restart
 densities  will  still be used. Restart wavefunctions from a very different
 frequency can hinder convergence. 
END

Variable Preorthogonalization
Type logical
Section Linear Response::Sternheimer
Description
 Whether  initial  linear-response wavefunctions should be orthogonalized or
 not against the occupied states, at the start of each SCF cycle. Default is
 true only if SmearingFunction = semiconducting, or if the Occupations block
 specifies  all  full  or  empty  states,  and we are not solving for linear
 response in the occupied subspace too. 
END

Variable HamiltonianVariation
Type integer
Default hartree+fxc
Section Linear Response::Sternheimer
Description
 The  terms  to  be  considered  in  the  variation  of the Hamiltonian. The
 external  potential (V_ext) is always considered. The default is to include
 also  the  exchange-correlation  and  Hartree terms, which fully takes into
 account local fields. Just hartree gives you the random-phase approximation
 (RPA).  If  you  want  to  choose  the exchange-correlation kernel, use the
 variable 
 XCKernel.  For  kdotp  and  magnetic  em_resp  modes,  or  if TheoryLevel =
 independent_particles,  the  value  V_ext_only is used and this variable is
 ignored. 
Option V_ext_only 0
 Neither Hartree nor XC potentials included. 
Option hartree 1
 The variation of the Hartree potential only. 
Option fxc 2
 The  exchange-correlation kernel (the variation of the exchange-correlation
 potential) only. 
END

Variable PhotonEta
Type float
Default 0.0000367
Section Linear Response::Sternheimer
Description
 This variable provides the value for the broadening of the photonic spectra
 when  the  coupling  of  electrons  to  photons  is  enabled  in  the
 frequency-dependent Sternheimer equation 
END

Variable KdotPOccupiedSolutionMethod
Type integer
Default sternheimer_eqn
Section Linear Response::KdotP
Description
 Method  of  calculating  the  contribution  of  the  projection  of  the
 linear-response wavefunctions in the occupied subspace. 
Option sternheimer_eqn 0
 The  Sternheimer equation is solved including the occupied subspace, to get
 the full linear-response wavefunctions. 
Option sum_over_states 1
 The  Sternheimer  equation is solved only in the unoccupied subspace, and a
 sum-over-states  perturbation-theory  expression  is  used  to evaluate the
 contributions in the occupied subspace. 
END

Variable DegeneracyThreshold
Type float
Default 1e-5
Section States
Description
 States with energy E_i and E_j will be considered degenerate if  \left| E_i
 - E_j \right| < DegeneracyThreshold. 
END

Variable KdotPEta
Type float
Default 0.0
Section Linear Response::KdotP
Description
 Imaginary  frequency  added  to  Sternheimer  equation  which  may  improve
 convergence. Not recommended. 
END

Variable KdotPCalculateEffectiveMasses
Type logical
Default true
Section Linear Response::KdotP
Description
 If  true,  uses  kdotp  perturbations  of  ground-state  wavefunctions  to
 calculate effective masses. It is not correct for degenerate states. 
END

Variable KdotPCalcSecondOrder
Type logical
Default false
Section Linear Response::KdotP
Description
 If  true,  calculates  second-order  response  of  wavefunctions as well as
 first-order response. Note that the second derivative of the Hamiltonian is
 NOT  included  in  this calculation. This is needed for a subsequent run in
 CalculationMode = em_resp with EMHyperpol. 
END

Variable CalcNormalModeWfs
Type logical
Default false
Section Linear Response::Vibrational Modes
Description
 If  set  to  true,  the response wavefunctions for each normal mode will be
 calculated  and  written  in  directory restart/vib_modes/phn_nm_wfs_XXXXX.
 This  part  is  time-consuming  and  not  parallel, but not needed for most
 purposes. 
END

Variable CalcInfrared
Type logical
Default true
Section Linear Response::Vibrational Modes
Description
 If  set to true, infrared intensities (and born charges) will be calculated
 and written in vib_modes/infrared. 
END

Variable SymmetrizeDynamicalMatrix
Type logical
Default true
Section Linear Response::Vibrational Modes
Description
 If  set to true, all entries of the dynamical matrix will be calculated and
 then  the  matrix will be symmetrized to enforce D_{ij} = D_{ji}. If set to
 false, only the upper half of the matrix will be calculated. 
END

Variable DOSEnergyMin
Type float
Section Output
Description
 Lower  bound  for  the  energy  mesh  of the DOS. The default is the lowest
 eigenvalue, minus a quarter of the total range of eigenvalues. 
END

Variable DOSEnergyMax
Type float
Section Output
Description
 Upper  bound  for  the  energy  mesh of the DOS. The default is the highest
 eigenvalue, plus a quarter of the total range of eigenvalues. 
END

Variable DOSEnergyPoints
Type integer
Default 500
Section Output
Description
 Determines  how  many  energy  points Octopus should use for the DOS energy
 grid. 
END

Variable DOSGamma
Type float
Default 0.008 Ha
Section Output
Description
 Determines the width of the Lorentzian which is used for the DOS sum. 
END

Variable DOSComputePDOS
Type logical
Default false
Section Output
Description
 Determines if projected dos are computed or not. At the moment, the PDOS is
 computed  from  the  bare  pseudo-atomic  orbitals, directly taken from the
 pseudopotentials.  The  orbitals  are  not  orthonormalized,  in  order  to
 preserve  their atomic orbitals character. As a consequence, the sum of the
 different PDOS does not integrate to the total DOS. 

 The  radii  of  the  orbitals  are  controled  by  the threshold defined by
 AOThreshold<\tt>,  and  the  fact  that  they  are  normalized  or  not  by
 AONormalize<\tt>. 
END

Variable MagneticGaugeCorrection
Type integer
Default gipaw
Section Linear Response
Description
 For  magnetic  linear  response:  how  to  handle  gauge-invariance  in the
 description of the coupling of electrons to the magnetic field. 
Option none 0
 No correction. 
Option gipaw 1
 GIPAW  correction:  C  Pickard and F Mauri, _Phys. Rev. Lett._ *91*, 196401
 (2003). 
Option icl 2
 ICL  correction: S Ismail-Beigi, EK Chang, and SG Louie, _Phys. Rev. Lett._
 *87*, 087402 (2001). 
END

Variable SICCorrection
Type integer
Default sic_none
Section Hamiltonian::XC
Description
 This  variable  controls  which form of self-interaction correction to use.
 Note  that  this  correction  will  be  applied to the functional chosen by
 XCFunctional. 
Option sic_none 1
 No self-interaction correction. 
Option sic_pz 2
 Perdew-Zunger SIC, handled by the OEP technique. 
Option sic_amaldi 3
 Amaldi correction term. 
Option sic_adsic 4
 Average-density SIC. C. Legrand _et al._, _J. Phys. B_ *35*, 1115 (2002). 
END

Variable LinearSolver
Type integer
Default qmr_symmetric
Section Linear Response::Solver
Description
 Method  for  solving  linear  equations, which occur for Sternheimer linear
 response  and  OEP.  The  solvers  vary  in  speed, reliability (ability to
 converge), and domain of applicability. QMR solvers are most reliable. 
Option bicgstab 4
 Biconjugate  gradients  stabilized.  Slower  than  cg,  but  more reliable.
 General matrices. 
Option cg 5
 Conjugate  gradients.  Fast but unreliable. Hermitian matrices only (no eta
 in Sternheimer). 
Option multigrid 7
 Multigrid  solver,  currently  only  Gauss-Jacobi (experimental). Slow, but
 fairly reliable. General matrices. 
Option qmr_symmetric 81
 Quasi-minimal  residual  solver,  for  (complex)  symmetric matrices. [Real
 symmetric  is  equivalent  to Hermitian.] Slightly slower than bicgstab but
 more  reliable.  For  Sternheimer, must be real wavefunctions, but can have
 eta. 
Option qmr_symmetrized 82
 Quasi-minimal  residual  solver, using the symmetrized form A^\dagger A x =
 A^\dagger y instead of 
 A x = y. Reliable but very slow. General matrices. 
Option qmr_dotp 83
 Quasi-minimal  residual solver, for Hermitian matrices, using the symmetric
 algorithm  with conjugated dot product (experimental). Slightly slower than
 bicgstab but more reliable. Can always be used in Sternheimer. 
Option qmr_general 84
 Quasi-minimal residual solver, for general matrices, using the most general
 form of the algorithm. Slow and unreliable. 
Option sos 9
 Sum  over  states: the Sternheimer equation is solved by using the explicit
 solution  in  terms  of the ground-state wavefunctions. You need unoccupied
 states  to  use  this  method.  Unlike  the other methods, may not give the
 correct answer. 
Option idrs 11
 This  is  the  "Induced Dimension Reduction", IDR(s) (for s=4). IDR(s) is a
 robust  and  efficient  short recurrence Krylov subspace method for solving
 large  nonsymmetric  systems of linear equations. It is described in [Peter
 Sonneveld  and Martin B. van Gijzen, SIAM J. Sci. Comput. 31, 1035 (2008)].
 We  have  adapted  the  code  released  by  M.  B.  van  Gizjen
 [http://ta.twi.tudelft.nl/nw/users/gijzen/IDR.html]. 
END

Variable LinearSolverMaxIter
Type integer
Default 1000
Section Linear Response::Solver
Description
 Maximum number of iterations the linear solver does, even if convergence is
 not achieved. 
END

Variable Eigensolver
Type integer
Section SCF::Eigensolver
Description
 Which  eigensolver  to  use  to  obtain  the  lowest  eigenvalues  and
 eigenfunctions  of  the  Kohn-Sham  Hamiltonian.  The  default is conjugate
 gradients  (cg), except that when parallelization in states is enabled, the
 default is rmmdiis. 
Option cg 5
 Conjugate-gradients algorithm. 
Option plan 11
 Preconditioned  Lanczos  scheme.  Ref:  Y.  Saad,  A.  Stathopoulos,  J.
 Chelikowsky,  K.  Wu and S. Ogut, "Solution of Large Eigenvalue Problems in
 Electronic Structure Calculations", _BIT_ *36*, 1 (1996). 
Option cg_new 6
 An  alternative  conjugate-gradients eigensolver, faster for larger systems
 but less mature. Ref: Jiang et al., _Phys. Rev. B_ *68*, 165337 (2003) 
Option evolution 9
 (Experimental) Propagation in imaginary time. 
Option rmmdiis 10
 Residual  minimization  scheme,  direct inversion in the iterative subspace
 eigensolver,  based  on  the  implementation of Kresse and Furthm&uuml;ller
 [_Phys.  Rev.  B_  *54*, 11169 (1996)]. This eigensolver requires almost no
 orthogonalization  so  it can be considerably faster than the other options
 for large systems. To improve its performance a large number of ExtraStates
 are  required  (around 10-20% of the number of occupied states). Note: with
 unocc,  you  will  need  to stop the calculation by hand, since the highest
 states  will  probably  never  converge.  Usage with more than one block of
 states per node is experimental, unfortunately. 
END

Variable CGOrthogonalizeAll
Type logical
Default no
Section SCF::Eigensolver
Description
 Used  by the cg solver only. During the cg iterations, the current band can
 be  orthogonalized against all other bands or only against the lower bands.
 Orthogonalizing against all other bands can improve convergence properties,
 whereas  orthogonalizing  against  lower  bands  needs  less  operations.
 Moreover, orthogonalizing against all bands can make converging the highest
 band or unoccupied bands more difficult. 
END

Variable CGDirection
Type integer
Section SCF::Eigensolver
Description
 Used  by  the  cg  solver  only. The conjugate direction is updated using a
 certain  coefficient  to  the  previous  direction. This coeffiction can be
 computed  in different ways. The default is to use Fletcher-Reeves (FR), an
 alternative is Polak-Ribiere (PR). 
Option fletcher 1
 The  coefficient  for  Fletcher-Reeves  consists of the current norm of the
 steepest descent vector divided by that of the previous iteration. 
Option polak 2
 For  the  Polak-Ribiere  scheme, a product of the current with the previous
 steepest descent vector is subtracted in the nominator. 
END

Variable CGAdditionalTerms
Type logical
Section SCF::Eigensolver
Default no
Description
 Used  by  the  cg  solver  only.  Add  additional  terms  during  the  line
 minimization,  see  PTA92,  eq. 5.31ff. These terms can improve convergence
 for  some systems, but they are quite costly. If you experience convergence
 problems,  you  might  try  out  this  option.  This  feature  is  still
 experimental. 
END

Variable CGEnergyChangeThreshold
Type float
Section SCF::Eigensolver
Default 0.1
Description
 Used  by  the  cg solver only. For each band, the CG iterations are stopped
 when the change in energy is smaller than the change in the first iteration
 multiplied by this factor. This limits the number of CG iterations for each
 band, while still showing good convergence for the SCF cycle. The criterion
 is  discussed  in Sec. V.B.6 of Payne et al. (1992), Rev. Mod. Phys. 64, 4.
 The  default  value  is 0.1, which is usually a good choice for LDA and GGA
 potentials. If you are solving the OEP equation, you might want to set this
 value  to  1e-3  or  smaller.  In general, smaller values might help if you
 experience  convergence  problems.  For  very small convergence tolerances,
 choose 0 to disable this criterion. 
END

Variable EigensolverImaginaryTime
Type float
Default 0.1
Section SCF::Eigensolver
Description
 The imaginary-time step that is used in the imaginary-time evolution method
 (Eigensolver = evolution) to obtain the lowest eigenvalues/eigenvectors. It
 must  satisfy  EigensolverImaginaryTime > 0. Increasing this value can make
 the propagation faster, but could lead to unstable propagations. 
END

Variable EigensolverMinimizationIter
Type integer
Default 0
Section SCF::Eigensolver
Description
 During  the  first  iterations,  the  RMMDIIS  eigensolver  requires  some
 steepest-descent  minimizations  to  improve  convergence.  This  variable
 determines the number of those minimizations. 
END

Variable EigensolverTolerance
Type float
Section SCF::Eigensolver
Description
 This is the tolerance for the eigenvectors. The default is 1e-7. 
END

Variable EigensolverMaxIter
Type integer
Section SCF::Eigensolver
Description
 Determines  the  maximum  number  of  iterations  that the eigensolver will
 perform  if  the  desired  tolerance  is  not  achieved.  The default is 25
 iterations  for  all  eigensolvers except for rmdiis, which performs only 5
 iterations.  Increasing  this  value  for  rmdiis increases the convergence
 speed, at the cost of an increased memory footprint. 

 In  the  case  of  imaginary  time  propatation, this variable controls the
 number  of  iterations  for which the Hxc potential is frozen. Default is 1
 for the imaginary time evolution. 
END

Variable SubspaceDiagonalization
Type integer
Default standard
Section SCF::Eigensolver
Description
 Selects  the  method  to  perform  subspace diagonalization. The default is
 standard,  unless  states  parallelization  is  used,  when  the default is
 scalapack.  Note  that  this  variable  is  not  parsed  in the case of the
 evolution eigensolver. 
Option none 0
 No  subspace  diagonalization.  WARNING: this will generally give incorrect
 results. 
Option standard 1
 The standard routine. Can be used with domain parallelization but not state
 parallelization. 
Option scalapack 3
 State-parallelized  version  using  ScaLAPACK.  (Requires  that Octopus was
 compiled with ScaLAPACK support.) 
END

Variable MagneticGaugeCorrection
Type integer
Default gipaw
Section Linear Response
Description
 For  magnetic  linear  response:  how  to  handle  gauge-invariance  in the
 description of the coupling of electrons to the magnetic field. 
Option none 0
 No correction. 
Option gipaw 1
 GIPAW  correction:  C  Pickard and F Mauri, _Phys. Rev. Lett._ *91*, 196401
 (2003). 
Option icl 2
 ICL  correction: S Ismail-Beigi, EK Chang, and SG Louie, _Phys. Rev. Lett._
 *87*, 087402 (2001). 
END

Variable KdotPUseNonLocalPseudopotential
Type logical
Default true
Section Linear Response::KdotP
Description
 For  testing  purposes,  set  to false to ignore the term -i \left[\vec{r},
 V\right]  in  the  \vec{k}  \cdot  \vec{p}  perturbation,  which  is due to
 non-local pseudopotentials. 
END

Variable KdotPVelMethod
Type integer
Default grad_vel
Section Linear Response::KdotP
Description
 Method of velocity calculation. 
Option grad_vel 0
 -i \left(\nabla + \left[r, V_{\rm nl} \right] \right) 
Option hcom_vel 1
 As  a  commutator  of the position operator and Hamiltonian, -i \left[ r, H
 \right]. 
END

Variable KPointsUseSymmetries
Type logical
Default no
Section Mesh::KPoints
Description
 This  variable defines whether symmetries are taken into account or not for
 the  choice  of _k_-points. If it is set to no, the _k_-point sampling will
 range over the full Brillouin zone. 

 When  a  perturbation  is applied to the system, the full symmetries of the
 system  cannot be used. In this case you must not use symmetries or use the
 SymmetryBreakDir to tell Octopus the direction of the perturbation (for the
 moment  this  has  to be done by hand by the user, in the future it will be
 automatic). 

END

Variable KPointsUseTimeReversal
Type logical
Section Mesh::KPoints
Description
 If  symmetries  are  used to reduce the number of _k_-points, this variable
 defines  whether time-reversal symmetry is taken into account or not. If it
 is  set  to  no,  the  _k_-point  sampling will not be reduced according to
 time-reversal symmetry. 

 The  default  is  yes, unless symmetries are broken in one direction by the
 SymmetryBreakDir block. 

 Warning:  For  time  propagation runs with an external field, time-reversal
 symmetry should not be used. 

END

Variable KPointsGrid
Type block
Default <math>\Gamma</math>-point only
Section Mesh::KPoints
Description
 When this block is given (and the KPoints block is not present), 
 _k_-points  are  distributed  in  a  uniform  grid, according to a modified
 version of the Monkhorst-Pack scheme. For the original MP scheme, see James
 D. Pack and Hendrik J. Monkhorst, 
 _Phys. Rev. B_ *13*, 5188 (1976) and _Phys. Rev. B_ *16*, 1748 (1977). 

 The  first  row  of  the  block is a set of integers defining the number of
 _k_-points to be used along each direction in reciprocal space. The numbers
 refer  to  the whole Brillouin zone, and the actual number of _k_-points is
 usually  reduced  exploiting  the  symmetries of the system. By default the
 grid  will  always  include the \Gamma-point. Optional rows can be added to
 specify  multiple  shifts in the _k_-points (between 0.0 and 1.0), in units
 of the Brillouin zone divided by the number in the first row. The number of
 columns  should  be  equal  to  Dimensions,  but the grid and shift numbers
 should be 1 and zero in finite directions. 

 For example, the following input samples the BZ with 100 points in the 
 _xy_-plane of reciprocal space: 

 %KPointsGrid 
   10 | 10 | 1 
 % 

END

Variable QPointsGrid
Type block
Default KPointsGrid
Section Mesh::KPoints
Description
 This  block allows to define a q-point grid used for the calculation of the
 Fock  operator  with  k-points. The _q_-points are distributed in a uniform
 grid, as done for the 
 KPointsGrid variable. See J. Chem Phys. 124, 154709 (2006) for details 

 For  each  dimension, the number of q point must be a divider of the number
 of k point 

 %QPointsGrid 
   2 | 2 | 1 
 % 

 At the moment, this is not compatible with k-point symmetries. 

END

Variable KPointsPath
Type block
Section Mesh::KPoints
Description
 When  this block is given, _k_-points are generated along a path defined by
 the points of the list. The points must be given in reduced coordinates. 

 The  first  row  of  the  block is a set of integers defining the number of
 _k_-points  for  each segments of the path. The number of columns should be
 equal  to  Dimensions, and the k-points coordinate should be zero in finite
 directions. 

 For example, the following input samples the BZ with 15 points: 

 %KPointsPath 
   10 | 5 
    0 | 0 | 0 
    0.5 | 0 | 0 
    0.5 | 0.5 | 0.5 
 % 

END

Variable KPoints
Type block
Section Mesh::KPoints
Description
 This  block  defines  an explicit set of _k_-points and their weights for a
 periodic-system  calculation.  The  first  column  is  the  weight  of each
 _k_-point and the following are the components of the _k_-point vector. You
 only  need to specify the components for the periodic directions. Note that
 the  _k_-points  should  be  given in Cartesian coordinates (not in reduced
 coordinates),  in  the  units  of  inverse  length.  The  weights  will  be
 renormalized so they sum to 1 (and must be rational numbers). 

 For example, if you want to include only the Gamma point, you can use: 

 %KPoints 
   1.0 | 0 | 0 | 0 
 % 

END

Variable KPointsReduced
Type block
Section Mesh::KPoints
Description
 Same  as  the  block  KPoints  but  this time the input is given in reduced
 coordinates,  _i.e._  what  Octopus  writes  in  a line in the ground-state
 standard output as 

 #k = 1, k = ( 0.154000, 0.154000, 0.154000). 
END

Variable TDExponentialMethod
Type integer
Default taylor
Section Time-Dependent::Propagation
Description
 Method  used to numerically calculate the exponential of the Hamiltonian, a
 core part of the full algorithm used to approximate the evolution operator,
 specified  through  the  variable  TDPropagator.  In  the case of using the
 Magnus method, described below, the action of the exponential of the Magnus
 operator  is  also  calculated  through  the  algorithm  specified  by this
 variable. 
Option lanczos 2
 Allows for larger time-steps. However, the larger the time-step, the longer
 the computational time per time-step. In certain cases, if the time-step is
 too  large,  the  code  will  emit a warning whenever it considers that the
 evolution  may  not  be  properly proceeding -- the Lanczos process did not
 converge.  The  method  consists  in a Krylov subspace approximation of the
 action  of the exponential (see M. Hochbruck and C. Lubich, _SIAM J. Numer.
 Anal._  *34*,  1911  (1997)  for  details).  Two more variables control the
 performance  of  the  method:  the  maximum  dimension  of  this  subspace
 (controlled by variable TDExpOrder), and the stopping criterion (controlled
 by  variable  TDLanczosTol).  The  smaller the stopping criterion, the more
 precisely  the exponential is calculated, but also the larger the dimension
 of  the Arnoldi subspace. If the maximum dimension allowed by TDExpOrder is
 not enough to meet the criterion, the above-mentioned warning is emitted. 
Option taylor 3
 This  method  amounts to a straightforward application of the definition of
 the exponential of an operator, in terms of its Taylor expansion. 

 \exp_{\rm  STD}  (-i\delta  t H) = \sum_{i=0}^{k} {(-i\delta t)^i\over{i!}}
 H^i. 

 The  order  _k_  is  determined  by  variable  TDExpOrder.  Some  numerical
 considerations  from  <a
 href=http://www.phys.washington.edu/~bertsch/num3.ps> Jeff Giansiracusa and
 George  F.  Bertsch</a>  suggest  the  4th order as especially suitable and
 stable. 
Option chebyshev 4
 In principle, the Chebyshev expansion of the exponential represents it more
 accurately than the canonical or standard expansion. As in the latter case,
 TDExpOrder determines the order of the expansion. 

 There exists a closed analytic form for the coefficients of the exponential
 in terms of Chebyshev polynomials: 

 \exp_{\rm  CHEB}  \left(  -i\delta  t  H  \right)  =  \sum_{k=0}^{\infty}
 (2-\delta_{k0})(-i)^{k}J_k(\delta t) T_k(H), 

 where  J_k  are  the  Bessel  functions  of the first kind, and H has to be
 previously  scaled  to  [-1,1].  See  H. Tal-Ezer and R. Kosloff, _J. Chem.
 Phys._  *81*,  3967  (1984); R. Kosloff, _Annu. Rev. Phys. Chem._ *45*, 145
 (1994); C. W. Clenshaw, _MTAC_ *9*, 118 (1955). 
END

Variable TDLanczosTol
Type float
Default 1e-5
Section Time-Dependent::Propagation
Description
 An  internal  tolerance  variable  for the Lanczos method. The smaller, the
 more  precisely  the  exponential  is  calculated,  and also the bigger the
 dimension  of  the  Krylov  subspace  needed  to perform the algorithm. One
 should  carefully  make  sure  that  this value is not too big, or else the
 evolution will be wrong. 
END

Variable TDExpOrder
Type integer
Default 4
Section Time-Dependent::Propagation
Description
 For  TDExponentialMethod  =  standard  or chebyshev, the order to which the
 exponential  is  expanded.  For  the  Lanczos  approximation,  it  is  the
 Lanczos-subspace dimension. 
END

Variable ArnoldiOrthogonalization
Type integer
Section Time-Dependent::Propagation
Description
 The  orthogonalization  method  used  for  the  Arnoldi procedure. Only for
 TDExponentialMethod = lanczos. 
Option cgs 3
 Classical Gram-Schmidt (CGS) orthogonalization. The algorithm is defined in
 Giraud et al., Computers and Mathematics with Applications 50, 1069 (2005).
 
Option drcgs 5
 Classical  Gram-Schmidt  orthogonalization  with  double-step
 reorthogonalization.  The  algorithm is taken from Giraud et al., Computers
 and  Mathematics  with  Applications  50,  1069  (2005).  According to this
 reference, this is much more precise than CGS or MGS algorithms. 
END

Variable KdotPUseNonLocalPseudopotential
Type logical
Default true
Section Linear Response::KdotP
Description
 For  testing  purposes,  set  to false to ignore the term -i \left[\vec{r},
 V\right]  in  the  \vec{k}  \cdot  \vec{p}  perturbation,  which  is due to
 non-local pseudopotentials. 
END

Variable KdotPVelMethod
Type integer
Default grad_vel
Section Linear Response::KdotP
Description
 Method of velocity calculation. 
Option grad_vel 0
 -i \left(\nabla + \left[r, V_{\rm nl} \right] \right) 
Option hcom_vel 1
 As  a  commutator  of the position operator and Hamiltonian, -i \left[ r, H
 \right]. 
END

Variable TheoryLevel
Type integer
Section Hamiltonian
Description
 The calculations can be run with different "theory levels" that control how
 electrons are simulated. The default is 
 dft.  When  hybrid  functionals  are  requested,  through  the XCFunctional
 variable, the default is 
 hartree_fock. 
Option independent_particles 2
 Particles  will  be  considered  as independent, _i.e._ as non-interacting.
 This  mode is mainly used for testing purposes, as the code is usually much
 faster with independent_particles. 
Option hartree 1
 Calculation  within  the Hartree method (experimental). Note that, contrary
 to  popular  belief,  the  Hartree  potential  is  self-interaction-free.
 Therefore,  this  run  mode  will  not  yield  the same result as kohn-sham
 without exchange-correlation. 
Option hartree_fock 3
 This is the traditional Hartree-Fock scheme. Like the Hartree scheme, it is
 fully self-interaction-free. 
Option kohn_sham 4
 This  is  the  default  density-functional theory scheme. Note that you can
 also  use  hybrid  functionals in this scheme, but they will be handled the
 "DFT" way, _i.e._, solving the OEP equation. 
Option generalized_kohn_sham 5
 This  is  similar  to  the  kohn-sham  scheme,  except that this allows for
 nonlocal  operators.  This  is  the default mode to run hybrid functionals,
 meta-GGA  functionals, or DFT+U. It can be more convenient to use kohn-sham
 DFT  within  the OEP scheme to get similar (but not the same) results. Note
 that  within  this scheme you can use a correlation functional, or a hybrid
 functional  (see  XCFunctional).  In the latter case, you will be following
 the quantum-chemistry recipe to use hybrids. 
Option rdmft 7
 (Experimental) Reduced Density Matrix functional theory. 
END

Variable XCKernel
Type integer
Section Hamiltonian::XC
Description
 Defines  the  exchange-correlation  kernel.  Only LDA kernels are available
 currently.  The  options  are the same as XCFunctional. Note: the kernel is
 only  needed  for  Casida,  Sternheimer,  or  optimal-control calculations.
 Defaults: 
 1D: lda_x_1d + lda_c_1d_csc 
 2D: lda_x_2d + lda_c_2d_amgb 
 3D: lda_x + lda_c_pz_mod 
Option xc_functional -1
 The same functional defined by XCFunctional. 
END

Variable EnablePhotons
Type logical
Default no
Section Hamiltonian
Description
 This  variable  can  be  used  to  enable  photons  in  several  types  of
 calculations.  It  can be used to activate the one-photon OEP formalism. In
 the  case of CalculationMode = casida, it enables photon modes as described
 in  ACS  Photonics  2019,  6,  11,  2757-2778.  Finally, if set to yes when
 solving  the  ferquency-dependent  Sternheimer  equation,  the  photons are
 coupled to the electronic subsystem. 
END

Variable VDWCorrection
Type integer
Default no
Section Hamiltonian::XC
Description
 (Experimental)  This  variable  selects  which  van der Waals correction to
 apply to the correlation functional. 
Option none 0
 No correction is applied. 
Option vdw_ts 1
 The scheme of Tkatchenko and Scheffler, Phys. Rev. Lett. 102 073005 (2009).
 
Option vdw_d3 3
 The  DFT-D3  scheme  of  S. Grimme, J. Antony, S. Ehrlich, and S. Krieg, J.
 Chem. Phys. 132, 154104 (2010). 
END

Variable VDWSelfConsistent
Type logical
Default yes
Section Hamiltonian::XC
Description
 This  variable  controls  whether  the  VDW  correction  is  applied
 self-consistently,  the  default,  or  just  as  a  correction to the total
 energy. This option only works with vdw_ts. 
END

Variable VDWD3Functional
Type string
Section Hamiltonian::XC
Description
 (Experimental)  You  can  use this variable to override the parametrization
 used  by  the  DFT-D3  van deer Waals correction. Normally you need not set
 this  variable,  as  the  proper  value  will  be  selected  by Octopus (if
 available). 

 This  variable  takes  a string value, the valid values can be found in the
 source file 'external_libs/dftd3/core.f90'. For example you can use: 

 VDWD3Functional = 'pbe' 

END

Variable CurrentDensity
Default gradient_corrected
Type integer
Section Hamiltonian
Description
 This variable selects the method used to calculate the current density. For
 the  moment  this variable is for development purposes and users should not
 need to use it. 
Option gradient 1
 The  calculation  of  current  is  done  using  the  gradient  operator.
 (Experimental) 
Option gradient_corrected 2
 The  calculation  of  current  is  done  using  the  gradient operator with
 additional corrections for the total current from non-local operators. 
Option hamiltonian 3
 The current density is obtained from the commutator of the Hamiltonian with
 the position operator. (Experimental) 
END

Variable OEPLevel
Type integer
Default oep_kli
Section Hamiltonian::XC
Description
 At  what level shall Octopus handle the optimized effective potential (OEP)
 equation. 
Option oep_none 1
 Do not solve OEP equation. 
Option oep_kli 3
 Krieger-Li-Iafrate  (KLI) approximation. Ref: JB Krieger, Y Li, GJ Iafrate,
 _Phys. Lett. A_ *146*, 256 (1990). 
Option oep_full 5
 (Experimental)  Full  solution  of  OEP  equation  using  the  Sternheimer
 approach.  The linear solver will be controlled by the variables in section
 Linear Response::Solver, and the iterations for OEP by Linear Response::SCF
 in LR calculations and variable 
 OEPMixing.  Note  that  default  for  LRMaximumIter  is  set to 10. Ref: S.
 Kuemmel and J. Perdew, _Phys. Rev. Lett._ *90*, 043004 (2003). 
END

Variable OEPMixing
Type float
Default 1.0
Section Hamiltonian::XC
Description
 The linear mixing factor used to solve the Sternheimer equation in the full
 OEP procedure. 
END

Variable OEPMixingScheme
Type integer
Default 1.0
Section Hamiltonian::XC
Description
 Different Mixing Schemes are possible 
Option OEP_MIXING_SCHEME_CONST 1
 Use  a  constant  Reference:  S.  Kuemmel and J. Perdew, _Phys. Rev. Lett._
 *90*, 4, 043004 (2003) 
Option OEP_MIXING_SCHEME_BB 2
 Use the Barzilai-Borwein (BB) Method Reference: T. W. Hollins, S. J. Clark,
 K. Refson, and N. I. Gidopoulos, 
 _Phys. Rev. B_ *85*, 235126 (2012) 
Option OEP_MIXING_SCHEME_DENS 3
 Use  the  inverse  of  the  electron  density  Reference: S. Kuemmel and J.
 Perdew, _Phys. Rev. B_ *68*, 035103 (2003) 
END

Variable KLIPhotonCOC
Type logical
Default .false.
Section Hamiltonian::XC
Description
 Activate  the  center of charge translation of the electric dipole operator
 which should avoid the dependence of the photon KLI on an permanent dipole.
 
END

Variable InvertKSmethod
Type integer
Default iterative
Section Calculation Modes::Invert KS
Description
 Selects  whether  the  exact two-particle method or the iterative scheme is
 used to invert the density to get the KS potential. 
Option two_particle 1
 Exact two-particle scheme. 
Option iterative 2
 Iterative scheme for v_s. 
Option iter_stella 3
 Iterative scheme for v_s using Stella and Verstraete method. 
Option iter_godby 4
 Iterative scheme for v_s using power method from Rex Godby. 
END

Variable KSInversionLevel
Type integer
Default ks_inversion_adiabatic
Section Calculation Modes::Invert KS
Description
 At what level Octopus shall handle the KS inversion. 
Option ks_inversion_none 1
 Do not compute KS inversion. 
Option ks_inversion_adiabatic 2
 Compute exact adiabatic v_{xc}. 
END

Variable KSInversionAsymptotics
Type integer
Default xc_asymptotics_none
Section Calculation Modes::Invert KS
Description
 Asymptotic correction applied to v_{xc}. 
Option xc_asymptotics_none 1
 Do not apply any correction in the asymptotic region. 
Option xc_asymptotics_sc 2
 Applies  the  soft-Coulomb  decay  of  -1/\sqrt{r^2+1}  to  v_{xc}  in  the
 asymptotic region. 
END

Variable InvertKSConvAbsDens
Type float
Default 1e-5
Section Calculation Modes::Invert KS
Description
 Absolute difference between the calculated and the target density in the KS
 inversion.  Has to be larger than the convergence of the density in the SCF
 run. 
END

Variable InvertKSStellaBeta
Type float
Default 1.0
Section Calculation Modes::Invert KS
Description
 residual term in Stella iterative scheme to avoid 0 denominators 
END

Variable InvertKSStellaAlpha
Type float
Default 0.05
Section Calculation Modes::Invert KS
Description
 prefactor term in iterative scheme from L Stella 
END

Variable InvertKSGodbyMu
Type float
Default 1.0
Section Calculation Modes::Invert KS
Description
 prefactor for iterative KS inversion convergence scheme from Godby based on
 van Leeuwen scheme 
END

Variable InvertKSGodbyPower
Type float
Default 0.05
Section Calculation Modes::Invert KS
Description
 power  to  which density is elevated for iterative KS inversion convergence
 scheme from Godby based on van Leeuwen scheme 
END

Variable InvertKSVerbosity
Type integer
Default 0
Section Calculation Modes::Invert KS
Description
 Selects what is output during the calculation of the KS potential. 
Option 0
 Only outputs the converged density and KS potential. 
Option 1
 Same  as 0 but outputs the maximum difference to the target density in each
 iteration in addition. 
Option 2
 Same as 1 but outputs the density and the KS potential in each iteration in
 addition. 
END

Variable InvertKSMaxIter
Type integer
Default 200
Section Calculation Modes::Invert KS
Description
 Selects  how  many  iterations  of  inversion will be done in the iterative
 scheme 
END

Variable ELFWithCurrentTerm
Type logical
Default true
Section Output
Description
 The  ELF,  when calculated for complex wavefunctions, should contain a term
 dependent  on  the  current.  This  term is properly calculated by default;
 however,  for  research  purposes  it  may be useful not to add it. If this
 feature proves to be useless, this option should go away. 
END

Variable Preconditioner
Type integer
Section SCF::Eigensolver
Description
 Which  preconditioner  to  use in order to solve the Kohn-Sham equations or
 the  linear-response  equations.  The  default  is  pre_filter,  except for
 curvilinear coordinates, where no preconditioner is applied by default. 
Option no 0
 Do not apply preconditioner. 
Option pre_filter 1
 Filter preconditioner. 
Option pre_jacobi 2
 Jacobi  preconditioner. Only the local part of the pseudopotential is used.
 Not very helpful. 
Option pre_poisson 3
 Uses  the  full  Laplacian  as  preconditioner.  The  inverse is calculated
 through  the  solution  of  the  Poisson equation. This is, of course, very
 slow. 
Option pre_multigrid 7
 Multigrid preconditioner. 
END

Variable PreconditionerFilterFactor
Type float
Section SCF::Eigensolver
Description
 This  variable  controls how much filter preconditioner is applied. A value
 of 1.0 means no preconditioning, 0.5 is the standard. 

 The default is 0.5, except for periodic systems where the default is 0.6. 

 If  you  observe  that  the first eigenvectors are not converging properly,
 especially for periodic systems, you should increment this value. 

 The  allowed  range  for  this  parameter is between 0.5 and 1.0. For other
 values, the SCF may converge to wrong results. 
END

Variable PreconditionerIterationsPre
Type integer
Section SCF::Eigensolver
Description
 This  variable  is the number of pre-smoothing iterations for the multigrid
 preconditioner. The default is 1. 
END

Variable PreconditionerIterationsMiddle
Type integer
Section SCF::Eigensolver
Description
 This  variable  is  the number of smoothing iterations on the coarsest grid
 for the multigrid preconditioner. The default is 1. 
END

Variable PreconditionerIterationsPost
Type integer
Section SCF::Eigensolver
Description
 This  variable is the number of post-smoothing iterations for the multigrid
 preconditioner. The default is 2. 
END

Variable PseudopotentialSet
Type integer
Default standard
Section System::Species
Description
 Selects the set of pseudopotentials used by default for species not defined
 in the Species block. 

 These  sets  of  pseudopotentials  come  from  different  sources.  Octopus
 developers  have  not  validated  them.  We  include them with the code for
 convenience  of  the  users,  but you are expected to check the quality and
 suitability of the pseudopotential for your application. 

Option none 0
 Do  not  load any pseudopotential by default. All species must be specified
 in the Species block. 
Option standard 1
 The  standard  set of Octopus that provides LDA pseudopotentials in the PSF
 format for some elements: H, Li, C, N, O, Na, Si, S, Ti, Se, Cd. 
Option sg15 2
 The  set of Optimized Norm-Conserving Vanderbilt PBE pseudopotentials. Ref:
 M.  Schlipf  and  F. Gygi, _Comp. Phys. Commun._ *196*, 36 (2015). This set
 provides  pseudopotentials  for  elements  up  to  Z  =  83 (Bi), excluding
 Lanthanides. Current version of the set is 1.2. 
Option hgh_lda 3
 The  set  of  Hartwigsen-Goedecker-Hutter LDA pseudopotentials for elements
 from  H to Rn. Ref: C. Hartwigsen, S. Goedecker, and J. Hutter, _Phys. Rev.
 B_ *58*, 3641 (1998). 
Option hgh_lda_sc 31
 The  semicore set of Hartwigsen-Goedecker-Hutter LDA pseudopotentials. Ref:
 C.  Hartwigsen,  S.  Goedecker,  and  J.  Hutter, _Phys. Rev. B_ *58*, 3641
 (1998). 
Option hscv_lda 4
 The  set  of  Hamann-Schlueter-Chiang-Vanderbilt  (HSCV) potentials for LDA
 exchange  and  correlation  downloaded  from
 http://fpmd.ucdavis.edu/potentials/index.htm.  These  pseudopotentials were
 originally intended for the QBox code. They were generated using the method
 of  Hamann,  Schluter  and Chiang. Ref: D. Vanderbilt, _Phys. Rev. B_ *32*,
 8412  (1985).  Warning  from  the original site: The potentials provided in
 this  site are distributed without warranty. In most cases, potentials were
 not  tested.  Potentials  should  be thoroughly tested before being used in
 simulations. 
Option hscv_pbe 5
 PBE  version  of  the HSCV pseudopotentials. Check the documentation of the
 option hscv_lda for details and warnings. 
Option pseudodojo_pbe 100
 PBE version of the pseudopotentials of http://pseudo-dojo.org. Version 0.4.
 
Option pseudodojo_lda 103
 LDA pseudopotentials of http://pseudo-dojo.org. Version 0.4. 
Option pseudodojo_pbesol 105
 PBEsol  version  of the pseudopotentials of http://pseudo-dojo.org. Version
 0.3. 
END

Variable Species
Type block
Section System::Species
Description
 A  species  is  by  definition  either  an "ion" (nucleus + core electrons)
 described through a pseudopotential, or a model potential. 

 Note  that  some sets of pseudopotentials are distributed with the code. To
 use  these  pseudopotentials,  you do not need to define them explicitly in
 the  Species  block, as default parameters are provided. You can select the
 set for default pseudopotentials using the 
 PseudopotentialSet variable. 

 Additional  pseudopotentials  can  be  downloaded  from  the  <a
 href='http://octopus-code.org/wiki/Pseudopotentials'>  octopus homepage</a>
 or  from  other  sources. Supported norm-conserving pseudopotential formats
 are  detected  by  the  file extension: UPF (.upf), PSF (SIESTA, .psf), FHI
 (ABINIT 6, .fhi), CPI (Fritz-Haber, .cpi), QSO (quantum-simulation.org, for
 Qbox, .xml), HGH (Hartwigsen-Goedecker-Hutter, .hgh). PSPIO format can also
 be used via species_pspio if that library is linked. Note: pseudopotentials
 may only be used in 3D. 

 The format of this block is the following: The first field is a string that
 defines  the  name  of  the  species.  The second field defines the type of
 species (the valid options are detailed below). 

 Then  a list of parameters follows. The parameters are specified by a first
 field  with the parameter name and the field that follows with the value of
 the  parameter.  Some  parameters  are  specific to a certain species while
 others  are  accepted  by  all  species.  These  are mass, max_spacing, and
 min_radius. 

 These are examples of possible species: 

 %Species 
   'O' | species_pseudo | file | 'O.psf' | lmax | 1 | lloc | 1 
   'H' | species_pseudo | file | '../H.hgh' 
   'Xe' | species_pseudo | set | pseudojo_pbe_stringent 
   'C' | species_pseudo | file | "carbon.xml" 
   'jlm' | species_jellium | jellium_radius | 5.0 
   'rho'  |  species_charge_density | density_formula | "exp(-r/a)" | mass |
 17.0 | valence | 6 
   'udf'  | species_user_defined | potential_formula | "1/2*r^2" | valence |
 8 
   'He_all' | species_full_delta 
   'H_all' | species_full_gaussian | gaussian_width | 0.2 
   'Li1D' | species_soft_coulomb | softening | 1.5 | valence | 3 
 % 
Option species_pseudo  -7
 The  species  is  a  pseudopotential. How to get the pseudopotential can be
 specified  by  the  file  or  the  set parameters. If both are missing, the
 pseudopotential will be taken from the PseudopotentialSet specified for the
 run,  this  is  useful if you want to change some parameters of the pseudo,
 like the mass. 

 The optional parameters for this type of species are 
 lmax,  that  defines the maximum angular momentum component to be used, and
 lloc,  that  defines  the  angular momentum to be considered as local. When
 these  parameters  are  not  set, the value for lmax is the maximum angular
 component  from  the  pseudopotential  file.  The default value for lloc is
 taken  from  the pseudopotential if available, if not, it is set to 0. Note
 that, depending on the type of pseudopotential, it might not be possible to
 select 
 lmax and lloc, if that is the case the parameters will be ignored. 

Option species_pspio  -110
 (experimental)  Alternative method to read pseudopotentials using the PSPIO
 library. This species uses the same parameters as species_pseudo. 
Option species_user_defined -123
 Species  with  user-defined  potential.  The  potential  for the species is
 defined by the formula given by the potential_formula parameter. The 
 valence  parameter  determines  the number of electrons associated with the
 species. By default, a valence of 0 is assumed. 
Option species_charge_density -125
 The  potential  for this species is created from the distribution of charge
 given by the density_formula parameter. The 
 valence  parameter  determines  the number of electrons associated with the
 species. By default, a valence of 0 is assumed. 
Option species_point  -3
Option species_jellium  -3
 Jellium  sphere.  The  charge associated with this species must be given by
 the valence parameter. 
Option species_jellium_slab  -4
 A slab of jellium that extends across the simulation box in the 
 _xy_-plane.  The  dimension  along  the  _z_ direction is determined by the
 required  parameter thickness. The charge associated with this species must
 be given by the valence parameter. 
Option species_full_delta   -127
 Full  atomic potential represented by a delta charge distribution. The atom
 will  be  displaced  to  the  nearest  grid  point.  The  atomic  number is
 determined from the name of the species. 
Option species_full_gaussian   -124
 A  full-potential  atom  is  defined by a Gaussian accumulation of positive
 charge (distorted if curvilinear coordinates are used), in the form: 

 q(r) = z \beta \exp[ - (\vec{r}-\vec{r_0})^2 / (\sqrt{2} \delta \sigma) ]  

 \beta  is chosen in order to maintain proper normalization (the integral of
 q should sum up to 
 z). \delta is the grid spacing (the grid spacing in the first dimension, to
 be precise). 
 \vec{r_0}  is  calculated in such a way that the the first moment of q(r)/z
 is  equal  to  the  atomic  position.  For a precise description, see N. A.
 Modine, 
 _Phys.  Rev.  B_  *55*,  10289  (1997). The width of the Gaussian is set by
 parameter  gaussian_width. The atomic number is determined from the name of
 the species. 
Option species_from_file  -126
 The  potential  is  read  from  a  file. Accepted file formats, detected by
 extension: obf, ncdf and csv. The 
 valence  parameter  determines  the number of electrons associated with the
 species. By default, a valence of 0 is assumed. 
Option species_soft_coulomb -128
 The potential is a soft-Coulomb function, _i.e._ a function in the form: 

 v(r) = - z_{val} / \sqrt{a^2 + r^2} 

 The  value of _a_ should be given by the mandatory softening parameter. The
 charge associated with this species must be given by the valence parameter.
 
Option species_jellium_charge_density -129
 The  parameter  is  the  name of a volume block specifying the shape of the
 jellium. 
Option lmax -10003
 The  maximum  angular-momentum  channel  that  will  be  used  for  the
 pseudopotential. 
Option lloc -10004
 The angular-momentum channel of the pseudopotential to be considered local.
 
Option mass -10005
 The  mass  of the species in atomic mass units, _i.e._ the mass of a proton
 is roughly one. It is set automatically for pseudopotentials from the 
 <a  href=http://www.nist.gov/pml/data/comp.cfm>NIST  values</a>.  For other
 species, the default is 1.0. 
Option valence -10006
 The  number  of  electrons  of  the  species.  It  is set automatically for
 pseudopotentials, but is mandatory for other species. 
Option jellium_radius -10007
 The  radius  of  the  sphere  for  species_jellium.  If  this  value is not
 specified, the default of 0.5 bohr is used. 
Option set -10017
 For  a  species_pseudo, get the pseudopotential from a particular set. This
 flag  must  be  followed  with  one  of  the  valid values for the variable
 PseudopotentialSet. 
Option gaussian_width -10008
 The  width  of  the  Gaussian  (in  units of spacing) used to represent the
 nuclear  charge  for  species_full_gaussian. If not present, the default is
 0.25. 
Option softening -10009
 The softening parameter _a_ for species_soft_coulomb in units of length. 
Option file -10010
 The path for the file that describes the species. 
Option db_file -10011
 Obsolete. Use the set option of the PseudopotentialSet variable instead. 
Option potential_formula -10012
 Mathematical  expression  that  defines  the  potential  for
 species_user_defined.  You  can  use  any  of  the  _x_,  _y_,  _z_  or _r_
 variables. 
Option density_formula -10013
 Mathematical  expression  that  defines  the  charge  density  for
 species_charge_density.  You  can  use  any  of  the  _x_,  _y_, _z_ or _r_
 variables. 
Option thickness -10014
 The thickness of the slab for species_jellium_slab. Must be positive. 
Option vdw_radius -10015
 The van der Waals radius that will be used for this species. 
Option volume -10016
 Name of a volume block 
Option hubbard_l -10018
 The angular-momentum for which the effective U will be applied. 
Option hubbard_u -10019
 The effective U that will be used for the LDA+U calculations. 
Option hubbard_j -10020
 The value of j (hubbard_l-1/2 or hubbard_l+1/2) on which the effective U is
 applied. 
Option hubbard_alpha -10021
 The strength of the potential constraining the occupations of the localized
 subspace as defined in PRB 71, 035105 (2005) 
END

Variable SpeciesProjectorSphereThreshold
Type float
Default 0.001
Section System::Species
Description
 The  pseudopotentials  may  be  composed  of  a  local  part,  and a linear
 combination  of  nonlocal  operators.  These  nonlocal  projectors  have
 "projector"  form,  \left|  v \right> \left< v \right|  (or, more generally
 speaking,  \left|  u  \right>  \left<  v  \right|  ).  These projectors are
 localized  in  real  space  -- that is, the function v has a finite support
 around  the  nucleus. This region where the projectors are localized should
 be small or else the computation time required to operate with them will be
 very large. 

 In  practice, this localization is fixed by requiring the definition of the
 projectors  to be contained in a sphere of a certain radius. This radius is
 computed by making sure that the absolute value of the projector functions,
 at  points  outside  the localization sphere, is below a certain threshold.
 This threshold is set by SpeciesProjectorSphereThreshold. 
END

Variable AOTruncation
Type flag
Default ao_full
Section Atomic Orbitals
Description
 This  option  determines  how  Octopus  will truncate the orbitals used for
 LDA+U.  Except for the full method, the other options are only there to get
 a quick idea. 
Option ao_full bit(0)
 The  full  size  of  the orbitals used. The radius is controled by variable
 AOThreshold. 
Option ao_box bit(1)
 The  radius  of  the  orbitals are restricted to the size of the simulation
 box.  This  reduces  the  number of points used to discretize the orbitals.
 This  is  mostly  a debug option, and one should be aware that changing the
 size of the simulation box will affect the result of the calculation. It is
 recommended to use ao_nlradius instead. 
Option ao_nlradius bit(2)
 The  radius  of  the orbitals are restricted to the radius of the non-local
 part of the pseudopotential of the corresponding atom. 
END

Variable AOThreshold
Type float
Default 0.01
Section Atomic Orbitals
Description
 Determines  the threshold used to compute the radius of the atomic orbitals
 for  LDA+U  and  for Wannier90. This radius is computed by making sure that
 the  absolute  value  of the radial part of the atomic orbital is below the
 specified threshold. This value should be converged to be sure that results
 do  not  depend  on this value. However increasing this value increases the
 number  of  grid  points  covered  by  the  orbitals  and  directly  affect
 performances. 
END

Variable AONormalize
Type logical
Default yes
Section Atomic Orbitals
Description
 If  set  to  yes,  Octopus will normalize the atomic orbitals individually.
 This variable is ignored is AOLoewdin<\tt> is set to yes. 
END

Variable AOSubmesh
Type logical
Section Atomic Orbitals
Description
 If  set to yes, Octopus will use submeshes to internally store the orbitals
 with  their  phase  instead  of  storing  them on the mesh. This is usually
 slower  for  small  periodic  systems,  but  becomes advantageous for large
 supercells.  Submeshes  are  not compatible with Loewdin orthogonalization.
 For  periodic  systems,  the default is set to no, whereas it is set to yes
 for isolated systems. 
END

Variable AOLoewdin
Type logical
Default no
Section Atomic Orbitals
Description
 This  option  determines  if  the atomic orbital basis is orthogonalized or
 not.  This  is  done  for  using  the Loewdin orthogonalization scheme. The
 default  is  set to no for the moment as this option is not yet implemented
 for isolated systems, and seems to lead to important egg-box effect 
END

Variable OperateDouble
Type integer
Section Execution::Optimization
Default optimized
Description
 This variable selects the subroutine used to apply non-local operators over
 the grid for real functions. 
Option fortran 0
 The standard Fortran function. 
Option optimized 1
 This version is optimized using vector primitives (if available). 
END

Variable OperateComplex
Type integer
Section Execution::Optimization
Default optimized
Description
 This variable selects the subroutine used to apply non-local operators over
 the grid for complex functions. 
Option fortran 0
 The standard Fortran function. 
Option optimized 1
 This version is optimized using vector primitives (if available). 
END

Variable OperateSingle
Type integer
Section Execution::Optimization
Default optimized
Description
 This variable selects the subroutine used to apply non-local operators over
 the grid for single-precision real functions. 
Option fortran 0
 The standard Fortran function. 
Option optimized 1
 This version is optimized using vector primitives (if available). 
END

Variable OperateComplexSingle
Type integer
Section Execution::Optimization
Default optimized
Description
 This variable selects the subroutine used to apply non-local operators over
 the grid for single-precision complex functions. 
Option fortran 0
 The standard Fortran function. 
Option optimized 1
 This version is optimized using vector primitives (if available). 
END

Variable OperateAccel
Type integer
Default map
Section Execution::Optimization
Description
 This variable selects the subroutine used to apply non-local operators over
 the grid when an accelerator device is used. 
Option invmap 1
 The standard implementation ported to OpenCL. 
Option map 2
 A different version, more suitable for GPUs. 
END

Variable NLOperatorCompactBoundaries
Type logical
Default no
Section Execution::Optimization
Description
 (Experimental)  When  set  to  yes,  for  finite  systems  Octopus will map
 boundary points for finite-differences operators to a few memory locations.
 This  increases  performance,  however  it is experimental and has not been
 thoroughly tested. 
END

Variable CurvGygiA
Type float
Default 0.5
Section Mesh::Curvilinear::Gygi
Description
 The  grid spacing is reduced locally around each atom, and the reduction is
 given by 1/(1+_A_), where _A_ is specified by this variable. So, if 
 _A_=1/2  (the  default),  the  grid  spacing  is  reduced  to  two thirds =
 1/(1+1/2).  [This  is  the  A_{\alpha}  variable in Eq. 2 of F. Gygi and G.
 Galli, _Phys. Rev. B_ *52*, R2229 (1995)]. It must be larger than zero. 
END

Variable CurvGygiAlpha
Type float
Default 2.0 a.u.
Section Mesh::Curvilinear::Gygi
Description
 This number determines the region over which the grid is enhanced (range of
 enhancement  of  the resolution). That is, the grid is enhanced on a sphere
 around  each  atom,  whose  radius  is given by this variable. [This is the
 a_{\alpha}  variable in Eq. 2 of F. Gygi and G. Galli, _Phys. Rev. B_ *52*,
 R2229 (1995)]. It must be larger than zero. 
END

Variable CurvGygiBeta
Type float
Default 4.0 a.u.
Section Mesh::Curvilinear::Gygi
Description
 This  number  determines  the distance over which Euclidean coordinates are
 recovered.  [This  is  the  b_{\alpha}  variable in Eq. 2 of F. Gygi and G.
 Galli, 
 _Phys. Rev. B_ *52*, R2229 (1995)]. It must be larger than zero. 
END

Variable Volume
Type block
Default
Section Utilities::
Description
 Describes  a  volume in space defined through the addition and substraction
 of  spheres.  The  first  field  is  always  "+" (include points inside the
 volume) or "-" (exclude points inside the volume) 
Option vol_sphere 10001

 %Volume 
    "+"/"-" | vol_sphere | center_x | center_y | center_z | radius 
 % 
Option vol_slab 10002

 %Volume 
    "+"/"-" | vol_slab | thickness 
 % 

END

Variable SpiralBoundaryCondition
Type logical
Default no
Section Mesh
Description
 (Experimental)  If  set  to  yes,  Octopus  will apply spin-spiral boundary
 conditions. The momentum of the spin spiral is defined by the variable 
 TDMomentumTransfer 
END

Variable RestartOptions
Type block
Section Execution::IO
Description
 Octopus usually stores binary information, such as the wavefunctions, to be
 used  in  subsequent  calculations.  The  most  common  example  is  the
 ground-state  states  that  are used to start a time-dependent calculation.
 This  variable  allows  to  control where this information is written to or
 read  from.  The  format of this block is the following: for each line, the
 first  column  indicates  the type of data, the second column indicates the
 path  to  the  directory that should be used to read and write that restart
 information,  and  the  third  column, which is optional, allows one to set
 some  flags to modify the way how the data is read or written. For example,
 if  you  are  running  a time-dependent calculation, you can indicate where
 Octopus can find the ground-state information in the following way: 

 %RestartOptions 
   restart_gs | "gs_restart" 
   restart_td | "td_restart" 
 % 

 The  second  line  of  the  above  example  also  tells  Octopus  that  the
 time-dependent  restart  data  should  be  read  from  and  written  to the
 "td_restart" directory. 

 In case you want to change the path of all the restart directories, you can
 use  the restart_all option. When using the restart_all option, it is still
 possible to have a different restart directory for specific data types. For
 example, when including the following block in your input file: 

 %RestartOptions 
   restart_all | "my_restart" 
   restart_td  | "td_restart" 
 % 

 the  time-dependent  restart information will be stored in the "td_restart"
 directory,  while  all  the remaining restart information will be stored in
 the "my_restart" directory. 

 By default, the name of the "restart_all" directory is set to "restart". 

 Some  CalculationModes  also  take  into  account specific flags set in the
 third  column  of  the RestartOptions block. These are used to determine if
 some  specific  part of the restart data is to be taken into account or not
 when  reading  the  restart  information.  For  example,  when restarting a
 ground-state  calculation,  one  can set the restart_rho flags, so that the
 density used is not built from the saved wavefunctions, but is instead read
 from the restart directory. In this case, the block should look like this: 

 %RestartOptions 
   restart_gs | "restart" | restart_rho 
 % 

 A  list  of  available  flags  is given below, but note that the code might
 ignore  some  of them, which will happen if they are not available for that
 particular  calculation, or might assume some of them always present, which
 will happen in case they are mandatory. 

 Finally,  note  that  all  the  restart information of a given data type is
 always  stored  in  a  subdirectory of the specified path. The name of this
 subdirectory  is  fixed  and  cannot  be changed. For example, ground-state
 information  will always be stored in a subdirectory named "gs". This makes
 it safe in most situations to use the same path for all the data types. The
 name  of  these  subdirectories is indicated in the description of the data
 types below. 

 Currently, the available restart data types and flags are the following: 
Option restart_all 0
 (data  type)  Option  to  globally  change  the  path  of  all  the restart
 information. 
Option restart_gs  1
 (data  type)  The  data  resulting  from  a  ground-state calculation. This
 information is stored under the "gs" subdirectory. 
Option restart_unocc 2
 (data  type) The data resulting from an unoccupied states calculation. This
 information  also corresponds to a ground state and can be used as such, so
 it is stored under the same subdirectory as the one of restart_gs. 
Option restart_td 3
 (data type) The data resulting from a real-time time-dependent calculation.
 This information is stored under the "td" subdirectory. 
Option restart_em_resp 4
 (data  type) The data resulting from the calculation of the electromagnetic
 response  using  the Sternheimer approach. This information is stored under
 the "em_resp" subdirectory. 
Option restart_em_resp_fd 5
 (data  type) The data resulting from the calculation of the electromagnetic
 response  using  finite-differences.  This  information is stored under the
 "em_resp_fd" subdirectory. 
Option restart_kdotp 6
 (data  type) The data resulting from the calculation of effective masses by
 k.p  perturbation  theory.  This  information  is  stored under the "kdotp"
 subdirectory. 
Option restart_vib_modes 7
 (data  type)  The data resulting from the calculation of vibrational modes.
 This information is stored under the "vib_modes" subdirectory. 
Option restart_vdw 8
 (data  type)  The  data  resulting  from  the  calculation of van der Waals
 coefficients. This information is stored under the "vdw" subdirectory. 
Option restart_casida 9
 (data  type) The data resulting from a Casida calculation. This information
 is stored under the "casida" subdirectory. 
Option restart_oct 10
 (data  type) The data for optimal control calculations. This information is
 stored under the "opt-control" subdirectory. 
Option restart_partition 11
 (data  type) The data for the mesh partitioning. This information is stored
 under the "partition" subdirectory. 
Option restart_proj 12
 (data  type)  The ground-state to be used with the td_occup and populations
 options of TDOutput. This information should be a ground state, so the "gs"
 subdirectory is used. 
Option restart_states 1
 (flag) Read the electronic states. (not yet implemented) 
Option restart_rho 2
 (flag) Read the electronic density. 
Option restart_vhxc 4
 (flag) Read the Hartree and XC potentials. 
Option restart_mix 8
 (flag) Read the SCF mixing information. 
Option restart_skip 16
 (flag)  This  flag  allows  to selectively skip the reading and writting of
 specific restart information. 
END

Variable RestartWrite
Type logical
Default true
Section Execution::IO
Description
 If  this  variable  is  set to no, restart information is not written. Note
 that  some  run  modes  will  ignore  this  option  and  write some restart
 information anyway. 
END

Variable MultigridLevels
Type integer
Default max_levels
Section Mesh
Description
 Number of levels in the grid hierarchy used for multigrid. Positive numbers
 indicate an absolute number of levels, negative numbers are subtracted from
 the maximum number of levels possible. 
Option max_levels 0
 Calculate the optimal number of levels for the grid. 
END

Variable MultigridDerivativesOrder
Type integer
Default 1
Section Mesh::Derivatives
Description
 This  variable  gives the discretization order for the approximation of the
 differential  operators  on the different levels of the multigrid. For more
 details, see the variable DerivativesOrder. 
END

Variable InterpolationTestOrder
Type integer
Default 1
Section Calculation Modes::Test
Description
 This  variable  controls  the  order  of the grid interpolation used in the
 corresponding unit test. 
END

Variable MeshPartitionPackage
Type integer
Section Execution::Parallelization
Description
 Decides  which  library  to  use  to perform the mesh partition. By default
 ParMETIS is used when available, otherwise METIS is used. 
Option metis 1
 METIS library. 
Option parmetis 2
 (Experimental)  Use  ParMETIS  libary  to  perform the mesh partition. Only
 available if the code was compiled with ParMETIS support. 
Option part_hilbert 3
 Use the ordering along the Hilbert curve for partitioning. 
END

Variable MeshPartitionStencil
Type integer
Default stencil_star
Section Execution::Parallelization
Description
 To  partition  the  mesh, it is necessary to calculate the connection graph
 connecting  the  points.  This variable selects which stencil is used to do
 this. 
Option stencil_star 1
 An order-one star stencil. 
Option laplacian 2
 The stencil used for the Laplacian is used to calculate the partition. This
 in  principle should give a better partition, but it is slower and requires
 more memory. 
END

Variable MeshPartition
Type integer
Section Execution::Parallelization
Description
 When  using METIS to perform the mesh partitioning, decides which algorithm
 is  used.  By default, graph partitioning is used for 8 or more partitions,
 and rcb for fewer. 
Option rcb 1
 Recursive coordinate bisection partitioning. 
Option graph 2
 Graph partitioning (called 'k-way' by METIS). 
END

Variable Spacing
Type float
Section Mesh
Description
 The  spacing  between  the points in the mesh. This controls the quality of
 the  discretization:  smaller  spacing  gives  more  precise  results  but
 increased computational cost. 

 When  using  curvilinear coordinates, this is a canonical spacing that will
 be  changed  locally  by  the  transformation. In periodic directions, your
 spacing may be slightly different than what you request here, since the box
 size must be an integer multiple of the spacing. 

 The  default  value  is  defined  by  the  species  if  only  default
 pseudopotentials  are  used  or  by  the  image  resolution  if  BoxShape =
 box_image. Otherwise, there is no default. 

 It  is  possible  to  have a different spacing in each one of the Cartesian
 directions if we define Spacing as block of the form 

 %Spacing 
   spacing_x | spacing_y | spacing_z 
 % 
END

Variable PeriodicBoundaryMask
Type block
Section Mesh
Description
 (Experimental) Defines a mask for which periodic boundaries are replaced by
 zero boundary conditions. 
END

Variable CurvMethod
Type integer
Default curv_uniform
Section Mesh::Curvilinear
Description
 The  relevant functions in octopus are represented on a mesh in real space.
 This mesh may be an evenly spaced regular rectangular grid (standard mode),
 or else an adaptive or curvilinear grid. We have implemented three kinds of
 adaptive  meshes,  although only one is currently working, the one invented
 by  F.  Gygi  (curv_gygi).  The  code  will stop if any of the other two is
 invoked. All are experimental with domain parallelization. 
Option curv_affine 1
 Regular, uniform rectangular grid. 
Option curv_gygi 2
 The deformation of the grid is done according to the scheme described by F.
 Gygi [F. Gygi and G. Galli, _Phys. Rev. B_ *52*, R2229 (1995)]. 
Option curv_briggs 3
 The  deformation  of  the grid is done according to the scheme described by
 Briggs  [E.L.  Briggs,  D.J. Sullivan, and J. Bernholc, _Phys. Rev. B_ *54*
 14362 (1996)] (NOT WORKING). 
Option curv_modine 4
 The  deformation  of  the grid is done according to the scheme described by
 Modine  [N.A. Modine, G. Zumbach and E. Kaxiras, _Phys. Rev. B_ *55*, 10289
 (1997)] (NOT WORKING). 
END

Variable MeshLocalOrder
Default blocks
Type integer
Section Execution::Optimization
Description
 This  variable  controls  how the grid points are mapped to a linear array.
 This influences the performance of the code. 
Option order_blocks 1
 The  grid  is  mapped  using  small parallelepipedic grids. The size of the
 blocks is controlled by MeshBlockSize. 
Option order_cube 3
 The grid is mapped using a full cube, i.e. without blocking. 
Option order_global 4
 Use the ordering from the global mesh 
END

Variable MeshLocalBlockDirection
Type integer
Section Execution::Optimization
Description
 Determines  the direction in which the dimensions are chosen to compute the
 blocked  index  for  sorting  the mesh points (see MeshLocalBlockSize). The
 default is increase_with_dimensions, corresponding to xyz ordering in 3D. 
Option increase_with_dimension 1
 The  fastest  changing  index  is  in the first dimension, i.e., in 3D this
 corresponds to ordering in xyz directions. 
Option decrease_with_dimension 2
 The  fastest  changing  index  is  in  the last dimension, i.e., in 3D this
 corresponds to ordering in zyx directions. 
END

Variable MeshLocalBlockSize
Type block
Section Execution::Optimization
Description
 To improve memory-access locality when calculating derivatives, 
 Octopus  arranges mesh points in blocks. This variable controls the size of
 this  blocks in the different directions. The default is selected according
 to  the  value of the StatesBlockSize variable. (This variable only affects
 the performance of Octopus and not the results.) 
END

Variable MeshIndexType
Type integer
Default idx_cubic
Section Mesh
Description
 Determine index type. Must be the same for restarting a calculation. 
Option idx_cubic 1
 Cubic indices are used to map the spatial information to the grid points. 
Option idx_hilbert 2
 A Hilbert space-filling curve is used to map the spatial information to the
 grid points. 
END

Variable MeshPartitionVirtualSize
Type integer
Default mesh mpi_grp size
Section Execution::Parallelization
Description
 Gives the possibility to change the partition nodes. Afterward, it crashes.
 
END

Variable MeshUseTopology
Type logical
Default false
Section Execution::Parallelization
Description
 (experimental)  If enabled, Octopus will use an MPI virtual topology to map
 the  processors.  This  can improve performance for certain interconnection
 systems. 
END

Variable PartitionPrint
Type logical
Default true
Section Execution::Parallelization
Description
 (experimental)  If  disabled,  Octopus  will  not  compute  nor  print  the
 partition  information,  such  as  local  points,  no. of neighbours, ghost
 points and boundary points. 
END

Variable MeshOrder
Type integer
Section Execution::Optimization
Description
 This variable controls how the grid points are mapped to a linear array for
 global  arrays. For runs that are parallel in domains, the local mesh order
 may be different (see 
 MeshLocalOrder). The default is blocks when serial in domains and cube when
 parallel in domains with the local mesh order set to blocks. 
Option order_blocks 1
 The  grid  is  mapped  using  small parallelepipedic grids. The size of the
 blocks is controlled by MeshBlockSize. 
Option order_original 2
 The original order of the indices is used to map the grid. 
Option order_cube 3
 The grid is mapped using a full cube, i.e. without blocking. 
END

Variable MeshBlockDirection
Type integer
Section Execution::Optimization
Description
 Determines  the direction in which the dimensions are chosen to compute the
 blocked  index for sorting the mesh points (see MeshBlockSize). The default
 is increase_with_dimensions, corresponding to xyz ordering in 3D. 
Option increase_with_dimension 1
 The  fastest  changing  index  is  in the first dimension, i.e., in 3D this
 corresponds to ordering in xyz directions. 
Option decrease_with_dimension 2
 The  fastest  changing  index  is  in  the last dimension, i.e., in 3D this
 corresponds to ordering in zyx directions. 
END

Variable MeshBlockSize
Type block
Section Execution::Optimization
Description
 To improve memory-access locality when calculating derivatives, 
 Octopus  arranges mesh points in blocks. This variable controls the size of
 this  blocks in the different directions. The default is selected according
 to  the  value of the StatesBlockSize variable. (This variable only affects
 the performance of Octopus and not the results.) 
END

Variable CurvModineXBar
Type float
Default 1/3
Section Mesh::Curvilinear::Modine
Description
 Size  of  central flat region (in units of Lsize). Must be between 0 and 1.
 See  N.  A.  Modine,  G.  Zumbach,  and  E.  Kaxiras,  _Phys. Rev. B_ *55*,
 10289-10301 (1997). 
END

Variable CurvModineJBar
Type float
Default 1/2
Section Mesh::Curvilinear::Modine
Description
 Increase  in  density  of  points  is  inverse of this parameter. See N. A.
 Modine,  G.  Zumbach,  and  E.  Kaxiras,  _Phys.  Rev. B_ *55*, 10289-10301
 (1997). 
END

Variable CurvModineJlocal
Type float
Default 0.25
Section Mesh::Curvilinear::Modine
Description
 Local  refinement  around  the  atoms.  Must  be between 0 and 1. See N. A.
 Modine,  G.  Zumbach,  and  E.  Kaxiras,  _Phys.  Rev. B_ *55*, 10289-10301
 (1997). 
END

Variable CurvModineJrange
Type float
Default 2 b
Section Mesh::Curvilinear::Modine
Description
 Local  refinement  range  (a  length). See N. A. Modine, G. Zumbach, and E.
 Kaxiras, _Phys. Rev. B_ *55*, 10289-10301 (1997). 
END

Variable Output
Type block
Default none
Section Output
Description
 Specifies  what to print. Each output must be in a separate row. Optionally
 individual  output formats and output intervals can be defined for each row
 or  they  can  be  read  separately  from  OutputFormat  and OutputInterval
 variables in the input file. The output files are written at the end of the
 run  into  the output directory for the relevant kind of run (_e.g._ static
 for  CalculationMode  =  gs).  Time-dependent  simulations  print  only per
 iteration, including always the last. The frequency of output per iteration
 (available  for CalculationMode = gs, unocc, td, and opt_control) is set by
 OutputInterval  and  the  directory  is  set  by  OutputIterDir.  For
 linear-response  run  modes,  the  derivatives  of  many  quantities can be
 printed,  as  listed  in  the  options  below.  Indices in the filename are
 labelled as follows: 
 sp  =  spin (or spinor component), k = _k_-point, st = state/band. There is
 no  tag  for  directions,  given as a letter. The perturbation direction is
 always  the  last direction for linear-response quantities, and a following
 +/- indicates the sign of the frequency. 

 Example (minimal): 
 %Output 
   density 
   potential 
 % 

 Example (with OutputFormat): 
 %Output 
   density | cube + axis_z 
   potential | cube 
 % 

 Example (with OutputFormat, incomplete): 
 %Output 
   density | cube + axis_z 
   potential 
 % 

 Example (tagged): 
 %Output 
   density | "output_format" | cube + axis_z | "output_interval" | 50 
   potential | "output_format" | cube | "output_interval" | 20 
 % 

 Example (tagged, incomplete): 
 %Output 
   density | "output_format" | cube + axis_z 
   potential | "output_interval" | 20 
 %  Missing  information  for  the incomplete blocks will be parsed form the
 out-of-block  definitions.  It is also possible to mix the order of columns
 in the tagged format. See OutputFormat, and OutputInterval. 
Option potential 1
 Outputs  Kohn-Sham potential, separated by parts. File names are v0 for the
 local  part  of  the ionic potential, vc for the classical potential (if it
 exists), 
 vh  for  the  Hartree  potential,  vks  for the local part of the Kohn-Sham
 potential, and 
 vxc- for the exchange-correlation potentials. For vks and vxc, a suffix for
 spin is added in the spin-polarized case. 
Option density 2
 Outputs  density.  The  output  file  is called density-, or lr_density- in
 linear response. 
Option wfs 3
 Outputs  wavefunctions.  Which wavefunctions are to be printed is specified
 by the variable OutputWfsNumber -- see below. The output file is called 
 wf-, or lr_wf- in linear response. 
Option wfs_sqmod 4
 Outputs  modulus  squared  of  the wavefunctions. The output file is called
 sqm-wf-. For linear response, the filename is sqm_lr_wf-. 
Option geometry 5
 Outputs file containing the coordinates of the atoms treated within quantum
 mechanics.  If  OutputFormat = xyz, the file is called geometry.xyz; a file
 crystal.xyz is written with a supercell geometry if the system is periodic;
 if  point  charges  were defined in the PDB file (see PDBCoordinates), they
 will  be  output  in  the  file  geometry_classical.xyz.  If OutputFormat =
 xcrysden, a file called geometry.xsf is written. 
Option current 6
 Outputs  the total current density. The output file is called current-. For
 linear response, the filename is lr_current-. 
Option ELF 7
 Outputs  electron  localization  function  (ELF). The output file is called
 elf-,  or lr_elf- in linear response, in which case the associated function
 D is also written, as lr_elf_D-. Only in 2D and 3D. 
Option ELF_basins 8
 Outputs basins of attraction of the ELF. The output file is called 
 elf_rs_basins.info. Only in 2D and 3D. 
Option Bader 9
 Outputs  Laplacian  of  the  density  which shows lone pairs, bonded charge
 concentrations and regions subject to electrophilic or nucleophilic attack.
 See  RF  Bader, _Atoms in Molecules: A Quantum Theory_ (Oxford Univ. Press,
 Oxford, 1990). 
Option el_pressure 10
 Outputs electronic pressure. See Tao, Vignale, and Tokatly, _Phys Rev Lett_
 *100*, 206405 (2008). 
Option matrix_elements 11
 Outputs a series of matrix elements of the Kohn-Sham states. What is output
 can be controlled by the OutputMatrixElements variable. 
Option pol_density 12
 Outputs  dipole-moment  density  dipole_density-, or polarizability density
 alpha_density-  in linear response. If ResponseMethod = finite_differences,
 the hyperpolarizability density 
 beta_density- is also printed. 
Option mesh_r 13
 Outputs  values  of  the  coordinates  over  the grid. Files will be called
 mesh_r- followed by the direction. 
Option kinetic_energy_density 14
 Outputs kinetic-energy density, defined as: 

 \tau_\sigma(\vec{r})  =  \sum_{i=1}^{N_\sigma}  \left|  \vec{\nabla}
 \phi_{i\sigma}(\vec{r}) \right|^2\,.  

 The  index  \sigma is the spin index for the spin-polarized case, or if you
 are  using  spinors.  For  spin-unpolarized calculations, you get the total
 kinetic-energy  density.  The  previous  expression  assumes  full  or null
 occupations.  If  fractional  occupation  numbers,  each term in the sum is
 weighted  by  the  occupation.  Also,  if  we  are working with an infinite
 system, all _k_-points are summed up, with their corresponding weights. The
 files  will  be  called  tau-sp1  and tau-sp2, if the spin-resolved kinetic
 energy  density  is  produced (runs in spin-polarized and spinors mode), or
 only tau if the run is in spin-unpolarized mode. 
Option dos 15
 Outputs density of states. See DOSEnergyMax, DOSEnergyMin, DOSEnergyPoints,
 and DOSGamma. 
Option tpa 16
 Outputs  transition-potential  approximation  (TPA)  matrix elements, using
 \vec{q}-vector specified by MomentumTransfer. 
Option forces 17
 Outputs  file  forces.xsf containing structure and forces on the atoms as a
 vector associated with each atom, which can be visualized with XCrySDen. 
Option wfs_fourier 18
 (Experimental)  Outputs  wavefunctions  in  Fourier  space.  This  is  only
 implemented  for  the  ETSF  file  format  output.  The file will be called
 wfs-pw-etsf.nc. 
Option xc_density 19
 Outputs  the  XC density, which is the charge density that generates the XC
 potential.  (This  is -1/4\pi times the Laplacian of the XC potential). The
 files are called nxc. 
Option PES_wfs 20
 Outputs the photoelectron wavefunctions. The file name is pes_wfs- plus the
 orbital number. 
Option PES_density 21
 Outputs  the  photolectron  density.  Output  file  is  pes_dens- plus spin
 species if spin-polarized calculation is performed. 
Option PES 22
 Outputs the time-dependent photoelectron spectrum. 
Option BerkeleyGW 23
 Output for a run with <a href=http://www.berkeleygw.org>BerkeleyGW</a>. See
 Output::BerkeleyGW for further specification. 
Option delta_perturbation 24
 Outputs  the  "kick", or time-delta perturbation applied to compute optical
 response in real time. 
Option external_td_potential 25
 Outputs the (scalar) time-dependent potential. 
Option mmb_wfs 26
 Triggers the ModelMB wavefunctions to be output for each state. 
Option mmb_den 27
 Triggers  the  ModelMB  density matrix to be output for each state, and the
 particles  specified  by  the DensitytoCalc block. Calculates, and outputs,
 the  reduced  density  matrix.  For  the  moment the trace is made over the
 second  dimension,  and the code is limited to 2D. The idea is to model _N_
 particles in 1D as an 
 _N_-dimensional  non-interacting  problem,  then  to  trace  out  _N_-1
 coordinates. 
Option potential_gradient 28
 Prints the gradient of the potential. 
Option energy_density 29
 Outputs the total energy density to a file called 
 energy_density. 
Option heat_current 30
 Outputs  the  total  heat  current  density.  The  output  file  is  called
 heat_current-. 
Option photon_correlator 31
 Outputs the electron-photon correlation function. The output file is called
 photon_correlator. 
Option J_flow 32
 todo: document J_flow option! 
Option current_kpt 33
 Outputs  the current density resolved in momentum space. The output file is
 called current_kpt-. 
Option density_kpt 34
 Outputs the electronic density resolved in momentum space. 
Option occ_matrices 35
 Only for DFT+U calculations. Outputs the occupation matrices of LDA+U 
Option effectiveU 36
 Only  for  DFT+U calculations. Outputs the value of the effectiveU for each
 atoms 
Option magnetization 37
 Only  for  DFT+U  calculations.  Outputs  file  containing  structure  and
 magnetization of the localized subspace on the atoms as a vector associated
 with each atom, which can be visualized. For the moment, it only works if a
 +U is added on one type of orbital per atom. 
Option local_orbitals 38
 Only  for  DFT+U calculations. Outputs the localized orbitals that form the
 correlated subspace 
Option kanamoriU 39
 Only for DFT+U calculations. Outputs the Kanamori interaction parameters U,
 U`,  and  J. These parameters are not determined self-consistently, but are
 taken  from  the  occupation  matrices and Coulomb integrals comming from a
 standard +U calculation. 
Option xc_torque 40
 Outputs  the  exchange-correlation  torque. Only for the spinor case and in
 the 3D case. 
Option eigenval_kpt 41
 Outputs  the eigenvalues resolved in momentum space, with one file for each
 band. 
END

Variable OutputFormat
Type flag
Default 0
Section Output
Description
 Describes the format of the output files. This variable can also be defined
 inside the Output block. See Output. Example: axis_x + plane_x + dx 
Option axis_x bit(0)
 The values of the function on the _x_ axis are printed. The string .y=0,z=0
 is appended to previous file names. 
Option axis_y bit(1)
 The values of the function on the _y_ axis are printed. The string .x=0,z=0
 is appended to previous file names. 
Option axis_z bit(2)
 The values of the function on the _z_ axis are printed. The string .x=0,y=0
 is appended to previous file names. 
Option plane_x bit(3)
 A  plane  slice  at  _x_  =  0  is  printed. The string .x=0 is appended to
 previous file names. 
Option plane_y bit(4)
 A  plane  slice  at  _y_  =  0  is  printed. The string .y=0 is appended to
 previous file names. 
Option plane_z bit(5)
 A  plane  slice  at  _z_  =  0  is  printed. The string .z=0 is appended to
 previous file names. 
Option dx bit(6)
 For  printing  three-dimensional  information,  the  open-source  program
 visualization  tool  <a  href=http://www.opendx.org>OpenDX</a> can be used.
 The string 
 .dx is appended to previous file names. Available only in 3D. 
Option netcdf bit(7)
 Outputs  in  <a href=http://www.unidata.ucar.edu/packages/netcdf>NetCDF</a>
 format.  This  file  can  then  be read, for example, by OpenDX. The string
 .ncdf is appended to previous file names. Requires the NetCDF library. Only
 writes the real part of complex functions. 
Option mesh_index bit(8)
 Generates  output  files  of a given quantity (density, wavefunctions, ...)
 which  include  the  internal  numbering  of  mesh  points. Since this mode
 produces large datafiles this is only useful for small meshes and debugging
 purposes.  The  output  can  also  be  used to display the mesh directly. A
 Gnuplot  script  for  mesh  visualization  can  be  found  under
 PREFIX/share/octopus/util/display_mesh_index.gp. 
Option xcrysden bit(9)
 A  format  for printing structures and three-dimensional information, which
 can  be  visualized  by  the  free  open-source  program  <a
 href=http://www.xcrysden.org>XCrySDen</a> and others. The string 
 .xsf  is  appended  to  previous  file names. Note that lattice vectors and
 coordinates are as specified by UnitsOutput. Available in 2D and 3D. 
Option matlab bit(10)
 In combination with plane_x, plane_y and 
 plane_z, this option produces output files which are suitable for 2D Matlab
 functions like mesh(), 
 surf(), or waterfall(). To load these files into Matlab you can use, _e.g._
 
<tt>
 >> density = load('static/density-1.x=0.matlab.abs'); >> mesh(density); 
</tt>
Option meshgrid bit(11)
 Outputs in Matlab mode the internal mesh in a format similar to 
<tt>
 >> [x,y] = meshgrid(-2:.2:2,-1:.15:1) 
</tt>
 The  _x_  meshgrid is contained in a file *.meshgrid.x and the _y_-grid can
 be found in 
 *.meshgrid.y. 
Option boundary_points bit(12)
 This  option  includes  the  output  of  the  mesh  enlargement. Default is
 without.  Supported  only  by  binary,  axis, plane, mesh_index, and matlab
 formats.  Not all types of Output will have this information available. Not
 supported when parallel in domains. 
Option binary bit(13)
 Plain binary, new format. 
Option etsf bit(14)
 <a  href=http://www.etsf.eu/resources/software/standardization_project>ETSF
 file  format</a>.  Requires  the  ETSF_IO library. Applies only to Output =
 density, geometry, 
 wfs, and/or wfs_fourier. 
Option xyz bit(15)
 Geometry will be output in XYZ format. Does not affect other outputs. 
Option cube bit(16)
 Generates output in the <a href=http://paulbourke.net/dataformats/cube>cube
 file format</a>. Available only in 3D. Only writes the real part of complex
 functions. This output format always uses atomic units. 
Option bild bit(19)
 Generates  output  in  <a
 href=http://plato.cgl.ucsf.edu/chimera/docs/UsersGuide/bild.html>BILD
 format</a>. 
Option vtk bit(20)
 Generates output in <a href=http://www.vtk.org/VTK/img/file-formats.pdf>VTK
 legacy format</a>. 
Option integrate_xy bit(21)
 Integrates  the function in the x-y plane and the result on the _z_ axis is
 printed. 
Option integrate_xz bit(22)
 Integrates  the function in the x-z plane and the result on the _y_ axis is
 printed 
Option integrate_yz bit(23)
 Integrates  the function in the y-z plane and the result on the _x_ axis is
 printed 
Option ascii bit(24)
 Plain  text  format  regardless  of  dimensionality.  For  the  moment only
 employed by the oct-phototoelectron_spectrum post-processing utility. 
END

Variable OutputInterval
Type integer
Default 50
Section Output
Description
 The  output  requested  by  variable  Output  is  written  to the directory
 OutputIterDir when the iteration number is a multiple of the OutputInterval
 variable. Subdirectories are named Y.X, where Y is td, scf, or unocc, and X
 is  the iteration number. To use the working directory, specify "." (Output
 of restart files is instead controlled by RestartWriteInterval.) Must be >=
 0.  If  it  is 0, then no output is written. For gs and unocc calculations,
 OutputDuringSCF  must  be  set  too  for  this  output to be produced. This
 variable can also be defined inside the Output block. See Output. 
END

Variable DerivativesStencil
Type integer
Default stencil_star
Section Mesh::Derivatives
Description
 Decides  what  kind  of  stencil  is used, _i.e._ which points, around each
 point in the mesh, are the neighboring points used in the expression of the
 differential operator. 

 If  curvilinear  coordinates are to be used, then only the stencil_starplus
 or  the  stencil_cube  may be used. We only recommend the stencil_starplus,
 since the cube typically needs far too much memory. 
Option stencil_star 1
 A star around each point (_i.e._, only points on the axis). 
Option stencil_variational 2
 Same as the star, but with coefficients built in a different way. 
Option stencil_cube 3
 A cube of points around each point. 
Option stencil_starplus 4
 The star, plus a number of off-axis points. 
Option stencil_stargeneral 5
 The general star. Default for non-orthogonal grids. 
END

Variable DerivativesOrder
Type integer
Default 4
Section Mesh::Derivatives
Description
 This  variable  gives the discretization order for the approximation of the
 differential operators. This means, basically, that 
 DerivativesOrder  points  are  used  in  each  positive/negative  spatial
 direction,  _e.g._  DerivativesOrder  =  1  would  give  the  well-known
 three-point  formula  in  1D.  The  number  of points actually used for the
 Laplacian  depends  on  the stencil used. Let O = DerivativesOrder, and d =
 Dimensions. 
  
  *)  stencil_star: 2 O d + 1 
  *)  stencil_cube: (2 O + 1)^d 
  *)  stencil_starplus: 2 O d + 1 + n with _n_ being 8 in 2D and 24 in 3D. 
  
END

Variable ParallelizationOfDerivatives
Type integer
Default non_blocking
Section Execution::Parallelization
Description
 This option selects how the communication of mesh boundaries is performed. 
Option blocking 1
 Blocking communication. 
Option non_blocking 2
 Communication is based on non-blocking point-to-point communication. 
END

Variable AbsorbingBoundaries
Type flag
Default not_absorbing
Section Time-Dependent::Absorbing Boundaries
Description
 To improve the quality of the spectra by avoiding the formation of standing
 density  waves, one can make the boundaries of the simulation box absorbing
 and use exterior complex scaling. 
Option not_absorbing 0
 Reflecting boundaries. 
Option mask 1
 Absorbing boundaries with a mask function. 
Option cap 2
 Absorbing boundaries with a complex absorbing potential. 
Option exterior 3
 Exterior complex scaling (not yet implemented). 
END

Variable ABCapHeight
Type float
Default -0.2 a.u.
Section Time-Dependent::Absorbing Boundaries
Description
 When  AbsorbingBoundaries  =  cap,  this  is  the  height  of the imaginary
 potential. 
END

Variable ABShape
Type block
Section Time-Dependent::Absorbing Boundaries
Description
 Set  the  shape of the absorbing boundaries. Here you can set the inner and
 outer bounds by setting the block as follows: 

 %ABShape 
    inner | outer | "user-defined" 
 % 

 The  optional  3rd  column  is  a user-defined expression for the absorbing
 boundaries.  For  example,  r  creates  a  spherical  absorbing  zone  for
 coordinates  with {\tt inner} < r < {\tt outer}, and z creates an absorbing
 plane.  Note, values outer larger than the box size may lead in these cases
 to  unexpected  reflection  behaviours.  If  no  expression  is  given, the
 absorbing  zone  follows  the  edges of the box (not valid for user-defined
 box). 
END

Variable ABWidth
Type float
Section Time-Dependent::Absorbing Boundaries
Description
 Specifies  the  boundary  width.  For  a  finer  control over the absorbing
 boundary shape use ABShape. 
END

Variable MaximumIterBerry
Type integer
Default 10
Section SCF::Convergence
Description
 Maximum  number  of  iterations  for  the  Berry potential, within each SCF
 iteration.  Only  applies if a StaticElectricField is applied in a periodic
 direction.  The  code  will  move  on  to  the  next  SCF iteration even if
 convergence has not been achieved. -1 means unlimited. 
END

Variable XCFunctional
Type integer
Section Hamiltonian::XC
Description
 Defines the exchange and correlation functionals to be used, specified as a
 sum  of  an  exchange  functional and a correlation functional, or a single
 exchange-correlation  functional  (_e.g._  hyb_gga_xc_pbeh).  For  more
 information on the functionals, see 
 <a  href=https://gitlab.com/libxc/libxc/wikis/Functionals-list-4.0.4> Libxc
 documentation</a>.  The  list  provided  here  is from libxc 4; if you have
 linked against a different libxc version, you may have a somewhat different
 set  of available functionals. Note that kinetic-energy functionals are not
 supported. 

 The  default  functional  will be selected by Octopus to be consistent with
 the  pseudopotentials you are using. If you are not using pseudopotentials,
 Octopus  cannot  determine  the  functional  used  to  generate  the
 pseudopotential,  or  the  pseudopotential  functionals  are  inconsistent,
 Octopus will use the following defaults: 

 1D: lda_x_1d + lda_c_1d_csc 
 2D: lda_x_2d + lda_c_2d_amgb 
 3D: lda_x + lda_c_pz_mod 
Option lda_x               1
 Exchange 
Option lda_c_wigner               2000
 Wigner parametrization 
Option lda_c_rpa               3000
 Random Phase Approximation 
Option lda_c_hl               4000
 Hedin & Lundqvist 
Option lda_c_gl               5000
 Gunnarson & Lundqvist 
Option lda_c_xalpha               6000
 Slater Xalpha 
Option lda_c_vwn               7000
 Vosko, Wilk, & Nusair (5) 
Option lda_c_vwn_rpa               8000
 Vosko, Wilk, & Nusair (RPA) 
Option lda_c_pz               9000
 Perdew & Zunger 
Option lda_c_pz_mod               10000
 Perdew & Zunger (Modified) 
Option lda_c_ob_pz               11000
 Ortiz & Ballone (PZ) 
Option lda_c_pw               12000
 Perdew & Wang 
Option lda_c_pw_mod               13000
 Perdew & Wang (Modified) 
Option lda_c_ob_pw               14000
 Ortiz & Ballone (PW) 
Option lda_c_2d_amgb               15000
 Attaccalite et al 
Option lda_c_2d_prm               16000
 Pittalis, Rasanen & Marques correlation in 2D 
Option lda_c_vbh               17000
 von Barth & Hedin 
Option lda_c_1d_csc               18000
 Casula, Sorella, and Senatore 1D correlation 
Option lda_x_2d               19
 Exchange in 2D 
Option lda_xc_teter93               20000
 Teter 93 parametrization 
Option lda_x_1d               21
 Exchange in 1D 
Option lda_c_ml1               22000
 Modified LSD (version 1) of Proynov and Salahub 
Option lda_c_ml2               23000
 Modified LSD (version 2) of Proynov and Salahub 
Option lda_c_gombas               24000
 Gombas parametrization 
Option lda_c_pw_rpa               25000
 Perdew & Wang fit of the RPA 
Option lda_c_1d_loos               26000
 P-F Loos correlation LDA 
Option lda_c_rc04               27000
 Ragot-Cortona 
Option lda_c_vwn_1               28000
 Vosko, Wilk, & Nusair (1) 
Option lda_c_vwn_2               29000
 Vosko, Wilk, & Nusair (2) 
Option lda_c_vwn_3               30000
 Vosko, Wilk, & Nusair (3) 
Option lda_c_vwn_4               31000
 Vosko, Wilk, & Nusair (4) 
Option lda_xc_zlp               43000
 Zhao, Levy & Parr, Eq. (20) 
Option lda_xc_ksdt               259000
 Karasiev et al. parametrization 
Option lda_c_chachiyo               287000
 Chachiyo simple 2 parameter correlation 
Option lda_c_lp96               289000
 Liu-Parr correlation 
Option lda_x_rel               532
 Relativistic exchange 
Option lda_xc_1d_ehwlrg_1               536000
 LDA constructed from slab-like systems of 1 electron 
Option lda_xc_1d_ehwlrg_2               537000
 LDA constructed from slab-like systems of 2 electrons 
Option lda_xc_1d_ehwlrg_3               538000
 LDA constructed from slab-like systems of 3 electrons 
Option lda_x_erf               546
 Attenuated exchange LDA (erf) 
Option lda_xc_lp_a               547000
 Lee-Parr reparametrization B 
Option lda_xc_lp_b               548000
 Lee-Parr reparametrization B 
Option lda_x_rae               549
 Rae self-energy corrected exchange 
Option lda_c_mcweeny               551000
 McWeeny 76 
Option lda_c_br78               552000
 Brual & Rothstein 78 
Option lda_c_pk09               554000
 Proynov and Kong 2009 
Option lda_c_ow_lyp               573000
 Wigner with corresponding LYP parameters 
Option lda_c_ow               574000
 Optimized Wigner 
Option lda_xc_gdsmfb               577000
 Groth et al. parametrization 
Option lda_c_gk72               578000
 Gordon and Kim 1972 
Option lda_c_karasiev               579000
 Karasiev reparameterization of Chachiyo 
Option gga_x_gam               32
 GAM functional from Minnesota 
Option gga_c_gam               33000
 GAM functional from Minnesota 
Option gga_x_hcth_a               34
 HCTH-A 
Option gga_x_ev93               35
 Engel and Vosko 
Option gga_x_bcgp               38
 Burke, Cancio, Gould, and Pittalis 
Option gga_c_bcgp               39000
 Burke, Cancio, Gould, and Pittalis 
Option gga_x_lambda_oc2_n               40
 lambda_OC2(N) version of PBE 
Option gga_x_b86_r               41
 Revised Becke 86 Xalpha,beta,gamma (with mod. grad. correction) 
Option gga_x_lambda_ch_n               44
 lambda_CH(N) version of PBE 
Option gga_x_lambda_lo_n               45
 lambda_LO(N) version of PBE 
Option gga_x_hjs_b88_v2               46
 HJS screened exchange corrected B88 version 
Option gga_c_q2d               47000
 Chiodo et al 
Option gga_x_q2d               48
 Chiodo et al 
Option gga_x_pbe_mol               49
 Del Campo, Gazquez, Trickey and Vela (PBE-like) 
Option gga_x_ak13               56
 Armiento & Kuemmel 2013 
Option gga_x_lv_rpw86               58
 Berland and Hyldgaard 
Option gga_x_pbe_tca               59
 PBE revised by Tognetti et al 
Option gga_x_pbeint               60
 PBE for hybrid interfaces 
Option gga_c_zpbeint               61000
 spin-dependent gradient correction to PBEint 
Option gga_c_pbeint               62000
 PBE for hybrid interfaces 
Option gga_c_zpbesol               63000
 spin-dependent gradient correction to PBEsol 
Option gga_xc_opbe_d               65000
 oPBE_D functional of Goerigk and Grimme 
Option gga_xc_opwlyp_d               66000
 oPWLYP-D functional of Goerigk and Grimme 
Option gga_xc_oblyp_d               67000
 oBLYP-D functional of Goerigk and Grimme 
Option gga_x_vmt84_ge               68
 VMT{8,4} with constraint satisfaction with mu = mu_GE 
Option gga_x_vmt84_pbe               69
 VMT{8,4} with constraint satisfaction with mu = mu_PBE 
Option gga_x_vmt_ge               70
 Vela, Medel, and Trickey with mu = mu_GE 
Option gga_x_vmt_pbe               71
 Vela, Medel, and Trickey with mu = mu_PBE 
Option gga_c_n12_sx               79000
 N12-SX functional from Minnesota 
Option gga_c_n12               80000
 N12 functional from Minnesota 
Option gga_x_n12               82
 N12 functional from Minnesota 
Option gga_c_regtpss               83000
 Regularized TPSS correlation (ex-VPBE) 
Option gga_c_op_xalpha               84000
 one-parameter progressive functional (XALPHA version) 
Option gga_c_op_g96               85000
 one-parameter progressive functional (G96 version) 
Option gga_c_op_pbe               86000
 one-parameter progressive functional (PBE version) 
Option gga_c_op_b88               87000
 one-parameter progressive functional (B88 version) 
Option gga_c_ft97               88000
 Filatov & Thiel correlation 
Option gga_c_spbe               89000
 PBE correlation to be used with the SSB exchange 
Option gga_x_ssb_sw               90
 Swart, Sola and Bickelhaupt correction to PBE 
Option gga_x_ssb               91
 Swart, Sola and Bickelhaupt 
Option gga_x_ssb_d               92
 Swart, Sola and Bickelhaupt dispersion 
Option gga_xc_hcth_407p               93000
 HCTH/407+ 
Option gga_xc_hcth_p76               94000
 HCTH p=7/6 
Option gga_xc_hcth_p14               95000
 HCTH p=1/4 
Option gga_xc_b97_gga1               96000
 Becke 97 GGA-1 
Option gga_c_hcth_a               97000
 HCTH-A 
Option gga_x_bpccac               98
 BPCCAC (GRAC for the energy) 
Option gga_c_revtca               99000
 Tognetti, Cortona, Adamo (revised) 
Option gga_c_tca               100000
 Tognetti, Cortona, Adamo 
Option gga_x_pbe               101
 Perdew, Burke & Ernzerhof exchange 
Option gga_x_pbe_r               102
 Perdew, Burke & Ernzerhof exchange (revised) 
Option gga_x_b86               103
 Becke 86 Xalpha,beta,gamma 
Option gga_x_herman               104
 Herman et al original GGA 
Option gga_x_b86_mgc               105
 Becke 86 Xalpha,beta,gamma (with mod. grad. correction) 
Option gga_x_b88               106
 Becke 88 
Option gga_x_g96               107
 Gill 96 
Option gga_x_pw86               108
 Perdew & Wang 86 
Option gga_x_pw91               109
 Perdew & Wang 91 
Option gga_x_optx               110
 Handy & Cohen OPTX 01 
Option gga_x_dk87_r1               111
 dePristo & Kress 87 (version R1) 
Option gga_x_dk87_r2               112
 dePristo & Kress 87 (version R2) 
Option gga_x_lg93               113
 Lacks & Gordon 93 
Option gga_x_ft97_a               114
 Filatov & Thiel 97 (version A) 
Option gga_x_ft97_b               115
 Filatov & Thiel 97 (version B) 
Option gga_x_pbe_sol               116
 Perdew, Burke & Ernzerhof exchange (solids) 
Option gga_x_rpbe               117
 Hammer, Hansen & Norskov (PBE-like) 
Option gga_x_wc               118
 Wu & Cohen 
Option gga_x_mpw91               119
 Modified form of PW91 by Adamo & Barone 
Option gga_x_am05               120
 Armiento & Mattsson 05 exchange 
Option gga_x_pbea               121
 Madsen (PBE-like) 
Option gga_x_mpbe               122
 Adamo & Barone modification to PBE 
Option gga_x_xpbe               123
 xPBE reparametrization by Xu & Goddard 
Option gga_x_2d_b86_mgc               124
 Becke 86 MGC for 2D systems 
Option gga_x_bayesian               125
 Bayesian best fit for the enhancement factor 
Option gga_x_pbe_jsjr               126
 JSJR reparametrization by Pedroza, Silva & Capelle 
Option gga_x_2d_b88               127
 Becke 88 in 2D 
Option gga_x_2d_b86               128
 Becke 86 Xalpha,beta,gamma 
Option gga_x_2d_pbe               129
 Perdew, Burke & Ernzerhof exchange in 2D 
Option gga_c_pbe               130000
 Perdew, Burke & Ernzerhof correlation 
Option gga_c_lyp               131000
 Lee, Yang & Parr 
Option gga_c_p86               132000
 Perdew 86 
Option gga_c_pbe_sol               133000
 Perdew, Burke & Ernzerhof correlation SOL 
Option gga_c_pw91               134000
 Perdew & Wang 91 
Option gga_c_am05               135000
 Armiento & Mattsson 05 correlation 
Option gga_c_xpbe               136000
 xPBE reparametrization by Xu & Goddard 
Option gga_c_lm               137000
 Langreth and Mehl correlation 
Option gga_c_pbe_jrgx               138000
 JRGX reparametrization by Pedroza, Silva & Capelle 
Option gga_x_optb88_vdw               139
 Becke 88 reoptimized to be used with vdW functional of Dion et al 
Option gga_x_pbek1_vdw               140
 PBE reparametrization for vdW 
Option gga_x_optpbe_vdw               141
 PBE reparametrization for vdW 
Option gga_x_rge2               142
 Regularized PBE 
Option gga_c_rge2               143000
 Regularized PBE 
Option gga_x_rpw86               144
 refitted Perdew & Wang 86 
Option gga_x_kt1               145
 Exchange part of Keal and Tozer version 1 
Option gga_xc_kt2               146000
 Keal and Tozer version 2 
Option gga_c_wl               147000
 Wilson & Levy 
Option gga_c_wi               148000
 Wilson & Ivanov 
Option gga_x_mb88               149
 Modified Becke 88 for proton transfer 
Option gga_x_sogga               150
 Second-order generalized gradient approximation 
Option gga_x_sogga11               151
 Second-order generalized gradient approximation 2011 
Option gga_c_sogga11               152000
 Second-order generalized gradient approximation 2011 
Option gga_c_wi0               153000
 Wilson & Ivanov initial version 
Option gga_xc_th1               154000
 Tozer and Handy v. 1 
Option gga_xc_th2               155000
 Tozer and Handy v. 2 
Option gga_xc_th3               156000
 Tozer and Handy v. 3 
Option gga_xc_th4               157000
 Tozer and Handy v. 4 
Option gga_x_c09x               158
 C09x to be used with the VdW of Rutgers-Chalmers 
Option gga_c_sogga11_x               159000
 To be used with HYB_GGA_X_SOGGA11_X 
Option gga_x_lb               160
 van Leeuwen & Baerends 
Option gga_xc_hcth_93               161000
 HCTH functional fitted to 93 molecules 
Option gga_xc_hcth_120               162000
 HCTH functional fitted to 120 molecules 
Option gga_xc_hcth_147               163000
 HCTH functional fitted to 147 molecules 
Option gga_xc_hcth_407               164000
 HCTH functional fitted to 407 molecules 
Option gga_xc_edf1               165000
 Empirical functionals from Adamson, Gill, and Pople 
Option gga_xc_xlyp               166000
 XLYP functional 
Option gga_xc_kt1               167000
 Keal and Tozer version 1 
Option gga_xc_b97_d               170000
 Grimme functional to be used with C6 vdW term 
Option gga_xc_pbe1w               173000
 Functionals fitted for water 
Option gga_xc_mpwlyp1w               174000
 Functionals fitted for water 
Option gga_xc_pbelyp1w               175000
 Functionals fitted for water 
Option gga_x_lbm               182
 van Leeuwen & Baerends modified 
Option gga_x_ol2               183
 Exchange form based on Ou-Yang and Levy v.2 
Option gga_x_apbe               184
 mu fixed from the semiclassical neutral atom 
Option gga_c_apbe               186000
 mu fixed from the semiclassical neutral atom 
Option gga_x_htbs               191
 Haas, Tran, Blaha, and Schwarz 
Option gga_x_airy               192
 Constantin et al based on the Airy gas 
Option gga_x_lag               193
 Local Airy Gas 
Option gga_xc_mohlyp               194000
 Functional for organometallic chemistry 
Option gga_xc_mohlyp2               195000
 Functional for barrier heights 
Option gga_xc_th_fl               196000
 Tozer and Handy v. FL 
Option gga_xc_th_fc               197000
 Tozer and Handy v. FC 
Option gga_xc_th_fcfo               198000
 Tozer and Handy v. FCFO 
Option gga_xc_th_fco               199000
 Tozer and Handy v. FCO 
Option gga_c_optc               200000
 Optimized correlation functional of Cohen and Handy 
Option gga_c_pbeloc               246000
 Semilocal dynamical correlation 
Option gga_xc_vv10               255000
 Vydrov and Van Voorhis 
Option gga_c_pbefe               258000
 PBE for formation energies 
Option gga_c_op_pw91               262000
 one-parameter progressive functional (PW91 version) 
Option gga_x_pbefe               265
 PBE for formation energies 
Option gga_x_cap               270
 Correct Asymptotic Potential 
Option gga_x_eb88               271
 Non-empirical (excogitated) B88 functional of Becke and Elliott 
Option gga_c_pbe_mol               272000
 Del Campo, Gazquez, Trickey and Vela (PBE-like) 
Option gga_c_bmk               280000
 Boese-Martin for kinetics 
Option gga_c_tau_hcth               281000
 correlation part of tau-hcth 
Option gga_c_hyb_tau_hcth               283000
 correlation part of hyb_tau-hcth 
Option gga_x_beefvdw               285
 BEEF-vdW exchange 
Option gga_xc_beefvdw               286000
 BEEF-vdW exchange-correlation 
Option gga_x_pbetrans               291
 Gradient-based interpolation between PBE and revPBE 
Option gga_x_chachiyo               298
 Chachiyo exchange 
Option gga_x_wpbeh               524
 short-range version of the PBE 
Option gga_x_hjs_pbe               525
 HJS screened exchange PBE version 
Option gga_x_hjs_pbe_sol               526
 HJS screened exchange PBE_SOL version 
Option gga_x_hjs_b88               527
 HJS screened exchange B88 version 
Option gga_x_hjs_b97x               528
 HJS screened exchange B97x version 
Option gga_x_ityh               529
 short-range recipe for exchange GGA functionals 
Option gga_x_sfat               530
 short-range recipe for exchange GGA functionals 
Option gga_x_sg4               533
 Semiclassical GGA at fourth order 
Option gga_c_sg4               534000
 Semiclassical GGA at fourth order 
Option gga_x_gg99               535
 Gilbert and Gill 1999 
Option gga_x_pbepow               539
 PBE power 
Option gga_x_kgg99               544
 Gilbert and Gill 1999 (mixed) 
Option gga_xc_hle16               545000
 high local exchange 2016 
Option gga_c_scan_e0               553000
 GGA component of SCAN 
Option gga_c_gapc               555000
 GapC 
Option gga_c_gaploc               556000
 Gaploc 
Option gga_c_zvpbeint               557000
 another spin-dependent correction to PBEint 
Option gga_c_zvpbesol               558000
 another spin-dependent correction to PBEsol 
Option gga_c_tm_lyp               559000
 Takkar and McCarthy reparametrization 
Option gga_c_tm_pbe               560000
 Thakkar and McCarthy reparametrization 
Option gga_c_w94               561000
 Wilson 94 (Eq. 25) 
Option gga_c_cs1               565000
 A dynamical correlation functional 
Option gga_x_b88m               570
 Becke 88 reoptimized to be used with mgga_c_tau1 
Option hyb_gga_x_n12_sx               81
 N12-SX functional from Minnesota 
Option hyb_gga_xc_b97_1p               266000
 version of B97 by Cohen and Handy 
Option hyb_gga_xc_pbe_mol0               273000
 PBEmol0 
Option hyb_gga_xc_pbe_sol0               274000
 PBEsol0 
Option hyb_gga_xc_pbeb0               275000
 PBEbeta0 
Option hyb_gga_xc_pbe_molb0               276000
 PBEmolbeta0 
Option hyb_gga_xc_pbe50               290000
 PBE0 with 50% exx 
Option hyb_gga_xc_b3pw91               401000
 The original (ACM) hybrid of Becke 
Option hyb_gga_xc_b3lyp               402000
 The (in)famous B3LYP 
Option hyb_gga_xc_b3p86               403000
 Perdew 86 hybrid similar to B3PW91 
Option hyb_gga_xc_o3lyp               404000
 hybrid using the optx functional 
Option hyb_gga_xc_mpw1k               405000
 mixture of mPW91 and PW91 optimized for kinetics 
Option hyb_gga_xc_pbeh               406000
 aka PBE0 or PBE1PBE 
Option hyb_gga_xc_b97               407000
 Becke 97 
Option hyb_gga_xc_b97_1               408000
 Becke 97-1 
Option hyb_gga_xc_b97_2               410000
 Becke 97-2 
Option hyb_gga_xc_x3lyp               411000
 hybrid by Xu and Goddard 
Option hyb_gga_xc_b1wc               412000
 Becke 1-parameter mixture of WC and PBE 
Option hyb_gga_xc_b97_k               413000
 Boese-Martin for Kinetics 
Option hyb_gga_xc_b97_3               414000
 Becke 97-3 
Option hyb_gga_xc_mpw3pw               415000
 mixture with the mPW functional 
Option hyb_gga_xc_b1lyp               416000
 Becke 1-parameter mixture of B88 and LYP 
Option hyb_gga_xc_b1pw91               417000
 Becke 1-parameter mixture of B88 and PW91 
Option hyb_gga_xc_mpw1pw               418000
 Becke 1-parameter mixture of mPW91 and PW91 
Option hyb_gga_xc_mpw3lyp               419000
 mixture of mPW and LYP 
Option hyb_gga_xc_sb98_1a               420000
 Schmider-Becke 98 parameterization 1a 
Option hyb_gga_xc_sb98_1b               421000
 Schmider-Becke 98 parameterization 1b 
Option hyb_gga_xc_sb98_1c               422000
 Schmider-Becke 98 parameterization 1c 
Option hyb_gga_xc_sb98_2a               423000
 Schmider-Becke 98 parameterization 2a 
Option hyb_gga_xc_sb98_2b               424000
 Schmider-Becke 98 parameterization 2b 
Option hyb_gga_xc_sb98_2c               425000
 Schmider-Becke 98 parameterization 2c 
Option hyb_gga_x_sogga11_x               426
 Hybrid based on SOGGA11 form 
Option hyb_gga_xc_hse03               427000
 the 2003 version of the screened hybrid HSE 
Option hyb_gga_xc_hse06               428000
 the 2006 version of the screened hybrid HSE 
Option hyb_gga_xc_hjs_pbe               429000
 HJS hybrid screened exchange PBE version 
Option hyb_gga_xc_hjs_pbe_sol               430000
 HJS hybrid screened exchange PBE_SOL version 
Option hyb_gga_xc_hjs_b88               431000
 HJS hybrid screened exchange B88 version 
Option hyb_gga_xc_hjs_b97x               432000
 HJS hybrid screened exchange B97x version 
Option hyb_gga_xc_cam_b3lyp               433000
 CAM version of B3LYP 
Option hyb_gga_xc_tuned_cam_b3lyp               434000
 CAM version of B3LYP tuned for excitations 
Option hyb_gga_xc_bhandh               435000
 Becke half-and-half 
Option hyb_gga_xc_bhandhlyp               436000
 Becke half-and-half with B88 exchange 
Option hyb_gga_xc_mb3lyp_rc04               437000
 B3LYP with RC04 LDA 
Option hyb_gga_xc_mpwlyp1m               453000
 MPW with 1 par. for metals/LYP 
Option hyb_gga_xc_revb3lyp               454000
 Revised B3LYP 
Option hyb_gga_xc_camy_blyp               455000
 BLYP with yukawa screening 
Option hyb_gga_xc_pbe0_13               456000
 PBE0-1/3 
Option hyb_gga_xc_b3lyps               459000
 B3LYP* functional 
Option hyb_gga_xc_wb97               463000
 Chai and Head-Gordon 
Option hyb_gga_xc_wb97x               464000
 Chai and Head-Gordon 
Option hyb_gga_xc_lrc_wpbeh               465000
 Long-range corrected functional by Rorhdanz et al 
Option hyb_gga_xc_wb97x_v               466000
 Mardirossian and Head-Gordon 
Option hyb_gga_xc_lcy_pbe               467000
 PBE with yukawa screening 
Option hyb_gga_xc_lcy_blyp               468000
 BLYP with yukawa screening 
Option hyb_gga_xc_lc_vv10               469000
 Vydrov and Van Voorhis 
Option hyb_gga_xc_camy_b3lyp               470000
 B3LYP with Yukawa screening 
Option hyb_gga_xc_wb97x_d               471000
 Chai and Head-Gordon 
Option hyb_gga_xc_hpbeint               472000
 hPBEint 
Option hyb_gga_xc_lrc_wpbe               473000
 Long-range corrected functional by Rorhdanz et al 
Option hyb_gga_xc_b3lyp5               475000
 B3LYP with VWN functional 5 instead of RPA 
Option hyb_gga_xc_edf2               476000
 Empirical functional from Lin, George and Gill 
Option hyb_gga_xc_cap0               477000
 Correct Asymptotic Potential hybrid 
Option hyb_gga_xc_lc_wpbe               478000
 Long-range corrected functional by Vydrov and Scuseria 
Option hyb_gga_xc_hse12               479000
 HSE12 by Moussa, Schultz and Chelikowsky 
Option hyb_gga_xc_hse12s               480000
 Short-range HSE12 by Moussa, Schultz, and Chelikowsky 
Option hyb_gga_xc_hse_sol               481000
 HSEsol functional by Schimka, Harl, and Kresse 
Option hyb_gga_xc_cam_qtp_01               482000
 CAM-QTP(01): CAM-B3LYP retuned using ionization potentials of water 
Option hyb_gga_xc_mpw1lyp               483000
 Becke 1-parameter mixture of mPW91 and LYP 
Option hyb_gga_xc_mpw1pbe               484000
 Becke 1-parameter mixture of mPW91 and PBE 
Option hyb_gga_xc_kmlyp               485000
 Kang-Musgrave hybrid 
Option hyb_gga_xc_b5050lyp               572000
 Like B3LYP but more exact exchange 
Option mgga_c_dldf               37000
 Dispersionless Density Functional 
Option mgga_xc_zlp               42000
 Zhao, Levy & Parr, Eq. (21) 
Option mgga_xc_otpss_d               64000
 oTPSS_D functional of Goerigk and Grimme 
Option mgga_c_cs               72000
 Colle and Salvetti 
Option mgga_c_mn12_sx               73000
 MN12-SX correlation functional from Minnesota 
Option mgga_c_mn12_l               74000
 MN12-L correlation functional from Minnesota 
Option mgga_c_m11_l               75000
 M11-L correlation functional from Minnesota 
Option mgga_c_m11               76000
 M11 correlation functional from Minnesota 
Option mgga_c_m08_so               77000
 M08-SO correlation functional from Minnesota 
Option mgga_c_m08_hx               78000
 M08-HX correlation functional from Minnesota 
Option mgga_x_lta               201
 Local tau approximation of Ernzerhof & Scuseria 
Option mgga_x_tpss               202
 Tao, Perdew, Staroverov & Scuseria exchange 
Option mgga_x_m06_l               203
 M06-L exchange functional from Minnesota 
Option mgga_x_gvt4               204
 GVT4 from Van Voorhis and Scuseria 
Option mgga_x_tau_hcth               205
 tau-HCTH from Boese and Handy 
Option mgga_x_br89               206
 Becke-Roussel 89 
Option mgga_x_bj06               207
 Becke & Johnson correction to Becke-Roussel 89 
Option mgga_x_tb09               208
 Tran & Blaha correction to Becke & Johnson 
Option mgga_x_rpp09               209
 Rasanen, Pittalis, and Proetto correction to Becke & Johnson 
Option mgga_x_2d_prhg07               210
 Pittalis, Rasanen, Helbig, Gross Exchange Functional 
Option mgga_x_2d_prhg07_prp10               211
 PRGH07 with PRP10 correction 
Option mgga_x_revtpss               212
 revised Tao, Perdew, Staroverov & Scuseria exchange 
Option mgga_x_pkzb               213
 Perdew, Kurth, Zupan, and Blaha 
Option mgga_x_ms0               221
 MS exchange of Sun, Xiao, and Ruzsinszky 
Option mgga_x_ms1               222
 MS1 exchange of Sun, et al 
Option mgga_x_ms2               223
 MS2 exchange of Sun, et al 
Option mgga_x_m11_l               226
 M11-L exchange functional from Minnesota 
Option mgga_x_mn12_l               227
 MN12-L exchange functional from Minnesota 
Option mgga_xc_cc06               229000
 Cancio and Chou 2006 
Option mgga_x_mk00               230
 Exchange for accurate virtual orbital energies 
Option mgga_c_tpss               231000
 Tao, Perdew, Staroverov & Scuseria correlation 
Option mgga_c_vsxc               232000
 VSxc from Van Voorhis and Scuseria (correlation part) 
Option mgga_c_m06_l               233000
 M06-L correlation functional from Minnesota 
Option mgga_c_m06_hf               234000
 M06-HF correlation functional from Minnesota 
Option mgga_c_m06               235000
 M06 correlation functional from Minnesota 
Option mgga_c_m06_2x               236000
 M06-2X correlation functional from Minnesota 
Option mgga_c_m05               237000
 M05 correlation functional from Minnesota 
Option mgga_c_m05_2x               238000
 M05-2X correlation functional from Minnesota 
Option mgga_c_pkzb               239000
 Perdew, Kurth, Zupan, and Blaha 
Option mgga_c_bc95               240000
 Becke correlation 95 
Option mgga_c_revtpss               241000
 revised TPSS correlation 
Option mgga_xc_tpsslyp1w               242000
 Functionals fitted for water 
Option mgga_x_mk00b               243
 Exchange for accurate virtual orbital energies (v. B) 
Option mgga_x_bloc               244
 functional with balanced localization 
Option mgga_x_modtpss               245
 Modified Tao, Perdew, Staroverov & Scuseria exchange 
Option mgga_c_tpssloc               247000
 Semilocal dynamical correlation 
Option mgga_x_mbeef               249
 mBEEF exchange 
Option mgga_x_mbeefvdw               250
 mBEEF-vdW exchange 
Option mgga_xc_b97m_v               254000
 Mardirossian and Head-Gordon 
Option mgga_x_mvs               257
 MVS exchange of Sun, Perdew, and Ruzsinszky 
Option mgga_x_mn15_l               260
 MN15-L exhange functional from Minnesota 
Option mgga_c_mn15_l               261000
 MN15-L correlation functional from Minnesota 
Option mgga_x_scan               263
 SCAN exchange of Sun, Ruzsinszky, and Perdew 
Option mgga_c_scan               267000
 SCAN correlation 
Option mgga_c_mn15               269000
 MN15 correlation functional from Minnesota 
Option mgga_x_b00               284
 Becke 2000 
Option mgga_xc_hle17               288000
 high local exchange 2017 
Option mgga_c_scan_rvv10               292000
 SCAN correlation + rVV10 correlation 
Option mgga_x_revm06_l               293
 revised M06-L exchange functional from Minnesota 
Option mgga_c_revm06_l               294000
 Revised M06-L correlation functional from Minnesota 
Option mgga_x_tm               540
 Tao and Mo 2016 
Option mgga_x_vt84               541
 meta-GGA version of VT{8,4} GGA 
Option mgga_x_sa_tpss               542
 TPSS with correct surface asymptotics 
Option mgga_c_kcis               562000
 Krieger, Chen, Iafrate, and Savin 
Option mgga_xc_lp90               564000
 Lee & Parr, Eq. (56) 
Option mgga_c_b88               571000
 Meta-GGA correlation by Becke 
Option mgga_x_gx               575
 GX functional of Loos 
Option mgga_x_pbe_gx               576
 PBE-GX functional of Loos 
Option mgga_x_revscan               581
 revised SCAN 
Option mgga_c_revscan               582000
 revised SCAN correlation 
Option mgga_c_scan_vv10               584000
 SCAN correlation + VV10 correlation 
Option mgga_c_revscan_vv10               585000
 revised SCAN correlation 
Option mgga_x_br89_explicit               586
 Becke-Roussel 89 with an explicit inversion of x(y) 
Option hyb_mgga_x_dldf               36
 Dispersionless Density Functional 
Option hyb_mgga_x_ms2h               224
 MS2 hybrid exchange of Sun, et al 
Option hyb_mgga_x_mn12_sx               248
 MN12-SX hybrid exchange functional from Minnesota 
Option hyb_mgga_x_scan0               264
 SCAN hybrid exchange 
Option hyb_mgga_x_mn15               268
 MN15 hybrid exchange functional from Minnesota 
Option hyb_mgga_x_bmk               279
 Boese-Martin for kinetics 
Option hyb_mgga_x_tau_hcth               282
 Hybrid version of tau-HCTH 
Option hyb_mgga_x_m08_hx               295
 M08-HX exchange functional from Minnesota 
Option hyb_mgga_x_m08_so               296
 M08-SO exchange functional from Minnesota 
Option hyb_mgga_x_m11               297
 M11 hybrid exchange functional from Minnesota 
Option hyb_mgga_x_m05               438
 M05 hybrid exchange functional from Minnesota 
Option hyb_mgga_x_m05_2x               439
 M05-2X hybrid exchange functional from Minnesota 
Option hyb_mgga_xc_b88b95               440000
 Mixture of B88 with BC95 (B1B95) 
Option hyb_mgga_xc_b86b95               441000
 Mixture of B86 with BC95 
Option hyb_mgga_xc_pw86b95               442000
 Mixture of PW86 with BC95 
Option hyb_mgga_xc_bb1k               443000
 Mixture of B88 with BC95 from Zhao and Truhlar 
Option hyb_mgga_x_m06_hf               444
 M06-HF hybrid exchange functional from Minnesota 
Option hyb_mgga_xc_mpw1b95               445000
 Mixture of mPW91 with BC95 from Zhao and Truhlar 
Option hyb_mgga_xc_mpwb1k               446000
 Mixture of mPW91 with BC95 for kinetics 
Option hyb_mgga_xc_x1b95               447000
 Mixture of X with BC95 
Option hyb_mgga_xc_xb1k               448000
 Mixture of X with BC95 for kinetics 
Option hyb_mgga_x_m06               449
 M06 hybrid exchange functional from Minnesota 
Option hyb_mgga_x_m06_2x               450
 M06-2X hybrid exchange functional from Minnesota 
Option hyb_mgga_xc_pw6b95               451000
 Mixture of PW91 with BC95 from Zhao and Truhlar 
Option hyb_mgga_xc_pwb6k               452000
 Mixture of PW91 with BC95 from Zhao and Truhlar for kinetics 
Option hyb_mgga_xc_tpssh               457000
 TPSS hybrid 
Option hyb_mgga_xc_revtpssh               458000
 revTPSS hybrid 
Option hyb_mgga_x_mvsh               474
 MVSh hybrid 
Option hyb_mgga_xc_wb97m_v               531000
 Mardirossian and Head-Gordon 
Option hyb_mgga_xc_b0kcis               563000
 Hybrid based on KCIS 
Option hyb_mgga_xc_mpw1kcis               566000
 Modified Perdew-Wang + KCIS hybrid 
Option hyb_mgga_xc_mpwkcis1k               567000
 Modified Perdew-Wang + KCIS hybrid with more exact exchange 
Option hyb_mgga_xc_pbe1kcis               568000
 Perdew-Burke-Ernzerhof + KCIS hybrid 
Option hyb_mgga_xc_tpss1kcis               569000
 TPSS hybrid with KCIS correlation 
Option hyb_mgga_x_revscan0               583
 revised SCAN hybrid exchange 
Option hyb_mgga_xc_b98               598000
 Becke 98 
Option oep_x                    901
 OEP: Exact exchange (not from libxc). 
Option slater_x                 902
 Slater approximation to the exact exchange (not from libxc). 
Option fbe_x                    903
 Exchange functional based on the force balance equation (not from libxc). 
Option ks_inversion             801
 Inversion of KS potential (not from libxc). 
Option lda_xc_cmplx             701
 Complex-scaled LDA exchange and correlation (not from libxc). 
Option pbe_xc_cmplx             702
 Complex-scaled PBE exchange and correlation (not from libxc). 
Option lb94_xc_cmplx            703
 Complex-scaled LB94 exchange and correlation (not from libxc). 
Option rdmft_xc_m               601
 RDMFT Mueller functional (not from libxc). 
Option xc_half_hartree          917
 Half-Hartree  exchange  for  two  electrons (supports complex scaling) (not
 from libxc). Defined by v_{xc}(r) = v_H(r) / 2. 
Option hyb_gga_xc_mvorb_hse06   921000
 Density-based mixing parameter of HSE06 (not from libxc). 
Option hyb_gga_xc_mvorb_pbeh    922000
 Density-based mixing parameter of PBEH (not from libxc). At the moment this
 is not supported for libxc >= 4.0. 
Option vdw_c_vdwdf      918000
 van der Waals density functional vdW-DF correlation from libvdwxc (not from
 libxc). Use with gga_x_pbe_r. 
Option vdw_c_vdwdf2     919000
 van  der  Waals  density  functional vdW-DF2 correlation from libvdwxc (not
 from libxc). Use with gga_x_rpw86. 
Option vdw_c_vdwdfcx    920000
 van  der  Waals density functional vdW-DF-cx correlation from libvdwxc (not
 from libxc). Use with gga_x_lv_rpw86. 
Option none                       0
 Exchange and correlation set to zero (not from libxc). 
END

Variable LRMaximumIter
Type integer
Default 200
Section Linear Response::SCF in LR calculations
Description
 The maximum number of SCF iterations to calculate response. 
END

Variable LRConvAbsDens
Type float
Default 1e-5
Section Linear Response::SCF in LR calculations
Description
 The  tolerance  in  the  absolute  variation  of  the  density response, to
 determine if the SCF for linear response is converged. 
 \varepsilon  =  \int {\rm d}^3r \left| \rho^{out}(\bf r) -\rho^{inp}(\bf r)
 \right|. A zero value means do not use this criterion. 
END

Variable LRConvRelDens
Type float
Default 0.0
Section Linear Response::SCF in LR calculations
Description
 The  tolerance  in  the  relative  variation  of  the  density response, to
 determine if the SCF for linear response is converged. 
 \varepsilon  =  \frac{1}{N_{\rm elec}} LRConvAbsDens. A zero value means do
 not use this criterion. 
END

Variable LRTolScheme
Type integer
Default tol_adaptive
Section Linear Response::SCF in LR calculations
Description
 The  scheme  used  to  adjust  the  tolerance  of the solver during the SCF
 iteration.  For  kdotp  and  magnetic  em_resp  modes,  or  whenever
 HamiltonianVariation = V_ext_only, the scheme is set to tol_fixed, and this
 variable is ignored. 
Option tol_fixed 0
 The  solver  tolerance  is  fixed  for  all  the  iterations; this improves
 convergence but increases the computational cost 
Option tol_adaptive 1
 The  tolerance  is  increased  according to the level of convergence of the
 SCF. 
Option tol_linear 2
 The tolerance decreases linearly for the first LRTolIterWindow iterations. 
Option tol_exp 3
 The  tolerance  decreases  exponentially  for  the  first  LRTolIterWindow
 iterations. 
END

Variable LRTolInitTol
Type float
Default 1e-2
Section Linear Response::Solver
Description
 This  is  the  tolerance to determine that the linear solver has converged,
 for the first SCF iteration. Ignored if LRTolScheme = fixed. 
END

Variable LRTolFinalTol
Type float
Default 1e-6
Section Linear Response::Solver
Description
 This is the tolerance to determine that the linear solver has converged. 
END

Variable LRTolAdaptiveFactor
Type float
Default 0.1
Section Linear Response::SCF in LR calculations
Description
 This  factor  controls  how  much  the  tolerance  is  decreased during the
 self-consistency  process.  Smaller values mean that tolerance is decreased
 faster. 
END

Variable LRTolIterWindow
Type float
Default 10
Section Linear Response::SCF in LR calculations
Description
 Number of iterations necessary to reach the final tolerance. 
END

Variable HFSingularity
Type integer
Default general
Section Hamiltonian::XC
Description
 (Experimental)  This  variable selects the method used for the treatment of
 the  singularity  of  the  Coulomb  potential  in  Hatree-Fock  and
 hybrid-functional  DFT  calculations.  This  shoulbe  be  only  applied for
 periodic systems and is only used for FFT kernels of the Poisson solvers. 
Option none 0
 The singularity is replaced by zero. 
Option general 1
 The  general  treatment  of the singularity, as described in Carrier et al,
 PRB 75 205126 (2007). This is the default option 
Option fcc 2
 The  treatment  of the singulariy as described in Gygi and Baldereschi, PRB
 34, 4405 (1986). This is formally valid for cubic systems only. 
Option spherical_bz 3
 The  divergence  in  q=0  is  treated  analytically  assuming  a  spherical
 Brillouin zone 
END

Variable HFSingularityNk
Type integer
Default 60 in 3D, 1200 in 1D
Section Hamiltonian::XC
Description
 Number  of  k-point  used  (total number of k-points) is (2*Nk+1)^3) in the
 numerical  integration  of  the auxiliary function f(q). See PRB 75, 205126
 (2007) for more details. Only for HFSingularity=general. Also used in 1D. 
END

Variable HFSingularityNsteps
Type integer
Default 7 in 3D, 15 in 1D
Section Hamiltonian::XC
Description
 Number  of  grid  refinement  steps  in  the  numerical  integration of the
 auxiliary  function  f(q). See PRB 75, 205126 (2007) for more details. Only
 for HFSingularity=general. Also used in 1D. 
END

Variable VDW_TS_cutoff
Type float
Default 10.0
Section Hamiltonian::XC
Description
 Set  the  value  of  the  cutoff (unit of length) for the VDW correction in
 periodic system in the Tkatchenko and Scheffler (vdw_ts) scheme only. 
END

Variable VDW_TS_damping
Type float
Default 20.0
Section Hamiltonian::XC
Description
 Set  the  value of the damping function (in unit of 1/length) steepness for
 the VDW correction in the Tkatchenko-Scheffler scheme. See Equation (12) of
 Phys. Rev. Lett. 102 073005 (2009). 
END

Variable VDW_TS_sr
Type float
Default 0.94
Section Hamiltonian::XC
Description
 Set  the  value  of  the  sr  parameter  in the damping function of the VDW
 correction  in  the Tkatchenko-Scheffler scheme. See Equation (12) of Phys.
 Rev.  Lett.  102 073005 (2009). This parameter depends on the xc functional
 used.  The default value is 0.94, which holds for PBE. For PBE0, a value of
 0.96 should be used. 
END

Variable DFTUBasisFromStates
Type logical
Default no
Section Hamiltonian::DFT+U
Description
 If set to yes, Octopus will construct the localized basis from user-defined
 states.  The  states  are taken at the Gamma point (or the first k-point of
 the states in the restart_proj folder. The states are defined via the block
 DFTUBasisStates 
END

Variable DFTUDoubleCounting
Type integer
Default dft_u_fll
Section Hamiltonian::DFT+U
Description
 This variable selects which DFT+U double counting term is used. 
Option dft_u_fll 0
 (Default) The Fully Localized Limit (FLL) 
Option dft_u_amf 1
 (Experimental) Around mean field double counting, as defined in PRB 44, 943
 (1991) and PRB 49, 14211 (1994). 
END

Variable DFTUPoissonSolver
Type integer
Section Hamiltonian::DFT+U
Description
 This  variable  selects which Poisson solver is used to compute the Coulomb
 integrals  over  a submesh. These are non-periodic Poisson solvers. The FFT
 Poisson solver with spherical cutoff is used by default. 

Option dft_u_poisson_direct 0
 Direct Poisson solver. Slow but working in all cases. 
Option dft_u_poisson_isf 1
 (Experimental)  ISF  Poisson  solver  on  a submesh. This does not work for
 non-orthogonal cells nor domain parallelization. 
Option dft_u_poisson_psolver 2
 (Experimental)  PSolver Poisson solver on a submesh. This does not work for
 non-orthogonal  cells  nor  domain  parallelization.  Requires  the PSolver
 external library. 
Option dft_u_poisson_fft 3
 (Default)  FFT  Poisson  solver  on  a  submesh.  This uses the 0D periodic
 version of the FFT kernels. 
END

Variable UseAllAtomicOrbitals
Type logical
Default no
Section Hamiltonian::DFT+U
Description
 If  set  to  yes,  Octopus  will  determine  the effective U for all atomic
 orbitals  from the peusopotential. Only available with ACBN0 functional. It
 is strongly recommended to set AOLoewdin=yes when using the option. 
END

Variable SkipSOrbitals
Type logical
Default no
Section Hamiltonian::DFT+U
Description
 If  set  to  yes,  Octopus  will  determine  the effective U for all atomic
 orbitals  from the peusopotential but s orbitals. Only available with ACBN0
 functional. 
END

Variable ACBN0Screening
Type float
Default 1.0
Section Hamiltonian::DFT+U
Description
 If set to 0, no screening will be included in the ACBN0 functional, and the
 U will be estimated from bare Hartree-Fock. If set to 1 (default), the full
 screening of the U, as defined in the ACBN0 functional, is used. 
END

Variable ACBN0RotationallyInvariant
Type logical
Section Hamiltonian::DFT+U
Description
 If set to yes, Octopus will use for U and J a formula which is rotationally
 invariant. This is different from the original formula for U and J. This is
 activated  by  default,  except  in the case of spinors, as this is not yet
 implemented in this case. 
END

Variable ACBN0IntersiteInteraction
Type logical
Default no
Section Hamiltonian::DFT+U
Description
 If set to yes, Octopus will determine the effective intersite interaction V
 Only  available  with  ACBN0  functional. It is strongly recommended to set
 AOLoewdin=yes when using the option. 
END

Variable ACBN0IntersiteCutoff
Type float
Section Hamiltonian::DFT+U
Description
 The  cutoff radius defining the maximal intersite distance considered. Only
 available with ACBN0 functional with intersite interaction. 
END

Variable DFTUBasisStates
Type block
Default none
Section Hamiltonian::DFT+U
Description
 Each  line  of  this  block  contains  the  index  of a state to be used to
 construct the localized basis. See DFTUBasisFromStates for details. 
END

Variable PCMCalculation
Type logical
Default no
Section Hamiltonian::PCM
Description
 If  true,  the calculation is performed accounting for solvation effects by
 using  the  Integral Equation Formalism Polarizable Continuum Model IEF-PCM
 formulated  in  real-space  and  real-time  (_J. Chem. Phys._ *143*, 144111
 (2015), 
 _Chem. Rev._ *105*, 2999 (2005), _J. Chem. Phys._ *139*, 024105 (2013)). At
 the  moment,  this  option  is available only for TheoryLevel = DFT. PCM is
 tested  for CalculationMode = gs, while still experimental for other values
 (in particular, CalculationMode = td). 
END

Variable PCMVdWRadii
Type integer
Default pcm_vdw_optimized
Section Hamiltonian::PCM
Description
 This  variable  selects which van der Waals radius will be used to generate
 the solvent cavity. 
Option pcm_vdw_optimized  1
 Use the van der Waals radius optimized by Stefan Grimme in J. Comput. Chem.
 27: 1787-1799, 2006, except for C, N and O, reported in J. Chem. Phys. 120,
 3893 (2004). 
Option pcm_vdw_species  2
 The  vdW radii are set from the share/pseudopotentials/elements file. These
 values  are  obtained  from Alvarez S., Dalton Trans., 2013, 42, 8617-8636.
 Values can be changed in the Species block. 
END

Variable PCMRadiusScaling
Type float
Section Hamiltonian::PCM
Description
 Scales  the  radii  of the spheres used to build the solute cavity surface.
 The  default  value  depends  on  the  choice  of  PCMVdWRadii:  1.2  for
 pcm_vdw_optimized and 1.0 for pcm_vdw_species. 
END

Variable PCMTDLevel
Type integer
Default eq
Section Hamiltonian::PCM
Description
 When  CalculationMode=td,  PCMTDLevel  it sets the way the time-depenendent
 solvent polarization is propagated. 
Option eq 0
 If  PCMTDLevel=eq,  the solvent is always in equilibrium with the solute or
 the  external field, i.e., the solvent polarization follows instantaneously
 the  changes in solute density or in the external field. PCMTDLevel=neq and
 PCMTDLevel=eom are both nonequilibrium runs. 
Option neq 1
 If  PCMTDLevel=neq, solvent polarization charges are splitted in two terms:
 one  that  follows  instantaneously the changes in the solute density or in
 the  external  field (dynamical polarization charges), and another that lag
 behind  in  the  evolution  w.r.t. the solute density or the external field
 (inertial polarization charges). 
Option eom 2
 If  PCMTDLevel=eom,  solvent  polarization  charges  evolves  following  an
 equation  of motion, generalizing 'neq' propagation. The equation of motion
 used here depends on the value of PCMEpsilonModel. 
END

Variable PCMStaticEpsilon
Type float
Default 1.0
Section Hamiltonian::PCM
Description
 Static  dielectric  constant  of the solvent (\varepsilon_0). 1.0 indicates
 gas phase. 
END

Variable PCMDynamicEpsilon
Type float
Default PCMStaticEpsilon
Section Hamiltonian::PCM
Description
 High-frequency dielectric constant of the solvent (\varepsilon_d). 
 \varepsilon_d=\varepsilon_0 indicate equilibrium with solvent. 
END

Variable PCMEpsilonModel
Type integer
Default pcm_debye
Section Hamiltonian::PCM
Description
 Define the dielectric function model. 
Option pcm_debye 1
 Debye  model:
 \varepsilon(\omega)=\varepsilon_d+\frac{\varepsilon_0-\varepsilon_d}{1-i\omega\tau}
 
Option pcm_drude 2
 Drude-Lorentz  model:
 \varepsilon(\omega)=1+\frac{A}{\omega_0^2-\omega^2+i\gamma\omega} 
END

Variable PCMEoMInitialCharges
Type integer
Default 0
Section Hamiltonian::PCM
Description
 If  =0  the  propagation  of  the  solvent polarization charges starts from
 internally  generated  initial  charges  in  equilibrium  with  the initial
 potential.  For  Debye  EOM-PCM,  if  >0  the  propagation  of  the solvent
 polarization  charges  starts  from initial charges from input file. if =1,
 initial pol. charges due to solute electrons are read from input file. else
 if  =2,  initial pol. charges due to external potential are read from input
 file. else if =3, initial pol. charges due to solute electrons and external
 potential  are  read  from  input  file.  Files  should  be  located in pcm
 directory  and  are  called  ASC_e.dat  and  ASC_ext.dat, respectively. The
 latter files are generated after any PCM run and contain the last values of
 the polarization charges. 
END

Variable PCMDebyeRelaxTime
Type float
Default 0.0
Section Hamiltonian::PCM
Description
 Relaxation  time  of  the  solvent  within Debye model (\tau). Recall Debye
 dieletric function: 
 \varepsilon(\omega)=\varepsilon_d+\frac{\varepsilon_0-\varepsilon_d}{1-i\omega\tau}
 
END

Variable PCMDrudeLOmega
Type float
Default <math>\sqrt{1/(\varepsilon_0-1)}</math>
Section Hamiltonian::PCM
Description
 Resonance  frequency  of the solvent within Drude-Lorentz model (\omega_0).
 Recall  Drude-Lorentz  dielectric  function:
 \varepsilon(\omega)=1+\frac{A}{\omega_0^2-\omega^2+i\gamma\omega}  Default
 values of \omega_0 guarantee to recover static dielectric constant. 
END

Variable PCMDrudeLDamping
Type float
Default 0.0
Section Hamiltonian::PCM
Description
 Damping  factor  of  the  solvent charges oscillations within Drude-Lorentz
 model  (\gamma).  Recall  Drude-Lorentz  dielectric  function:
 \varepsilon(\omega)=1+\frac{A}{\omega_0^2-\omega^2+i\gamma\omega} 
END

Variable PCMLocalField
Type logical
Default no
Section Hamiltonian::PCM
Description
 This  variable is a flag for including local field effects when an external
 field is applied. The total field interacting with the molecule (also known
 as  cavity  field)  is  not  the  bare  field in the solvent (the so-called
 Maxwell  field), but it also include a contribution due to the polarization
 of the solvent. The latter is calculated here within the PCM framework. See
 [G. Gil, et al., J. Chem. Theory Comput., 2019, 15 (4), pp 2306–2319]. 
END

Variable PCMSolute
Type logical
Default yes
Section Hamiltonian::PCM
Description
 This  variable  is a flag for including polarization effects of the solvent
 due  to the solute. (Useful for analysis) When external fields are applied,
 turning  off the solvent-molecule interaction (PCMSolute=no) and activating
 the  solvent  polarization  due  to  the  applied field (PCMLocalField=yes)
 allows to include only local field effects. 
END

Variable PCMKick
Type logical
Default no
Section Hamiltonian::PCM
Description
 This  variable  controls the effect the kick has on the polarization of the
 solvent.  If  .true. ONLY the FAST degrees-of-freedom of the solvent follow
 the  kick.  The  potential  due  to polarization charges behaves as another
 kick,  i.e.,  it is a delta-perturbation. If .false. ALL degrees-of-freedom
 of  the  solvent follow the kick. The potential due to polarization charges
 evolves  following  an  equation  of motion. When Debye dielectric model is
 used, just a part of the potential behaves as another kick. 
END

Variable PCMUpdateIter
Type integer
Default 1
Section Hamiltonian::PCM
Description
 Defines how often the PCM potential is updated during time propagation. 
END

Variable PCMGamessBenchmark
Type logical
Default .false.
Section Hamiltonian::PCM
Description
 If  PCMGamessBenchmark is set to "yes", the pcm_matrix is also written in a
 Gamess format. for benchamarking purposes. 
END

Variable PCMRenormCharges
Type logical
Default .false.
Section Hamiltonian::PCM
Description
 If  .true.  renormalization  of  the  polarization  charges is performed to
 enforce  fulfillment  of  the  Gauss  law,  \sum_i  q_i^{e/n}  =
 -[(\epsilon-1)/\epsilon] Q_M^{e/n} where 
 q_i^{e/n}  are  the polarization charges induced by the electrons/nuclei of
 the  molecule and Q_M^{e/n} is the nominal electronic/nuclear charge of the
 system. This can be needed to treat molecules in weakly polar solvents. 
END

Variable PCMQtotTol
Type float
Default 0.5
Section Hamiltonian::PCM
Description
 If  PCMRenormCharges=.true.  and  \delta  Q  =  |[\sum_i  q_i|  -
 ((\epsilon-1)/\epsilon)*|Q_M]|>PCMQtotTol  the polarization charges will be
 normalized as 
 q_i^\prime=q_i  +  signfunction(e, n, \delta Q) (q_i/q_{tot})*\delta Q with
 q_{tot}  = \sum_i q_i. For values of \delta Q > 0.5 (printed by the code in
 the  file pcm/pcm_info.out) even, if polarization charges are renormalized,
 the calculated results might be inaccurate or erroneous. 
END

Variable PCMSmearingFactor
Type float
Default 1.0
Section Hamiltonian::PCM
Description
 Parameter used to control the width (area of each tessera) of the Gaussians
 used  to  distribute  the  polarization  charges  on  each  tessera
 (arXiv:1507.05471).  If  set  to  zero,  the  solvent reaction potential in
 real-space is defined by using point charges. 
END

Variable PCMCavity
Type string
Section Hamiltonian::PCM
Description
 Name  of  the file containing the geometry of the cavity hosting the solute
 molecule.  The  data  must be in atomic units and the file must contain the
 following  information  sequentially:  T  <  Number  of tesserae s_x(1:T) <
 coordinates  x  of  the  tesserae  s_y(1:T) < coordinates y of the tesserae
 s_z(1:T)  <  coordinates  z  of the tesserae A(1:T) < areas of the tesserae
 R_sph(1:T)  <  Radii  of  the  spheres  to  which  the  tesserae  belong
 normal(1:T,1:3) < Outgoing unitary vectors at the tesserae surfaces 
END

Variable PCMSpheresOnH
Type logical
Default no
Section Hamiltonian::PCM
Description
 If  true, spheres centered at the Hydrogens atoms are included to build the
 solute cavity surface. 
END

Variable PCMTessSubdivider
Type integer
Default 1
Section Hamiltonian::PCM
Description
 Allows to subdivide further each tessera refining the discretization of the
 cavity  tesselation.  Can take only two values, 1 or 4. 1 corresponds to 60
 tesserae per sphere, while 4 corresponds to 240 tesserae per sphere. 
END

Variable PCMTessMinDistance
Type float
Default 0.1
Section Hamiltonian::PCM
Description
 Minimum distance between tesserae. Any two tesserae having smaller distance
 in the starting tesselation will be merged together. 
END

Variable PCMCalcMethod
Type integer
Default pcm_direct
Section Hamiltonian::PCM
Description
 Defines the method to be used to obtain the PCM potential. 
Option pcm_direct 1
 Direct  sum  of  the  potential  generated  by  the  polarization  charges
 regularized  with a Gaussian smearing [A. Delgado, et al., J Chem Phys 143,
 144111 (2015)]. 
Option pcm_poisson 2
 Solving the Poisson equation for the polarization charge density. 
END

Variable PCMChargeSmearNN
Type integer
Default 2 * max_area * PCMSmearingFactor
Section Hamiltonian::PCM
Description
 Defines  the number of nearest neighbor mesh-points to be taken around each
 cavity  tessera  in  order  to  smear  the  charge  when  PCMCalcMethod  =
 pcm_poisson.  Setting  PCMChargeSmearNN  = 1 means first nearest neighbors,
 PCMChargeSmearNN = 2 second nearest neighbors, and so on. The default value
 is  such  that  the  neighbor mesh contains points in a radius equal to the
 width used for the gaussian smearing. 
END

Variable MagneticConstrain
Type integer
Default no
Section Hamiltonian
Description
 This  variable  selects which magnetic constrain expression is added to the
 Hamiltonian. 
Option constrain_none 0
 No constrain is added to the Hamiltonian. 
Option constrain_dir 1
 We  are  adding a constrain for the direction of the magnetic moments only,
 see PRB 91, 054420 (2015). 
Option constrain_full 2
 We  are  adding  a  constrain  for  the  direction and norm of the magnetic
 moments only, see PRB 91, 054420 (2015). 
END

Variable MagneticConstrainStrength
Type float
Default 0.01
Section Hamiltonian
Description
 This  variable determines the value of the Lagrange multiplier used for the
 constrain term. 
END

Variable FilterPotentials
Type integer
Default filter_ts
Section Hamiltonian
Description
 Octopus  can  filter  the  pseudopotentials  so that they no longer contain
 Fourier  components  larger  than  the  mesh itself. This is very useful to
 decrease  the  egg-box effect, and so should be used in all instances where
 atoms  move  (_e.g._  geometry  optimization,  molecular  dynamics,  and
 vibrational modes). 
Option filter_none 0
 Do not filter. 
Option filter_TS 2
 The  filter  of M. Tafipolsky and R. Schmid, _J. Chem. Phys._ *124*, 174102
 (2006). 
Option filter_BSB 3
 The filter of E. L. Briggs, D. J. Sullivan, and J. Bernholc, _Phys. Rev. B_
 *54*, 14362 (1996). 
END

Variable ClassicalPotential
Type integer
Default no
Section Hamiltonian
Description
 Whether and how to add to the external potential the potential generated by
 the classical charges read from block PDBClassical, for QM/MM calculations.
 Not available in periodic systems. 
Option no 0
 No classical charges. 
Option point_charges 1
 Classical charges are treated as point charges. 
Option gaussian_smeared 2
 Classical  charges  are  treated as Gaussian distributions. Smearing widths
 are hard-coded by species (experimental). 
END

Variable GyromagneticRatio
Type float
Default 2.0023193043768
Section Hamiltonian
Description
 The  gyromagnetic  ratio  of  the  electron.  This  is of course a physical
 constant, and the default value is the exact one that you should not touch,
 unless:  (i)  You  want  to  disconnect  the  anomalous  Zeeman term in the
 Hamiltonian (then set it to zero; this number only affects that term); (ii)
 You are using an effective Hamiltonian, as is the case when you calculate a
 2D  electron  gas,  in which case you have an effective gyromagnetic factor
 that depends on the material. 
END

Variable RelativisticCorrection
Type integer
Default non_relativistic
Section Hamiltonian
Description
 The  default  value  means  that  _no_  relativistic correction is used. To
 include spin-orbit coupling turn RelativisticCorrection to spin_orbit (this
 will  only  work  if  SpinComponents  has  been set to non_collinear, which
 ensures the use of spinors). 
Option non_relativistic 0
 No relativistic corrections. 
Option spin_orbit 1
 Spin-orbit. 
END

Variable SOStrength
Type float
Default 1.0
Section Hamiltonian
Description
 Tuning  of  the  spin-orbit  coupling  strength: setting this value to zero
 turns  off  spin-orbit  terms  in  the  Hamiltonian,  and setting it to one
 corresponds to full spin-orbit. 
END

Variable TDExternalFields
Type block
Section Time-Dependent
Description
 The  block  TDExternalFields describes the type and shape of time-dependent
 external perturbations that are applied to the system, in the form 
 f(x,y,z)  \cos(\omega t + \phi (t)) g(t), where f(x,y,z) is defined by by a
 field  type  and  polarization  or  a scalar potential, as below; \omega is
 defined by omega; g(t) is defined by 
 envelope_function_name;  and  \phi(t)  is  the  (time-dependent) phase from
 phase. 

 These  perturbations  are only applied for time-dependent runs. If you want
 the  value  of  the  perturbation  at  time  zero  to  be  applied  for
 time-independent runs, use TimeZero = yes. 

 Each  line  of  the  block  describes  an  external field; this way you can
 actually have more than one laser (_e.g._ a "pump" and a "probe"). 

 There  are  two  ways  to  specify  f(x,y,z)  but both use the same omega |
 envelope_function_name  [|  phase] for the time-dependence. The float omega
 will  be the carrier frequency of the pulse (in energy units). The envelope
 of the field is a time-dependent function whose definition must be given in
 a  TDFunctions  block. envelope_function_name is a string (and therefore it
 must  be surrounded by quotation marks) that must match one of the function
 names given in the first column of the TDFunctions block. 
 phase  is  optional  and is taken to be zero if not provided, and is also a
 string specifying a time-dependent function. 

 (A) type = electric field, magnetic field, vector_potential 

 For these cases, the syntax is: 

 %TDExternalFields 
    type | nx | ny | nz | omega | envelope_function_name | phase 
 % 

 The  vector_potential  option (constant in space) permits us to describe an
 electric  perturbation  in the velocity gauge. The three (possibly complex)
 numbers  (nx,  ny,  nz)  mark  the  polarization direction of the field. By
 default,  (nx,  ny,  nz)  are  defined  in  Cartesian space. However, it is
 possible  for  solids  to define them using the Miller indices. This can be
 achieved by defining the block MillerIndicesBasis. 

 (B) type = scalar_potential 

 %TDExternalFields 
    scalar_potential | "spatial_expression" | omega | envelope_function_name
 | phase 
 % 

 The  scalar potential is any expression of the spatial coordinates given by
 the  string  "spatial_expression",  allowing  a  field  beyond  the  dipole
 approximation. 

 For  DFTB  runs,  only fields of type type = electric field are allowed for
 the moment, and the 
 type keyword is omitted. 

 A NOTE ON UNITS: 

 It  is  very  common  to  describe  the  strength  of  a laser field by its
 intensity,  rather than using the electric-field amplitude. In atomic units
 (or,  more  precisely,  in  any Gaussian system of units), the relationship
 between instantaneous electric field and intensity is: 
  I(t) = \frac{c}{8\pi} E^2(t) . 

 It  is  common to read intensities in W/cm^2. The dimensions of intensities
 are  [W]/(L^2T),  where  [W]  are  the  dimensions  of energy. The relevant
 conversion factors are: 

 Hartree / (a_0^2 atomic_time) = 6.4364086 \times 10^{15} \mathrm{W/cm}^2 

 eV / ( &Aring;^2 (\hbar/eV) ) = 2.4341348 \times 10^{12} \mathrm{W/cm}^2 

 If,  in  atomic units, we set the electric-field amplitude to E_0, then the
 intensity is: 

  I_0 = 3.51 \times 10^{16} \mathrm{W/cm}^2 (E_0^2)  

 If, working with Units = ev_angstrom, we set E_0, then the intensity is: 

  I_0 = 1.327 \times 10^{13} (E_0^2) \mathrm{W/cm}^2  

Option electric_field 1
 The  external  field  is  an electric field, the usual case when we want to
 describe a laser in the length gauge. 
Option magnetic_field 2
 The external field is a (homogeneous) time-dependent magnetic field. 
Option vector_potential 3
 The  external field is a time-dependent homogeneous vector potential, which
 may describe a laser field in the velocity gauge. 
Option scalar_potential 4
 The  external field is an arbitrary scalar potential, which may describe an
 inhomogeneous electrical field. 
END

Variable MillerIndicesBasis
Type block
Section Time-Dependent
Description
 When  this  block  is  given,  the  polarisation of the TDExternalFields is
 understood  to be defined in terms of Miller indices. This block define the
 corresponding basis, by defining the reduced coordinates of the X, Y, and Z
 high  symmetry  points,  such  that  the  code  can  do  the  corresponding
 transformation. 

 For  example,  in  an FCC crystal with the conventional primitive cell, the
 following  input  allows  to  define  the  polarization  in terms of Miller
 indices 

 %MillerIndicesBasis 
  0.0 | 0.5 | 0.5 
  0.5 | 0.0 | 0.5 
  0.5 | 0.5 | 0.0 
 % 

 Indeed,  in  this  case, the reciprocal lattice vectors are (-1, 1, 1), (1,
 -1,  1),  and  (1,  1, -1) in units of 2*pi/a. This directly gives that the
 [100]  direction  correspond  to  the  x  direction, [111] gives the vector
 (1,1,1), etc. 

END

Variable GaugeFieldDynamics
Type integer
Default polarization
Section Hamiltonian
Description
 This variable select the dynamics of the gauge field used to apply a finite
 electric field to periodic systems in time-dependent runs. 
Option none 0
 The  gauge  field does not have dynamics. The induced polarization field is
 zero. 
Option polarization 1
 The  gauge field follows the dynamic described in Bertsch et al, Phys. Rev.
 B 62 7998 (2000). 
END

Variable GaugeFieldPropagate
Type logical
Default no
Section Hamiltonian
Description
 Propagate the gauge field with initial condition set by GaugeVectorField or
 zero if not specified 
END

Variable GaugeVectorField
Type block
Section Hamiltonian
Description
 The  gauge  vector  field is used to include a uniform (but time-dependent)
 external  electric  field in a time-dependent run for a periodic system. An
 optional  second row specifies the initial value for the time derivative of
 the gauge field (which is set to zero by default). By default this field is
 not  included. If KPointsUseSymmetries = yes, then SymmetryBreakDir must be
 set  in  the  same  direction.  This  is  used  with  utility
 oct-dielectric_function  according to GF Bertsch, J-I Iwata, A Rubio, and K
 Yabana, 
 _Phys. Rev. B_ *62*, 7998-8002 (2000). 
END

Variable GaugeFieldDelay
Type float
Default 0.
Section Hamiltonian
Description
 The  application  of  the  gauge  field  acts as a probe of the system. For
 dynamical  systems  one  can  apply this probe with a delay relative to the
 start of the simulation. 
END

Variable Xalpha
Type float
Default 1.0
Section Hamiltonian::XC
Description
 The parameter of the Slater X\alpha functional. Applies only for 
 XCFunctional = xc_lda_c_xalpha. 
END

Variable Interaction1D
Type integer
Default interaction_soft_coulomb
Section Hamiltonian::XC
Description
 When  running  in  1D,  one  has  to  soften  the Coulomb interaction. This
 softening is not unique, and several possibilities exist in the literature.
 
Option interaction_exp_screened 0
 Exponentially  screened  Coulomb  interaction.  See,  _e.g._,  M  Casula, S
 Sorella, and G Senatore, _Phys. Rev. B_ *74*, 245427 (2006). 
Option interaction_soft_coulomb 1
 Soft Coulomb interaction of the form 1/\sqrt{x^2 + \alpha^2}. 
END

Variable Interaction1DScreening
Type float
Default 1.0
Section Hamiltonian::XC
Description
 Defines  the screening parameter \alpha of the softened Coulomb interaction
 when running in 1D. 
END

Variable TDDeltaKickTime
Type float
Default 0.0
Section Time-Dependent::Response
Description
 The  delta-perturbation  that  can  be  applied  by  making  use  of  the
 TDDeltaStrength  variable,  can  be  applied  at  the  time  given  by this
 variable.  Usually,  this  time is zero, since one wants to apply the delta
 pertubation  or  "kick"  at  a  system  at  equilibrium,  and  no  other
 time-dependent external potential is used. However, one may want to apply a
 kick on top of a laser field, for example. 
END

Variable TDDeltaStrength
Type float
Default 0
Section Time-Dependent::Response
Description
 When  no  laser  is  applied,  a delta (in time) perturbation with strength
 TDDeltaStrength  can  be  applied.  This  is used to calculate, _e.g._, the
 linear  optical  spectra.  If  the  ions are allowed to move, the kick will
 affect  them  also.  The  electric  field is -(\hbar k / e) \delta(t) for a
 dipole  with zero wavevector, where _k_ = TDDeltaStrength, which causes the
 wavefunctions  instantaneously  to  acquire  a  phase  e^{ikx}. The unit is
 inverse length. 
END

Variable TDDeltaStrengthMode
Type integer
Default kick_density
Section Time-Dependent::Response
Description
 When  calculating the density response via real-time propagation, one needs
 to  perform  an  initial  kick on the KS system, at time zero. Depending on
 what  kind  of response property one wants to obtain, this kick may be done
 in  several  modes.  For  use  to  calculate  triplet  excitations, see MJT
 Oliveira,  A  Castro,  MAL  Marques,  and  A  Rubio,  _J.  Nanoscience  and
 Nanotechnology_ *8*, 3392 (2008). 
Option kick_density 0
 The  total density of the system is perturbed. This mode is appropriate for
 electric dipole response, as for optical absorption. 
Option kick_spin 1
 The individual spin densities are perturbed oppositely. Note that this mode
 is  only  possible  if  the  run  is  done  in spin-polarized mode, or with
 spinors.  This  mode  is  appropriate for the paramagnetic dipole response,
 which can couple to triplet excitations. 
Option kick_spin_and_density 2
 A combination of the two above. Note that this mode is only possible if the
 run  is done in spin-polarized mode, or with spinors. This mode is intended
 for  use  with  symmetries  to  obtain  both  of  the responses at once, at
 described in the reference above. 
Option kick_magnon 3
 Rotates  the  magnetization.  Only  works  for  spinors.  Can  be used in a
 supercell  or  my making use of the generalized Bloch theorem. In the later
 case (see SpiralBoundaryConditions) spin-orbit coupling cannot be used. 
END

Variable TDDeltaUserDefined
Type string
Section Time-Dependent::Response
Description
 By default, the kick function will be a dipole. This will change if (1) the
 variable 
 TDDeltaUserDefined  is  present  in  the  inp  file,  or  (2)  if the block
 TDKickFunction  is  present in the inp file. If both are present in the inp
 file,  the  TDKickFunction  block  will  be  ignored.  The  value  of
 TDDeltaUserDefined should be a string describing the function that is going
 to be used as delta perturbation. 
END

Variable TDKickFunction
Type block
Section Time-Dependent::Response
Description
 If the block TDKickFunction is present in the input file, and the variable 
 TDDeltaUserDefined  is  not present in the input file, the kick function to
 be  applied  at  time  zero  of the time-propagation will not be a "dipole"
 function  (_i.e._ \phi \rightarrow e^{ikx} \phi, but a general multipole in
 the form r^l Y_{lm}(r). 

 Each  line  has  three  columns:  integers  _l_  and  _m_  that defines the
 multipole,  and  a  weight.  Any number of lines may be given, and the kick
 will be the sum of those multipoles with the given weights. 

 This  feature  allows  calculation  of quadrupole, octupole, etc., response
 functions. 
END

Variable TDPolarizationEquivAxes
Type integer
Default 0
Section Time-Dependent::Response::Dipole
Description
 Defines  how  many  of  the  TDPolarization  axes  are  equivalent.  This
 information  is  stored in a file and then used by oct-propagation_spectrum
 to  rebuild  the  full  polarizability  tensor  from  just  the  first
 TDPolarizationEquivAxes  directions.  This  variable  is  also  used  by
 CalculationMode = vdw. 
END

Variable TDPolarizationDirection
Type integer
Section Time-Dependent::Response::Dipole
Description
 When  a  delta potential is included in a time-dependent run, this variable
 defines  in  which  direction the field will be applied by selecting one of
 the lines of TDPolarization. In a typical run (without using symmetry), the
 TDPolarization  block  would  contain the three Cartesian unit vectors (the
 default value), and one would make 3 runs varying 
 TDPolarization from 1 to 3. If one is using symmetry, TDPolarization should
 run only from 1 to TDPolarizationEquivAxes. 
END

Variable TDPolarization
Type block
Section Time-Dependent::Response::Dipole
Description
 The  (real)  polarization  of  the delta electric field. Normally one needs
 three perpendicular polarization directions to calculate a spectrum (unless
 symmetry is used). The format of the block is: 

 %TDPolarization 
   pol1x | pol1y | pol1z 
   pol2x | pol2y | pol2z 
   pol3x | pol3y | pol3z 
 % 

 Octopus uses both this block and the variable 
 TDPolarizationDirection  to  determine the polarization vector for the run.
 For example, if 
 TDPolarizationDirection=2  the  polarization (pol2x, pol2y, pol2z) would be
 used. These directions may not be in periodic directions. 

 The  default  value  for TDPolarization is the three Cartesian unit vectors
 (1,0,0), (0,1,0), and (0,0,1). 

 Note  that  the directions do not necessarily need to be perpendicular when
 symmetries are used. 

 WARNING: If you want to obtain the cross-section tensor, the 
 TDPolarization  block  must  be  exactly  the  same  for  the  run  in each
 direction. The direction must be selected by the 
 TDPolarizationDirection variable. 

END

Variable TDPolarizationWprime
Type block
Section Time-Dependent::Response::Dipole
Description
 This block is needed only when 
 TDPolarizationEquivAxes  is  set to 3. In such a case, the three directions
 (_pol1_,  _pol2_, and _pol3_) defined in the TDPolarization block should be
 related by symmetry operations. If _A_ is the symmetry operation that takes
 you  from  _pol1_ to _pol2_, then TDPolarizationWprime should be set to the
 direction defined by _A_^{-1}_pol3_. For more information see MJT Oliveira 
 _et al._, _J. Nanoscience and Nanotechnology_ *8*, 3392 (2008). 
END

Variable TDReducedMomentumTransfer
Type block
Section Time-Dependent::Response
Description
 The  same  as  TDMomentumTransfer, but the momentum is specified in reduced
 coordinates.  Only  available for magnon kicks at the moment, and only with
 an exponential kick. 
END

Variable TDMomentumTransfer
Type block
Section Time-Dependent::Response
Description
 Momentum-transfer  vector  for  the  calculation  of  the dynamic structure
 factor.  When  this  variable is set, a non-dipole field is applied, and an
 output file 
 ftchd  is  created (it contains the Fourier transform of the charge density
 at  each  time).  The  type  of the applied external field can be set by an
 optional last number. Possible options are qexp (default), qcos, 
 qsin, or qcos+qsin. In the formulae below, 
 \vec{q} is the momentum-transfer vector. 
Option qexp 1
 External field is e^{i \vec{q} \cdot \vec{r}}. 
Option qcos 2
 External field is \cos \left( i \vec{q} \cdot \vec{r} \right). 
Option qsin 3
 External field is \sin \left( i \vec{q} \cdot \vec{r} \right). 
Option qbessel 4
 External  field  is  j_l  \left(  \vec{q}  \cdot  \vec{r}  \right)  Y_{lm}
 \left(\vec{r}  \right).  In  this  case, the block has to include two extra
 values (_l_ and _m_). 
END

Variable TDEasyAxis
Type block
Section Time-Dependent::Response::Dipole
Description
 For magnon kicks only. This variable defines the direction of the easy axis
 of the crystal. The magnetization is kicked in the plane transverse to this
 vector 
END

Variable TDMultipleMomentumTransfer
Type block
Section Time-Dependent::Response
Description
 For  magnon  kicks  only. A simple way to specify momentum-transfer vectors
 for  the calculation of the magnetization dynamics. This variable should be
 used  for  a  supercell. For each reciprocal lattice vectors, the code will
 kick  the  original magnetization using all the multiples of it. The syntax
 reads: 

 %TDMultipleMomentumTransfer 
   N_x | N_y | N_z 
 % 

 and  will  include  the (2N_x+1)*(2N_y+1)*(2N_z+1) multiples vectors of the
 reciprocal lattice vectors of the current cell. 
END

Variable XCUseGaugeIndependentKED
Type logical
Default yes
Section Hamiltonian::XC
Description
 If  true,  when  evaluating  the  XC  functional,  a  term  including  the
 (paramagnetic or total) current is added to the kinetic-energy density such
 as  to  make  it  gauge-independent.  Applies  only to meta-GGA (and hybrid
 meta-GGA) functionals. 
END

Variable XCKernelLRCAlpha
Type float
Default 0.0
Section Hamiltonian::XC
Description
 Set  to  a  non-zero value to add a long-range correction for solids to the
 kernel.  This  is the \alpha parameter defined in S. Botti _et al._, _Phys.
 Rev.  B_  69,  155112  (2004). The \Gamma = \Gamma` = 0 term -\alpha/q^2 is
 taken  into account by introducing an additional pole to the polarizability
 (see R. Stubner 
 _et  al._,  _Phys.  Rev.  B_  70, 245119 (2004)). The rest of the terms are
 included  by multiplying the Hartree term by 1 - \alpha / 4 \pi. The use of
 non-zero 
 \alpha in combination with HamiltonianVariation = V_ext_only corresponds to
 account of only the \Gamma = \Gamma` = 0 term. Applicable only to isotropic
 systems. (Experimental) 
END

Variable XCDensityCorrection
Type integer
Default none
Section Hamiltonian::XC::DensityCorrection
Description
 This  variable controls the long-range correction of the XC potential using
 the <a href=http://arxiv.org/abs/1107.4339>XC density representation</a>. 
Option none 0
 No correction is applied. 
Option long_range_x 1
 The correction is applied to the exchange potential. 
END

Variable XCDensityCorrectionOptimize
Type logical
Default true
Section Hamiltonian::XC::DensityCorrection
Description
 When  enabled,  the  density  cutoff  will  be  optimized  to replicate the
 boundary  conditions  of  the exact XC potential. If the variable is set to
 no,  the value of the cutoff must be given by the XCDensityCorrectionCutoff
 variable. 
END

Variable XCDensityCorrectionCutoff
Type float
Default 0.0
Section Hamiltonian::XC::DensityCorrection
Description
 The value of the cutoff applied to the XC density. 
END

Variable XCDensityCorrectionMinimum
Type logical
Default true
Section Hamiltonian::XC::DensityCorrection
Description
 When  enabled, the cutoff optimization will return the first minimum of the
 q_{xc}  function  if  it  does  not  find  a  value  of  -1  (<a
 href=http://arxiv.org/abs/1107.4339>details</a>).  This  is  required  for
 atoms or small molecules, but may cause numerical problems. 
END

Variable XCDensityCorrectionNormalize
Type logical
Default true
Section Hamiltonian::XC::DensityCorrection
Description
 When  enabled,  the  correction  will  be normalized to reproduce the exact
 boundary conditions of the XC potential. 
END

Variable ParallelXC
Type logical
Default true
Section Execution::Parallelization
Description
 When  enabled,  additional parallelization will be used for the calculation
 of the XC functional. 
END

Variable ParticleMass
Type float
Default 1.0
Section Hamiltonian
Description
 It  is  possible  to make calculations for a particle with a mass different
 from  one (atomic unit of mass, or mass of the electron). This is useful to
 describe non-electronic systems, or for esoteric purposes. 
END

Variable RashbaSpinOrbitCoupling
Type float
Default 0.0
Section Hamiltonian
Description
 (Experimental.)  For  systems  described in 2D (electrons confined to 2D in
 semiconductor  structures),  one  may  add  the  Bychkov-Rashba  spin-orbit
 coupling  term  [Bychkov  and Rashba, _J. Phys. C: Solid State Phys._ *17*,
 6031  (1984)].  This variable determines the strength of this perturbation,
 and has dimensions of energy times length. 
END

Variable CalculateSelfInducedMagneticField
Type logical
Default no
Section Hamiltonian
Description
 The  existence  of  an  electronic  current  implies  the  creation  of  a
 self-induced magnetic field, which may in turn back-react on the system. Of
 course,  a fully consistent treatment of this kind of effect should be done
 in  QED theory, but we will attempt a first approximation to the problem by
 considering  the  lowest-order  relativistic  terms plugged into the normal
 Hamiltonian  equations  (spin-other-orbit  coupling  terms,  etc.). For the
 moment  being,  none  of  this  is  done,  but  a  first  step  is taken by
 calculating  the  induced magnetic field of a system that has a current, by
 considering the magnetostatic approximation and Biot-Savart law: 

  \nabla^2 \vec{A} + 4\pi\alpha \vec{J} = 0 

  \vec{B} = \vec{\nabla} \times \vec{A} 

 If  CalculateSelfInducedMagneticField  is  set  to  yes,  this _B_ field is
 calculated at the end of a gs calculation (nothing is done -- yet -- in the
 tdcase)  and  printed  out,  if  the Output variable contains the potential
 keyword (the prefix of the output files is Bind). 
END

Variable DFTULevel
Type integer
Default no
Section Hamiltonian::XC
Description
 This variable selects which DFT+U expression is added to the Hamiltonian. 
Option dft_u_none 0
 No +U term is not applied. 
Option dft_u_empirical 1
 An  empiricial  Hubbard  U  is added on the orbitals specified in the block
 species with hubbard_l and hubbard_u 
Option dft_u_acbn0 2
 Octopus  determines  the  effective  U  term  using the ACBN0 functional as
 defined in PRX 5, 011006 (2015) 
END

Variable HamiltonianApplyPacked
Type logical
Default yes
Section Execution::Optimization
Description
 If  set  to  yes (the default), Octopus will 'pack' the wave-functions when
 operating  with  them. This might involve some additional copying but makes
 operations more efficient. See also the related StatesPack variable. 
END

Variable TimeZero
Type logical
Default no
Section Hamiltonian
Description
 (Experimental)  If  set  to  yes, the ground state and other time dependent
 calculation  will  assume that they are done at time zero, so that all time
 depedent field at that time will be included. 
END

Variable AdaptivelyCompressedExchange
Type logical
Default false
Section Hamiltonian
Description
 (Experimental)  If  set  to yes, Octopus will use the adaptively compressed
 exchange  operator (ACE) for HF and hybrid calculations, as defined in Lin,
 J. Chem. Theory Comput. 2016, 12, 2242. 
END

Variable EwaldAlpha
Type float
Default 0.21
Section Hamiltonian
Description
 The value 'Alpha' that controls the splitting of the Coulomb interaction in
 the  Ewald  sum  used  to  calculation the ion-ion interaction for periodic
 systems. This value affects the speed of the calculation, normally users do
 not need to modify it. 
END

Variable libvdwxcDebug
Type logical
Section Hamiltonian::XC
Description
 Dump libvdwxc inputs and outputs to files. 
END

Variable libvdwxcVDWFactor
Type float
Section Hamiltonian::XC
Description
 Prefactor  of non-local van der Waals functional. Setting a prefactor other
 than one is wrong, but useful for debugging. 
END

Variable libvdwxcMode
Type integer
Section Hamiltonian::XC
Description
 Whether  libvdwxc  should  run  with  serial  fftw3, fftw3-mpi, or pfft. to
 specify  fftw3-mpi  in serial for debugging. pfft is not implemented at the
 moment. 
Option libvdwxc_mode_auto 1
 Use serial fftw3 if actually running in serial, else fftw3-mpi. 
Option libvdwxc_mode_serial 2
 Run with serial fftw3. Works only when not parallelizing over domains. 
Option libvdwxc_mode_mpi 3
 Run with fftw3-mpi. Works only if Octopus is compiled with MPI. 
END

Variable MaxAngularMomentum
Type block
Section DFTBPlusInterface
Description
 Specifies  the highest angular momentum for each atom type. All orbitals up
 to  that  angular  momentum  will  be included in the calculation. Possible
 values for the angular momenta are s, p, d, f. These are examples: 

 %MaxAngularMomentum 
   'O' | 'p' 
   'H' | 's' 
 % 
END

Variable SlakoDir
Type string
Default "./"
Section Execution::IO
Description
 Folder containing the Slako files 
END

Variable InitialIonicTemperature
Type float
Default 0.0
Section DFTBPlusInterface
Description
 If  this  variable  is  present,  the  ions  will  have  initial velocities
 velocities  to  the  atoms  following  a  Boltzmann  distribution with this
 temperature (in Kelvin). Used only if TDDynamics = Ehrenfest and MoveIons =
 yes. 
END

Variable SccTolerance
Type float
Section DFTBPlusInterface
Description
 Self-consistent-charges convergence tolerance. Once this tolerance has been
 achieved the SCC cycle will stop. 
END

Variable PDBCoordinates
Type string
Section System::Coordinates
Description
 If  this  variable  is  present,  the  program  tries  to  read  the atomic
 coordinates  from  the  file  specified  by  its  value.  The  PDB  (<a
 href=http://www.rcsb.org/pdb>Protein  Data  Bank</a>)  format  is  quite
 complicated, and it goes well beyond the scope of this manual. You can find
 a  comprehensive  description  <a
 href=http://www.wwpdb.org/docs.html>here</a>.  From  the  plethora  of
 instructions  defined in the PDB standard, Octopus only reads two, ATOM and
 HETATOM. From these fields, it reads: 
  
  *)  columns 13-16: The species; in fact Octopus only cares about the first
 letter  -  CA and CB will both refer to carbon - so elements whose chemical
 symbol  has  more than one letter cannot be represented in this way. So, if
 you  want to run mercury (Hg), please use one of the other methods to input
 the coordinates. 
  *)  columns 18-21: The residue. Ignored. 
  *)  columns  31-54:  The  Cartesian  coordinates.  The  Fortran  format is
 (3f8.3). 
  *)  columns  61-65:  Classical  charge  of  the  atom. Required if reading
 classical atoms, ignored otherwise. The Fortran format is (f6.2). 
  NOTE:  The  coordinates are treated in the units specified by Units and/or
 UnitsInput. 
END

Variable PDBClassical
Type string
Section System::Coordinates
Description
 If  this  variable  is  present,  the  program  tries  to  read  the atomic
 coordinates  for classical atoms. from the file specified by its value. The
 same  as  PDBCoordinates,  except  that  the classical charge colum must be
 present.  The  interaction  from  the  classical  atoms  is  specified  by
 ClassicalPotential,  for  QM/MM  calculations.  Not  available  in periodic
 systems. 
END

Variable XYZCoordinates
Type string
Section System::Coordinates
Description
 If  PDBCoordinates is not present, the program reads the atomic coordinates
 from  the XYZ file specified by the variable XYZCoordinates -- in case this
 variable  is  present. The XYZ format is very simple: The first line of the
 file  has an integer indicating the number of atoms. The second can contain
 comments that are simply ignored by 
 Octopus.  Then  there  follows  one  line per atom, containing the chemical
 species and the Cartesian coordinates of the atom. 

 If  you  want to specify the unit of the XYZ file, you can use the variable
 UnitsXYZFiles. 
END

Variable XSFCoordinates
Type string
Section System::Coordinates
Description
 Another  option  besides  PDB  and  XYZ  coordinates  formats is XSF, as <a
 href=http://www.xcrysden.org/doc/XSF.html>defined</a>  by  the  XCrySDen
 visualization program. Specify the filename with this variable. The lattice
 vectors will also be read from this file and the value of 
 PeriodicDimensions  needs  to  be  compatible with the first line (CRYSTAL,
 SLAB, POLYMER, or MOLECULE). The file should not contain ATOMS, CONVVEC, or
 PRIMCOORD.  NOTE:  The  coordinates  are  treated in the units specified by
 Units and/or UnitsInput. 
END

Variable XSFCoordinatesAnimStep
Type integer
Default 1
Section System::Coordinates
Description
 If  an  animated  file  is given with XSFCoordinates, this variable selects
 which  animation  step  will be used. The PRIMVEC block must be written for
 each step. 
END

Variable Coordinates
Type block
Section System::Coordinates
Description
 If XYZCoordinates, PDBCoordinates, and XSFCoordinates were not found, 
 Octopus  tries  to  read  the  coordinates  for  the  atoms  from the block
 Coordinates. The format is quite straightforward: 

 %Coordinates 
   'C' | -0.56415 | 0.0 | 0.0 | no 
   'O' |  0.56415 | 0.0 | 0.0 | no 
 % 

 The  first  line defines a carbon atom at coordinates (-0.56415, 0.0, 0.0),
 that is *not* allowed to move during dynamical simulations. The second line
 has  a  similar  meaning.  This  block  obviously defines a carbon monoxide
 molecule, if the input units are eV_Angstrom. The number of coordinates for
 each  species  must  be equal to the dimension of your space (generally 3).
 Note  that in this way it is possible to fix some of the atoms (this is not
 possible when specifying the coordinates through a PDBCoordinates or 
 XYZCoordinates  file). The last column is optional, and the default is yes.
 It is always possible to fix *all* atoms using the MoveIons directive. 
END

Variable ReducedCoordinates
Type block
Section System::Coordinates
Description
 This  block  gives  the  atomic coordinates relative to the real space unit
 cell. The format is the same as the 
 Coordinates block. 

 Note  that  in  Octopus  the  origin of coordinates is in the center of the
 cell, so the coordinates inside the cell are in the range [-0.5, 0.5). 

 This block cannot be used with the minimum box shape. 
END

Variable SymmetriesCompute
Type logical
Section Execution::Symmetries
Description
 If disabled, Octopus will not compute nor print the symmetries. 

 By  default,  symmetries  are  computed  when  running  in 3 dimensions for
 systems  with  less  than  100  atoms. For periodic systems, the default is
 always true, irrespective of the number of atoms. 
END

Variable SymmetriesTolerance
Type float
Section Execution::Symmetries
Description
 For  periodic  systems,  this  variable  controls the tolerance used by the
 symmetry  finder  (spglib)  to  find  the  spacegroup and symmetries of the
 crystal. 
END

Variable SymmetryBreakDir
Type block
Section Mesh::Simulation Box
Description
 This  variable  specifies  a  direction in which the symmetry of the system
 will  be  broken.  This  is  useful  for generating _k_-point grids when an
 external perturbation is applied. 
END

Variable BornChargeSumRuleCorrection
Type logical
Default true
Section Linear Response::Polarizabilities
Description
 Enforce  the  acoustic  sum  rule  by  distributing  the excess sum of Born
 charges  equally among the atoms. Sum rule: \sum_{\alpha} Z^{*}_{\alpha, i,
 j}  =  Z_{\rm  tot} \delta_{ij}. Violation of the sum rule may be caused by
 inadequate  spacing, box size (in finite directions), or _k_-point sampling
 (in periodic directions). 
END

Variable ForceTotalEnforce
Type logical
Default no
Section Hamiltonian
Description
 (Experimental)  If this variable is set to "yes", then the sum of the total
 forces will be enforced to be zero. 
END

Variable TDGlobalForce
Type string
Section Time-Dependent
Description
 If  this  variable is set, a global time-dependent force will be applied to
 the  ions  in  the  x  direction during a time-dependent run. This variable
 defines  the  base  name  of  the  force,  that  should  be  defined in the
 TDFunctions block. This force does not affect the electrons directly. 
END

Variable SpeciesTimeDependent
Type logical
Default no
Section System::Species
Description
 When  this  variable  is set, the potential defined in the block Species is
 calculated  and applied to the Hamiltonian at each time step. You must have
 at least one species_user_defined type of species to use this. 
END

Variable TDIonicTimeScale
Type float
Default 1.0
Section Time-Dependent::Propagation
Description
 This  variable  defines  the  factor  between  the  timescale  of ionic and
 electronic  movement.  It  allows  reasonably  fast  Born-Oppenheimer
 molecular-dynamics  simulations  based  on Ehrenfest dynamics. The value of
 this  variable  is  equivalent  to  the  role  of  \mu  in  Car-Parrinello.
 Increasing  it  linearly accelerates the time step of the ion dynamics, but
 also  increases  the  deviation  of  the  system  from the Born-Oppenheimer
 surface.  The  default is 1, which means that both timescales are the same.
 Note  that  a  value  different  than 1 implies that the electrons will not
 follow physical behaviour. 

 According to our tests, values around 10 are reasonable, but it will depend
 on your system, mainly on the width of the gap. 

 Important: The electronic time step will be the value of 
 TDTimeStep  divided  by this variable, so if you have determined an optimal
 electronic  time  step (that we can call _dte_), it is recommended that you
 define your time step as: 

 TDTimeStep = _dte_ * TDIonicTimeScale 

 so  you  will  always  use  the  optimal  electronic  time  step  (<a
 href=http://arxiv.org/abs/0710.3321>more details</a>). 
END

Variable IonsConstantVelocity
Type logical
Default no
Section Time-Dependent::Propagation
Description
 (Experimental)  If  this  variable is set to yes, the ions will move with a
 constant  velocity  given  by  the  initial  conditions.  They  will not be
 affected by any forces. 
END

Variable IonsTimeDependentDisplacements
Type block
Section Time-Dependent::Propagation
Description
 (Experimental)  This  variable  allows  you  to  specify  a  time-dependent
 function  describing  the  displacement  of the ions from their equilibrium
 position: r(t) = r_0 + \Delta r(t). Specify the displacements dx(t), dy(t),
 dz(t) as follows, for some or all of the atoms: 

 %IonsTimeDependentDisplacements 
    atom_index | "dx(t)" | "dy(t)" | "dz(t)" 
 % 

 The  displacement  functions  are time-dependent functions and should match
 one  of  the  function  names  given in the first column of the TDFunctions
 block. If this block is set, the ions will not be affected by any forces. 
END

Variable Thermostat
Type integer
Default none
Section Time-Dependent::Propagation
Description
 This  variable  selects the type of thermostat applied to control the ionic
 temperature. 
Option none 0
 No thermostat is applied. This is the default. 
Option velocity_scaling 1
 Velocities are scaled to control the temperature. 
Option nose_hoover 2
 Nose-Hoover thermostat. 
END

Variable TemperatureFunction
Type integer
Default "temperature"
Section Time-Dependent::Propagation
Description
 If  a  thermostat is used, this variable indicates the name of the function
 in  the TDFunctions block that will be used to control the temperature. The
 values of the temperature are given in degrees Kelvin. 
END

Variable ThermostatMass
Type float
Default 1.0
Section Time-Dependent::Propagation
Description
 This variable sets the fictitious mass for the Nose-Hoover thermostat. 
END

Variable RandomVelocityTemp
Type float
Default 0.0
Section System::Velocities
Description
 If  this  variable is present, Octopus will assign random velocities to the
 atoms  following  a  Boltzmann  distribution  with  temperature  given  by
 RandomVelocityTemp  (in  degrees  Kelvin).  The  seed for the random number
 generator can be modified by setting 
 GSL_RNG_SEED environment variable. 
END

Variable XYZVelocities
Type string
Section System::Velocities
Description
 Octopus  will try to read the starting velocities of the atoms from the XYZ
 file  specified by the variable XYZVelocities. Note that you do not need to
 specify initial velocities if you are not going to perform ion dynamics; if
 you  are  going  to  allow  the  ions  to  move  but the velocities are not
 specified,  they  are  considered to be null. Note: It is important for the
 velocities  to maintain the ordering in which the atoms were defined in the
 coordinates specifications. 
END

Variable XSFVelocities
Type string
Section System::Velocities
Description
 Like XYZVelocities but in XCrySDen format, as in XSFCoordinates. 
END

Variable PDBVelocities
Type string
Section System::Velocities
Description
 Like XYZVelocities but in PDB format, as in PDBCoordinates. 
END

Variable Velocities
Type block
Section System::Velocities
Description
 If XYZVelocities, PDBVelocities, and XSFVelocities are not present, Octopus
 will  try  to  fetch the initial atomic velocities from this block. If this
 block  is not present, Octopus will set the initial velocities to zero. The
 format of this block can be illustrated by this example: 

 %Velocities 
   'C' | -1.7 | 0.0 | 0.0 
   'O' |  1.7 | 0.0 | 0.0 
 % 

 It  describes  one carbon and one oxygen moving at the relative velocity of
 3.4 velocity units. 

 Note:  It is important for the velocities to maintain the ordering in which
 the atoms were defined in the coordinates specifications. 
END

Variable MoveIons
Type logical
Section Time-Dependent::Propagation
Description
 This  variable  controls  whether atoms are moved during a time propagation
 run.  The  default  is  yes  when  the  ion  velocity  is set explicitly or
 implicitly, otherwise is no. 
END

Variable DressedOrbitals
Type logical
Default false
Section Hamiltonian::Poisson
Description
 Allows  for  the calculation of coupled elecron-photon problems by applying
 the  dressed  orbital  approach.  Details  can  be  found  in
 https://arxiv.org/abs/1812.05562  At  the  moment,  N  electrons in d (<=3)
 spatial dimensions, coupled to one photon mode can be described. The photon
 mode  is  included by raising the orbital dimension to d+1 and changing the
 particle  interaction  kernel  and the local potential, where the former is
 included  automatically,  but  the  latter  needs  to by added by hand as a
 user_defined_potential! Coordinate 1-d: electron; coordinate d+1: photon. 
END

Variable ParallelizationPoissonAllNodes
Type logical
Default true
Section Execution::Parallelization
Description
 When  running in parallel, this variable selects whether the Poisson solver
 should  divide  the  work  among  all  nodes  or  only  among  the
 parallelization-in-domains groups. 
END

Variable PoissonSolver
Type integer
Section Hamiltonian::Poisson
Description
 Defines  which  method  to  use  to  solve  the  Poisson  equation.  Some
 incompatibilities  apply depending on dimensionality, periodicity, etc. For
 a comparison of the accuracy and performance of the methods in Octopus, see
 P  Garcia-Risue&ntilde;o,  J  Alberdi-Rodriguez  _et al._, _J. Comp. Chem._
 *35*,  427-444  (2014) or <a href=http://arxiv.org/abs/1211.2092>arXiV</a>.
 Defaults: 
  1D and 2D: fft. 
  3D: cg_corrected if curvilinear, isf if not periodic, fft if periodic. 
  Dressed orbitals: direct_sum. 
Option NoPoisson -99
 Do not use a Poisson solver at all. 
Option FMM -4
 (Experimental) Fast multipole method. Requires FMM library. 
Option direct_sum -1
 Direct evaluation of the Hartree potential (only for finite systems). 
Option fft 0
 The  Poisson  equation  is  solved  using  FFTs. A cutoff technique for the
 Poisson  kernel  is  selected so the proper boundary conditions are imposed
 according  to  the periodicity of the system. This can be overridden by the
 PoissonFFTKernel variable. To choose the FFT library use FFTLibrary 
Option cg 5
 Conjugate gradients (only for finite systems). 
Option cg_corrected 6
 Conjugate  gradients,  corrected  for  boundary conditions (only for finite
 systems). 
Option multigrid 7
 Multigrid method (only for finite systems). 
Option isf 8
 Interpolating Scaling Functions Poisson solver (only for finite systems). 
Option psolver 10
 Solver  based  on  Interpolating  Scaling  Functions  as implemented in the
 PSolver  library.  Parallelization  in  k-points  requires
 PoissonSolverPSolverParallelData  =  no.  Requires  the  PSolver  external
 library. 
Option poke 11
 (Experimental) Solver from the Poke library. 
END

Variable PoissonFFTKernel
Type integer
Section Hamiltonian::Poisson
Description
 Defines which kernel is used to impose the correct boundary conditions when
 using FFTs to solve the Poisson equation. The default is selected depending
 on the dimensionality and periodicity of the system: 
 In 1D, spherical if finite, fft_nocut if periodic. 
 In  2D,  spherical  if  finite,  cylindrical  if  1D-periodic, fft_nocut if
 2D-periodic. 
 In  3D,  spherical  if  finite,  cylindrical  if  1D-periodic,  planar  if
 2D-periodic, 
 fft_nocut  if  3D-periodic.  See  C.  A. Rozzi et al., _Phys. Rev. B_ *73*,
 205119  (2006)  for  3D implementation and A. Castro et al., _Phys. Rev. B_
 *80*, 033102 (2009) for 2D implementation. 
Option spherical 0
 FFTs using spherical cutoff (in 2D or 3D). 
Option cylindrical 1
 FFTs using cylindrical cutoff (in 2D or 3D). 
Option planar 2
 FFTs using planar cutoff (in 3D). 
Option fft_nocut 3
 FFTs without using a cutoff (for fully periodic systems). 
Option multipole_correction 4
 The  boundary  conditions  are imposed by using a multipole expansion. Only
 appropriate for finite systems. Further specification occurs with variables
 PoissonSolverBoundaries and PoissonSolverMaxMultipole. 
END

Variable DoubleFFTParameter
Type float
Default 2.0
Section Mesh::FFTs
Description
 For  solving  the  Poisson  equation in Fourier space, and for applying the
 local  potential  in  Fourier space, an auxiliary cubic mesh is built. This
 mesh  will  be  larger  than  the circumscribed cube of the usual mesh by a
 factor DoubleFFTParameter. See the section that refers to Poisson equation,
 and  to  the  local  potential  for  details  [the  default value of two is
 typically good]. 
END

Variable PoissonTestPeriodicThreshold
Type float
Default 1e-5
Section Hamiltonian::Poisson
Description
 This  threshold  determines  the  accuracy  of  the  periodic copies of the
 Gaussian charge distribution that are taken into account when computing the
 analytical  solution  for periodic systems. Be aware that the default leads
 to  good  results  for  systems that are periodic in 1D - for 3D it is very
 costly because of the large number of copies needed. 
END

Variable PoissonSolverBoundaries
Type integer
Section Hamiltonian::Poisson
Default multipole
Description
 For finite systems, some Poisson solvers (multigrid, 
 cg_corrected, and fft with PoissonFFTKernel = multipole_correction) require
 the  calculation  of the boundary conditions with an auxiliary method. This
 variable selects that method. 
Option multipole 1
 A  multipole  expansion of the density is used to approximate the potential
 on the boundaries. 
Option exact 3
 An  exact  integration of the Poisson equation is done over the boundaries.
 This  option  is  experimental,  and  not  implemented  for  domain
 parallelization. 
END

Variable PoissonSolverMGPresmoothingSteps
Type integer
Default 1
Section Hamiltonian::Poisson::Multigrid
Description
 Number  of  Gauss-Seidel  smoothing steps before coarse-level correction in
 the multigrid Poisson solver. 
END

Variable PoissonSolverMGPostsmoothingSteps
Type integer
Default 4
Section Hamiltonian::Poisson::Multigrid
Description
 Number of Gauss-Seidel smoothing steps after coarse-level correction in the
 multigrid Poisson solver. 
END

Variable PoissonSolverMGMaxCycles
Type integer
Default 60
Section Hamiltonian::Poisson::Multigrid
Description
 Maximum number of multigrid cycles that are performed if convergence is not
 achieved. 
END

Variable PoissonSolverMGRestrictionMethod
Type integer
Default fullweight
Section Hamiltonian::Poisson::Multigrid
Description
 Method used from fine-to-coarse grid transfer. 
Option injection 1
 Injection 
Option fullweight 2
 Fullweight restriction 
END

Variable PoissonSolverMGRelaxationMethod
Type integer
Section Hamiltonian::Poisson::Multigrid
Description
 Method  used  to solve the linear system approximately in each grid for the
 multigrid  procedure that solves Poisson equation. Default is gauss_seidel,
 unless  curvilinear  coordinates  are  used,  in  which case the default is
 gauss_jacobi. 
Option gauss_seidel 1
 Gauss-Seidel. 
Option gauss_jacobi 2
 Gauss-Jacobi. 
Option gauss_jacobi2 3
 Alternative implementation of Gauss-Jacobi. 
END

Variable PoissonSolverMGRelaxationFactor
Type float
Section Hamiltonian::Poisson::Multigrid
Description
 Relaxation factor of the relaxation operator used for the multigrid method.
 This  is  mainly  for  debugging,  since  overrelaxation does not help in a
 multigrid  scheme.  The  default is 1.0, except 0.6666 for the gauss_jacobi
 method. 
END

Variable PoissonSolverMaxMultipole
Type integer
Section Hamiltonian::Poisson
Description
 Order of the multipolar expansion for boundary corrections. 

 The  Poisson  solvers  multigrid,  cg,  and  cg_corrected  (and  fft  with
 PoissonFFTKernel  =  multipole_correction) do a multipolar expansion of the
 given charge density, such that \rho = \rho_{multip.expansion}+\Delta \rho.
 The  Hartree  potential  due  to  the \rho_{multip.expansion} is calculated
 analytically,  while the Hartree potential due to \Delta \rho is calculated
 with either a multigrid or cg solver. The order of the multipolar expansion
 is set by this variable. 

 Default  is 4 for PoissonSolver = cg_corrected and multigrid, and 2 for fft
 with PoissonFFTKernel = multipole_correction. 
END

Variable PoissonSolverMaxIter
Type integer
Section Hamiltonian::Poisson
Default 500
Description
 The maximum number of iterations for conjugate-gradient Poisson solvers. 
END

Variable PoissonSolverThreshold
Type float
Section Hamiltonian::Poisson
Default 1e-6
Description
 The tolerance for the Poisson solution, used by the cg, 
 cg_corrected, and multigrid solvers. 
END

Variable Poisson1DSoftCoulombParam
Type float
Default 1.0 bohr
Section Hamiltonian::Poisson
Description
 When Dimensions = 1, to prevent divergence, the Coulomb interaction treated
 by  the  Poisson  solver  is  not  1/r  but  1/\sqrt{a^2 + r^2}, where this
 variable sets the value of a. 
END

Variable DeltaEFMM
Type float
Default 0.0001
Section Hamiltonian::Poisson
Description
 Dimensionless  parameter  for  relative convergence of PoissonSolver = FMM.
 Sets energy error bound. Strong inhomogeneous systems may violate the error
 bound.  For  inhomogeneous  systems  we have an error-controlled sequential
 version available (from Ivo Kabadshow). 

 Our  implementation  of  FMM  (based on H. Dachsel, _J. Chem. Phys._ *131*,
 244102  (2009)) can keep the error of the Hartree energy below an arbitrary
 bound.  The  quotient  of  the  value  chosen  for the maximum error in the
 Hartree energy and the value of the Hartree energy is 
 DeltaEFMM. 

END

Variable AlphaFMM
Type float
Default 0.291262136
Section Hamiltonian::Poisson
Description
 Dimensionless  parameter  for the correction of the self-interaction of the
 electrostatic Hartree potential, when using PoissonSolver = FMM. 

 Octopus  represents  charge  density  on  a  real-space  grid,  each  point
 containing  a  value  \rho  corresponding to the charge density in the cell
 centered  in  such point. Therefore, the integral for the Hartree potential
 at point i, V_H(i), can be reduced to a summation: 

 V_H(i)  =  \frac{\Omega}{4\pi\varepsilon_0}  \sum_{i  \neq  j}
 \frac{\rho(\vec{r}(j))}{|\vec{r}(j) - \vec{r}(i)|} + V_{self.int.}(i) where
 \Omega is the volume element of the mesh, and \vec{r}(j) is the position of
 the point j. The V_{self.int.}(i) corresponds to the integral over the cell
 centered  on  the  point  i  that  is  necessary  to  calculate the Hartree
 potential at point i: 

 V_{self.int.}(i)=\frac{1}{4\pi\varepsilon_0}  \int_{\Omega(i)}d\vec{r}
 \frac{\rho(\vec{r}(i))}{|\vec{r}-\vec{r}(i)|} 

 In the FMM version implemented into Octopus, a correction method for V_H(i)
 is  used (see Garc&iacute;a-Risue&ntilde;o _et al._, _J. Comp. Chem._ *35*,
 427  (2014)).  This  method  defines  cells neighbouring cell i, which have
 volume \Omega(i)/8 (in 3D) and charge density obtained by interpolation. In
 the calculation of V_H(i), in order to avoid double counting of charge, and
 to  cancel  part  of  the  errors  arising  from  considering the distances
 constant  in  the  summation above, a term -\alpha_{FMM}V_{self.int.}(i) is
 added to the summation (see the paper for the explicit formulae). 
END

Variable PoissonCutoffRadius
Type float
Section Hamiltonian::Poisson
Description
 When  PoissonSolver  =  fft  and  PoissonFFTKernel  is  neither
 multipole_corrections  nor  fft_nocut,  this variable controls the distance
 after  which the electron-electron interaction goes to zero. A warning will
 be  written  if the value is too large and will cause spurious interactions
 between  images.  The  default  is  half  of the FFT box max dimension in a
 finite direction. 
END

Variable PoissonSolverNodes
Type integer
Section Hamiltonian::Poisson
Default 0
Description
 How  many  nodes  to  use  to solve the Poisson equation. A value of 0, the
 default, implies that all available nodes are used. 
END

Variable PhotonmodesFilename
Type string
Default "photonmodes"
Section Linear Response::Casida
Description
 Filename  for photon modes in text format - first line contains 2 integers:
 number  of  photon modes and number of columns - each further line contains
 the given number of floats for one photon mode 
END

Variable PhotonModes
Type block
Section Hamiltonian::XC
Description
 Each  line  of  the block should specify one photon mode. The syntax is the
 following: 

 %PhotonModes omega1 | lambda1| PolX1 | PolY1 | PolZ1 ... % 

 The  first  column  is  the  mode frequency, in units of energy. The second
 column  is the coupling strength, in units of energy. The remaining columns
 specify  the polarization direction of the mode. If the polarization vector
 should  be  normalized  to  one.  If  that  is  not  the case the code will
 normalize it. 
END

Variable TDPhotonicTimeScale
Type float
Default 1.0
Section Time-Dependent::Propagation
Description
 This  variable  defines  the  factor  between the timescale of photonic and
 electronic  movement.  for  more  details  see  the  documentation  of
 TDIonicTimeScale  If  you  also  use  TDIonicTimeScale,  we  advise  to set
 TDPhotonicTimeScale = TDIonicTimeScale, in the case the photon frequency is
 in  a vibrational energy range. Important: The electronic time step will be
 the value of 
 TDTimeStep  divided  by this variable, so if you have determined an optimal
 electronic  time  step (that we can call _dte_), it is recommended that you
 define your time step as: 

 TDTimeStep = _dte_ * TDPhotonicTimeScale 

 so  you  will  always  use  the  optimal  electronic  time  step  (<a
 href=http://arxiv.org/abs/0710.3321>more details</a>). 
END

Variable PoissonSolverPSolverParallelData
Type logical
Section Hamiltonian::Poisson::PSolver
Default yes
Description
 Indicates  whether  data is partitioned within the PSolver library. If data
 is  distributed among processes, Octopus uses parallel data-structures and,
 thus,  less  memory.  If  "yes",  data is parallelized. The _z_-axis of the
 input  vector  is  split among the MPI processes. If "no", entire input and
 output  vector  is  saved  in  all  the  MPI  processes.  If  k-points
 parallelization is used, "no" must be selected. 
END

Variable TDSystemPropagator
Type integer
Default static
Section Time-Dependent::Propagation
Description
 A  variable  to  set the propagator in the multisystem framework. This is a
 temporary solution, and should be replaced by the TDPropagator variable. 
Option static 0
 (Experimental) Do not propagate the system in time. 
Option verlet 1
 (Experimental) Verlet propagator. 
Option beeman 2
 (Experimental) Beeman propagator without predictor-corrector. 
Option beeman_scf 3
 (Experimental) Beeman propagator with predictor-corrector scheme. 
Option exp_mid 4
 (Experimental) Exponential midpoint propagator without predictor-corrector.
 
Option exp_mid_scf 5
 (Experimental)  Exponential  midpoint  propagator  with predictor-corrector
 scheme. 
END

Variable InteractionTiming
Type integer
Default timing_exact
Section Time-Dependent::Propagation
Description
 A  parameter  to determine if interactions should use the quantities at the
 exact time or if retardation is allowed. 
Option timing_exact 1
 Only allow interactions at exactly the same times 
Option timing_retarded 2
 Allow retarded interactions 
END

