@node Input Variables,,,
@chapter Input Variables

@code{octopus} has quite a few options, that we will subdivide in different groups.
After the name of the option, its type and default value (when applicable)
are given in parenthesis.
@node Atomic Orbitals,,,
@section Atomic Orbitals
@c ----------------------------------

@itemize
@item @strong{AOLoewdin}@*
@vindex @code{AOLoewdin}@*
@emph{Section}: Atomic Orbitals@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* This option determines if the atomic orbital basis is orthogonalized or not.
 This is done for using the Loewdin orthogonalization scheme.
 The default is set to no for the moment as this option is
 not yet implemented for isolated systems, and seems to lead to important egg-box effect



@c ----------------------------------
@item @strong{AONormalize}@*
@vindex @code{AONormalize}@*
@emph{Section}: Atomic Orbitals@*
@emph{Type}: logical@*
@emph{Default}: yes@*
@* If set to yes, Octopus will normalize the atomic orbitals individually.
 This variable is ignored is @t{AOLoewdin<\tt> is set to yes.



@c ----------------------------------
@item @strong{AOSubmesh}@*
@vindex @code{AOSubmesh}@*
@emph{Section}: Atomic Orbitals@*
@emph{Type}: logical@*
@* If set to yes, Octopus will use submeshes to internally store the orbitals with
 their phase instead of storing them on the mesh. This is usually slower for small
 periodic systems, but becomes advantageous for large supercells.
 Submeshes are not compatible with Loewdin orthogonalization.
 For periodic systems, the default is set to no, whereas it is set to yes for isolated systems.



@c ----------------------------------
@item @strong{AOThreshold}@*
@vindex @code{AOThreshold}@*
@emph{Section}: Atomic Orbitals@*
@emph{Type}: float@*
@emph{Default}: 0.01@*
@* Determines the threshold used to compute the radius of the atomic orbitals for LDA+U and for Wannier90.
 This radius is computed by making sure that the
 absolute value of the radial part of the atomic orbital is below the specified threshold.
 This value should be converged to be sure that results do not depend on this value.
 However increasing this value increases the number of grid points covered by the orbitals and directly affect performances.



@c ----------------------------------
@item @strong{AOTruncation}@*
@vindex @code{AOTruncation}@*
@emph{Section}: Atomic Orbitals@*
@emph{Type}: flag@*
@emph{Default}: ao_full@*
@* This option determines how Octopus will truncate the orbitals used for LDA+U.
 Except for the full method, the other options are only there to get a quick idea.


@emph{Options}:
@itemize @minus
@item @strong{ao_full}:  The full size of the orbitals used. The radius is controled by variable AOThreshold.
@item @strong{ao_box}:  The radius of the orbitals are restricted to the size of the simulation box.
 This reduces the number of points used to discretize the orbitals.
 This is mostly a debug option, and one should be aware that changing the size of the simulation box
 will affect the result of the calculation. It is recommended to use ao_nlradius instead.
@item @strong{ao_nlradius}:  The radius of the orbitals are restricted to the radius of the non-local part of the pseudopotential
 of the corresponding atom.
@end itemize

@c ----------------------------------
@end itemize
@node Calculation Modes,,,
@section Calculation Modes
@c ----------------------------------

@itemize
@item @strong{CalculationMode}@*
@vindex @code{CalculationMode}@*
@emph{Section}: Calculation Modes@*
@emph{Type}: integer@*
@emph{Default}: gs@*
@* Decides what kind of calculation is to be performed.


@emph{Options}:
@itemize @minus
@item @strong{gs}:  Calculation of the ground state.
@item @strong{unocc}:  Calculation of unoccupied/virtual KS states. Can also be used for a non-self-consistent
 calculation of states at arbitrary k-points, if @t{density.obf} from @t{gs}
 is provided in the @t{restart/gs} directory.
@item @strong{td}:  Time-dependent calculation (experimental for periodic systems).
@item @strong{go}:  Optimization of the geometry.
@item @strong{opt_control}:  Optimal control.
@item @strong{em_resp}:  Calculation of the electromagnetic response: electric
 polarizabilities and hyperpolarizabilities and magnetic
 susceptibilities (experimental for periodic systems).
@item @strong{casida}:  Excitations via Casida linear-response TDDFT; for finite systems only.
@item @strong{vdw}:  Calculate van der Waals coefficients.
@item @strong{vib_modes}:  Calculation of the vibrational modes.
@item @strong{one_shot}:  Obsolete. Use @t{gs} with @t{MaximumIter = 0} instead.
@item @strong{kdotp}:  Calculation of effective masses by \(\vec{k} \cdot \vec{p}\) perturbation theory (experimental).
@item @strong{dummy}:  This calculation mode does nothing. Useful for debugging, testing and benchmarking.
@item @strong{invert_ks}:  Invert the Kohn-Sham equations (experimental).
@item @strong{recipe}:  Prints out a tasty recipe.
@end itemize

@c ----------------------------------
@end itemize
@node Geometry Optimization,,,
@subsection Geometry Optimization
@c ----------------------------------

@itemize
@item @strong{GOCenter}@*
@vindex @code{GOCenter}@*
@emph{Section}: Calculation Modes::Geometry Optimization@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* (Experimental) If set to yes, Octopus centers the geometry at
 every optimization step. It also reduces the degrees of
 freedom of the optimization by using the translational
 invariance.



@c ----------------------------------
@item @strong{GOConstrains}@*
@vindex @code{GOConstrains}@*
@emph{Section}: Calculation Modes::Geometry Optimization@*
@emph{Type}: block@*
@* If @t{XYZGOConstrains}, @t{PDBConstrains}, and @t{XSFGOConstrains}
 are not present, @t{Octopus} will try to fetch the geometry optimization
 contrains from this block. If this block is not present, @t{Octopus}
 will not set any constrains. The format of this block can be
 illustrated by this example:

 @t{%GOConstrains
 @*@ @ 'C'  |      1 | 0 | 0
 @*@ @ 'O'  | @ 1 | 0 | 0
 @*%}

 Coordinates with a constrain value of 0 will be optimized, while
 coordinates with a constrain different from zero will be kept fixed. So,
 in this example the x coordinates of both atoms will remain fixed and the
 distance between the two atoms along the x axis will be constant.

 Note: It is important for the constrains to maintain the ordering
 in which the atoms were defined in the coordinates specifications.
 Moreover, constrains impose fixed absolute coordinates, therefore
 constrains are not compatible with GOCenter = yes



@c ----------------------------------
@item @strong{GOFireIntegrator}@*
@vindex @code{GOFireIntegrator}@*
@emph{Section}: Calculation Modes::Geometry Optimization@*
@emph{Type}: integer@*
@emph{Default}: verlet@*
@* The Fire algorithm (@t{GOMethod = fire}) uses a molecular dynamics
 integrator to compute new geometries and velocities.
 Currently, two integrator schemes can be selected


@emph{Options}:
@itemize @minus
@item @strong{euler}:  The Euler method.
@item @strong{verlet}:  The Velocity Verlet algorithm.
@end itemize

@c ----------------------------------
@item @strong{GOFireMass}@*
@vindex @code{GOFireMass}@*
@emph{Section}: Calculation Modes::Geometry Optimization@*
@emph{Type}: float@*
@emph{Default}: 1.0 amu@*
@* The Fire algorithm (@t{GOMethod = fire}) assumes that all degrees of freedom
 are comparable. All the velocities should be on the same
 scale,  which  for  heteronuclear  systems  can  be  roughly
 achieved by setting all the atom masses equal, to the value
 specified by this variable.
 By default the mass of a proton is selected (1 amu).
 However, a selection of @t{GOFireMass = 0.01} can, in manys systems,
 speed up the geometry optimization procedure.
 If @t{GOFireMass} <= 0, the masses of each
 species will be used.



@c ----------------------------------
@item @strong{GOLineTol}@*
@vindex @code{GOLineTol}@*
@emph{Section}: Calculation Modes::Geometry Optimization@*
@emph{Type}: float@*
@emph{Default}: 0.1@*
@* Tolerance for line-minimization. Applies only to GSL methods
 that use the forces.
 WARNING: in some weird units.



@c ----------------------------------
@item @strong{GOMaxIter}@*
@vindex @code{GOMaxIter}@*
@emph{Section}: Calculation Modes::Geometry Optimization@*
@emph{Type}: integer@*
@emph{Default}: 200@*
@* Even if the convergence criterion is not satisfied, the minimization will stop
 after this number of iterations.



@c ----------------------------------
@item @strong{GOMethod}@*
@vindex @code{GOMethod}@*
@emph{Section}: Calculation Modes::Geometry Optimization@*
@emph{Type}: integer@*
@emph{Default}: fire@*
@* Method by which the minimization is performed. For more information see the
 <a href=http://www.gnu.org/software/gsl/manual/html_node/Multidimensional-Minimization.html>
 GSL documentation</a>.


@emph{Options}:
@itemize @minus
@item @strong{steep_native}:  (Experimental) Non-gsl implementation of steepest descent.
@item @strong{steep}:  Simple steepest descent.
@item @strong{cg_fr}:  Fletcher-Reeves conjugate-gradient algorithm. The
 conjugate-gradient algorithm proceeds as a succession of line
 minimizations. The sequence of search directions is used to build
 up an approximation to the curvature of the function in the
 neighborhood of the minimum.
@item @strong{cg_pr}:  Polak-Ribiere conjugate-gradient algorithm.
@item @strong{cg_bfgs}:  Vector Broyden-Fletcher-Goldfarb-Shanno (BFGS) conjugate-gradient algorithm.
 It is a quasi-Newton method which builds up an approximation to the second
 derivatives of the function @emph{f} using the difference between successive gradient
 vectors.  By combining the first and second derivatives, the algorithm is able
 to take Newton-type steps towards the function minimum, assuming quadratic
 behavior in that region.
@item @strong{cg_bfgs2}:  The bfgs2 version of this minimizer is the most efficient version available,
 and is a faithful implementation of the line minimization scheme described in
 Fletcher, @emph{Practical Methods of Optimization}, Algorithms 2.6.2 and 2.6.4.
@item @strong{simplex}:  This is experimental, and in fact, @strong{not} recommended unless you just want to
 fool around. It is the Nead-Melder simplex algorithm, as implemented in the
 GNU Scientific Library (GSL). It does not make use of the gradients (@emph{i.e.}, the
 forces) which makes it less efficient than other schemes. It is included here
 for completeness, since it is free.
@item @strong{fire}:  The FIRE algorithm. See also @t{GOFireMass} and @t{GOFireIntegrator}.
 Ref: E. Bitzek, P. Koskinen, F. Gahler, M. Moseler, and P. Gumbsch, @emph{Phys. Rev. Lett.} @strong{97}, 170201 (2006).
@end itemize

@c ----------------------------------
@item @strong{GOMinimumMove}@*
@vindex @code{GOMinimumMove}@*
@emph{Section}: Calculation Modes::Geometry Optimization@*
@emph{Type}: float@*
@* Convergence criterion, for stopping the minimization. In
 units of length; minimization is stopped when the coordinates
 of all species change less than @t{GOMinimumMove}, or the
 @t{GOTolerance} criterion is satisfied.
 If @t{GOMinimumMove < 0}, this criterion is ignored.
 Default is -1, except 0.001 b with @t{GOMethod = simplex}.
 Note that if you use @t{GOMethod = simplex},
 then you must supply a non-zero @t{GOMinimumMove}.



@c ----------------------------------
@item @strong{GOObjective}@*
@vindex @code{GOObjective}@*
@emph{Section}: Calculation Modes::Geometry Optimization@*
@emph{Type}: integer@*
@emph{Default}: minimize_energy@*
@* This rather esoteric option allows one to choose which
 objective function to minimize during a geometry
 minimization. The use of this variable may lead to
 inconsistencies, so please make sure you know what you are
 doing.


@emph{Options}:
@itemize @minus
@item @strong{minimize_energy}:  Use the total energy as objective function.
@item @strong{minimize_forces}:  Use \(\sqrt{\sum_i \left| f_i \right|^2}\) as objective function.
 Note that in this case one still uses the forces as the gradient of the objective function.
 This is, of course, inconsistent, and may lead to very strange behavior.
@end itemize

@c ----------------------------------
@item @strong{GOStep}@*
@vindex @code{GOStep}@*
@emph{Section}: Calculation Modes::Geometry Optimization@*
@emph{Type}: float@*
@* Initial step for the geometry optimizer. The default is 0.5.
 WARNING: in some weird units.
 For the FIRE minimizer, default value is 0.1 fs,
 and corresponds to the initial time-step for the MD.



@c ----------------------------------
@item @strong{GOTolerance}@*
@vindex @code{GOTolerance}@*
@emph{Section}: Calculation Modes::Geometry Optimization@*
@emph{Type}: float@*
@emph{Default}: 0.001 H/b (0.051 eV/A)@*
@* Convergence criterion, for stopping the minimization. In
 units of force; minimization is stopped when all forces on
 ions are smaller than this criterion, or the
 @t{GOMinimumMove} is satisfied. If @t{GOTolerance < 0},
 this criterion is ignored.



@c ----------------------------------
@item @strong{PDBGOConstrains}@*
@vindex @code{PDBGOConstrains}@*
@emph{Section}: Calculation Modes::Geometry Optimization@*
@emph{Type}: string@*
@* Like @t{XYZGOConstrains} but in PDB format, as in @t{PDBCoordinates}.



@c ----------------------------------
@item @strong{XSFGOConstrains}@*
@vindex @code{XSFGOConstrains}@*
@emph{Section}: Calculation Modes::Geometry Optimization@*
@emph{Type}: string@*
@* Like @t{XYZGOConstrains} but in XCrySDen format, as in @t{XSFCoordinates}.



@c ----------------------------------
@item @strong{XYZGOConstrains}@*
@vindex @code{XYZGOConstrains}@*
@emph{Section}: Calculation Modes::Geometry Optimization@*
@emph{Type}: string@*
@* @t{Octopus} will try to read the coordinate-dependent constrains from the XYZ file
 specified by the variable @t{XYZGOConstrains}.
 Note: It is important for the contrains to maintain the ordering
 in which the atoms were defined in the coordinates specifications.
 Moreover, constrains impose fixed absolute coordinates, therefore
 constrains are not compatible with GOCenter = yes



@c ----------------------------------
@end itemize
@node Invert KS,,,
@subsection Invert KS
@c ----------------------------------

@itemize
@item @strong{InvertKSConvAbsDens}@*
@vindex @code{InvertKSConvAbsDens}@*
@emph{Section}: Calculation Modes::Invert KS@*
@emph{Type}: float@*
@emph{Default}: 1e-5@*
@* Absolute difference between the calculated and the target density in the KS
 inversion. Has to be larger than the convergence of the density in the SCF run.



@c ----------------------------------
@item @strong{InvertKSGodbyMu}@*
@vindex @code{InvertKSGodbyMu}@*
@emph{Section}: Calculation Modes::Invert KS@*
@emph{Type}: float@*
@emph{Default}: 1.0@*
@* prefactor for iterative KS inversion convergence scheme from Godby based on van Leeuwen scheme



@c ----------------------------------
@item @strong{InvertKSGodbyPower}@*
@vindex @code{InvertKSGodbyPower}@*
@emph{Section}: Calculation Modes::Invert KS@*
@emph{Type}: float@*
@emph{Default}: 0.05@*
@* power to which density is elevated for iterative KS inversion convergence
 scheme from Godby based on van Leeuwen scheme



@c ----------------------------------
@item @strong{InvertKSMaxIter}@*
@vindex @code{InvertKSMaxIter}@*
@emph{Section}: Calculation Modes::Invert KS@*
@emph{Type}: integer@*
@emph{Default}: 200@*
@* Selects how many iterations of inversion will be done in the iterative scheme



@c ----------------------------------
@item @strong{InvertKSStellaAlpha}@*
@vindex @code{InvertKSStellaAlpha}@*
@emph{Section}: Calculation Modes::Invert KS@*
@emph{Type}: float@*
@emph{Default}: 0.05@*
@* prefactor term in iterative scheme from L Stella



@c ----------------------------------
@item @strong{InvertKSStellaBeta}@*
@vindex @code{InvertKSStellaBeta}@*
@emph{Section}: Calculation Modes::Invert KS@*
@emph{Type}: float@*
@emph{Default}: 1.0@*
@* residual term in Stella iterative scheme to avoid 0 denominators



@c ----------------------------------
@item @strong{InvertKSTargetDensity}@*
@vindex @code{InvertKSTargetDensity}@*
@emph{Section}: Calculation Modes::Invert KS@*
@emph{Type}: string@*
@emph{Default}: @t{target_density.dat}@*
@* Name of the file that contains the density used as the target in the
 inversion of the KS equations.



@c ----------------------------------
@item @strong{InvertKSVerbosity}@*
@vindex @code{InvertKSVerbosity}@*
@emph{Section}: Calculation Modes::Invert KS@*
@emph{Type}: integer@*
@* Selects what is output during the calculation of the KS potential.


@emph{Options}:
@itemize @minus
@item @strong{0}:  Only outputs the converged density and KS potential.
@item @strong{1}:  Same as 0 but outputs the maximum difference to the target density in each
 iteration in addition.
@item @strong{2}:  Same as 1 but outputs the density and the KS potential in each iteration in
 addition.
@end itemize

@c ----------------------------------
@item @strong{InvertKSmethod}@*
@vindex @code{InvertKSmethod}@*
@emph{Section}: Calculation Modes::Invert KS@*
@emph{Type}: integer@*
@emph{Default}: iterative@*
@* Selects whether the exact two-particle method or the iterative scheme
 is used to invert the density to get the KS potential.


@emph{Options}:
@itemize @minus
@item @strong{two_particle}:  Exact two-particle scheme.
@item @strong{iterative}:  Iterative scheme for \(v_s\).
@item @strong{iter_stella}:  Iterative scheme for \(v_s\) using Stella and Verstraete method.
@item @strong{iter_godby}:  Iterative scheme for \(v_s\) using power method from Rex Godby.
@end itemize

@c ----------------------------------
@item @strong{KSInversionAsymptotics}@*
@vindex @code{KSInversionAsymptotics}@*
@emph{Section}: Calculation Modes::Invert KS@*
@emph{Type}: integer@*
@emph{Default}: xc_asymptotics_none@*
@* Asymptotic correction applied to \(v_{xc}\).


@emph{Options}:
@itemize @minus
@item @strong{xc_asymptotics_none}:  Do not apply any correction in the asymptotic region.
@item @strong{xc_asymptotics_sc}:  Applies the soft-Coulomb decay of \(-1/\sqrt{r^2+1}\) to \(v_{xc}\) in the asymptotic region.
@end itemize

@c ----------------------------------
@item @strong{KSInversionLevel}@*
@vindex @code{KSInversionLevel}@*
@emph{Section}: Calculation Modes::Invert KS@*
@emph{Type}: integer@*
@emph{Default}: ks_inversion_adiabatic@*
@* At what level @t{Octopus} shall handle the KS inversion.


@emph{Options}:
@itemize @minus
@item @strong{ks_inversion_none}:  Do not compute KS inversion.
@item @strong{ks_inversion_adiabatic}:  Compute exact adiabatic \(v_{xc}\).
@end itemize

@c ----------------------------------
@end itemize
@node Optimal Control,,,
@subsection Optimal Control
@c ----------------------------------

@itemize
@item @strong{OCTCheckGradient}@*
@vindex @code{OCTCheckGradient}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* When doing QOCT with the conjugate-gradient optimization scheme, the gradient is
 computed thanks to a forward-backwards propagation. For debugging purposes, this
 gradient can be compared with the value obtained "numerically" (@emph{i.e.} by doing
 successive forward propagations with control fields separated by small finite
 differences).

 In order to activate this feature, set @t{OCTCheckGradient} to some non-zero value,
 which will be the finite difference used to numerically compute the gradient.



@c ----------------------------------
@item @strong{OCTClassicalTarget}@*
@vindex @code{OCTClassicalTarget}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: block@*
@* If @t{OCTTargetOperator = oct_tg_classical}, the you must supply this block.
 It should contain a string (e.g. "(q[1,1]-q[1,2])*p[2,1]") with a mathematical
 expression in terms of two arrays, q and p, that represent the position and momenta
 of the classical variables. The first index runs through the various classical particles,
 and the second index runs through the spatial dimensions.

 In principle, the block only contains one entry (string). However, if the expression is very
 long, you can split it into various lines (one column each) that will be concatenated.

 The QOCT algorithm will attempt to maximize this expression, at the end of the propagation.



@c ----------------------------------
@item @strong{OCTControlFunctionOmegaMax}@*
@vindex @code{OCTControlFunctionOmegaMax}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: float@*
@emph{Default}: -1.0@*
@* The Fourier series that can be used to represent the control functions must be truncated;
 the truncation is given by a cut-off frequency which is determined by this variable.



@c ----------------------------------
@item @strong{OCTControlFunctionRepresentation}@*
@vindex @code{OCTControlFunctionRepresentation}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: integer@*
@emph{Default}: control_fourier_series_h@*
@* If @t{OCTControlRepresentation = control_function_parametrized}, one must
 specify the kind of parameters that determine the control function.
 If @t{OCTControlRepresentation = control_function_real_time}, then this variable
 is ignored, and the control function is handled directly in real time.


@emph{Options}:
@itemize @minus
@item @strong{control_fourier_series_h}:  The control function is expanded as a full Fourier series (although it must, of
 course, be a real function). Then, the total fluence is fixed, and a transformation
 to hyperspherical coordinates is done; the parameters to optimize are the hyperspherical
 angles.
@item @strong{control_zero_fourier_series_h}:  The control function is expanded as a Fourier series, but assuming (1) that the zero
 frequency component is zero, and (2) the control function, integrated in time, adds
 up to zero (this essentially means that the sum of all the cosine coefficients is zero).
 Then, the total fluence is fixed, and a transformation to hyperspherical coordinates is
 done; the parameters to optimize are the hyperspherical angles.
@item @strong{control_fourier_series}:  The control function is expanded as a full Fourier series (although it must, of
 course, be a real function). The control parameters are the coefficients of this
 basis-set expansion.
@item @strong{control_zero_fourier_series}:  The control function is expanded as a full Fourier series (although it must, of
 course, be a real function). The control parameters are the coefficients of this
 basis-set expansion. The difference with the option @t{control_fourier_series} is that
 (1) that the zero-frequency component is zero, and (2) the control function, integrated
 in time, adds up to zero (this essentially means that the sum of all the cosine
 coefficients is zero).
@item @strong{control_rt}:  (experimental)
@end itemize

@c ----------------------------------
@item @strong{OCTControlFunctionType}@*
@vindex @code{OCTControlFunctionType}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: integer@*
@emph{Default}: controlfunction_mode_epsilon@*
@* The control function may fully determine the time-dependent form of the
 external field, or only the envelope function of this external field, or its phase.
 Or, we may have two different control functions, one of them providing the phase
 and the other one, the envelope.

 Note that, if @t{OCTControlRepresentation = control_function_real_time}, then the control
 function must @strong{always} determine the full external field (THIS NEEDS TO BE FIXED).


@emph{Options}:
@itemize @minus
@item @strong{controlfunction_mode_epsilon}:  In this case, the control function determines the full control function: namely,
 if we are considering the electric field of a laser, the time-dependent electric field.
@item @strong{controlfunction_mode_f}:  The optimization process attempts to find the best possible envelope. The full
 control field is this envelope times a cosine function with a "carrier" frequency.
 This carrier frequency is given by the carrier frequency of the @t{TDExternalFields}
 in the @t{inp} file.
@end itemize

@c ----------------------------------
@item @strong{OCTCurrentFunctional}@*
@vindex @code{OCTCurrentFunctional}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: integer@*
@emph{Default}: oct_no_curr@*
@* (Experimental) The variable @t{OCTCurrentFunctional} describes which kind of
 current target functional \(J1_c[j]\) is to be used.


@emph{Options}:
@itemize @minus
@item @strong{oct_no_curr}:  No current functional is used, no current calculated.
@item @strong{oct_curr_square}:  Calculates the square of current \(j\):
 \(J1_c[j] = {\tt OCTCurrentWeight} \int{\left| j(r) \right|^2 dr}\).
 For @t{OCTCurrentWeight} < 0, the current will be minimized (useful in combination with
 target density in order to obtain stable final target density), while for
 @t{OCTCurrentWeight} > 0, it will be maximized (useful in combination with a target density
 in order to obtain a high-velocity impact, for instance). It is a static target, to be reached at
 total time.
@item @strong{oct_max_curr_ring}:  Maximizes the current of a quantum ring in one direction. The functional maximizes the \(z\) projection of the
 outer product between the position \(\vec{r}\) and the current \(\vec{j}\):
 \(J1[j] = {\tt OCTCurrentWeight} \int{(\vec{r} \times \vec{j}) \cdot \hat{z} dr}\).
 For @t{OCTCurrentWeight} > 0, the
 current flows in counter-clockwise direction, while for @t{OCTCurrentWeight} < 0, the current is clockwise.
@item @strong{oct_curr_square_td}:  The time-dependent version of @t{oct_curr_square}. In fact, calculates the
 square of current in time interval [@t{OCTStartTimeCurrTg},
 total time = @t{TDMaximumIter} * @t{TDTimeStep}].
 Set @t{TDPropagator} = @t{crank_nicolson}.
@end itemize

@c ----------------------------------
@item @strong{OCTCurrentWeight}@*
@vindex @code{OCTCurrentWeight}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* In the case of simultaneous optimization of density \(n\) and current \(j\), one can tune the importance
 of the current functional \(J1_c[j]\), as the respective functionals might not provide results on the
 same scale of magnitude. \(J1[n,j]= J1_d[n]+ {\tt OCTCurrentWeight}\ J1_c[j]\). Be aware that its
 sign is crucial for the chosen @t{OCTCurrentFunctional} as explained there.



@c ----------------------------------
@item @strong{OCTDelta}@*
@vindex @code{OCTDelta}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* If @t{OCTScheme = oct_mt03}, then you can supply the "eta" and "delta" parameters
 described in [Y. Maday and G. Turinici, @emph{J. Chem. Phys.} @strong{118}, 8191 (2003)], using the
 @t{OCTEta} and @t{OCTDelta} variables.



@c ----------------------------------
@item @strong{OCTDirectStep}@*
@vindex @code{OCTDirectStep}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: float@*
@emph{Default}: 0.25@*
@* If you choose @t{OCTScheme = oct_direct} or @t{OCTScheme = oct_nlopt_bobyqa},
 the algorithms necessitate an initial "step" to perform the direct search for the
 optimal value. The precise meaning of this "step" differs.



@c ----------------------------------
@item @strong{OCTDoubleCheck}@*
@vindex @code{OCTDoubleCheck}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* In order to make sure that the optimized field indeed does its job, the code
 may run a normal propagation after the optimization using the optimized field.



@c ----------------------------------
@item @strong{OCTDumpIntermediate}@*
@vindex @code{OCTDumpIntermediate}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* Writes to disk the laser pulse data during the OCT algorithm at intermediate steps.
 These are files called @t{opt_control/laser.xxxx}, where @t{xxxx} is the iteration number.



@c ----------------------------------
@item @strong{OCTEps}@*
@vindex @code{OCTEps}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: float@*
@emph{Default}: 1.0e-6@*
@* Define the convergence threshold. It computes the difference between the "input"
 field in the iterative procedure, and the "output" field. If this difference is
 less than @t{OCTEps} the iteration is stopped. This difference is defined as:

 \(
 D[\varepsilon^{in},\varepsilon^{out}] = \int_0^T dt \left| \varepsilon^{in}(t)-\varepsilon^{out}(t)\right|^2
 \)

 (If there are several control fields, this difference is defined as the sum over
 all the individual differences.)

 Whenever this condition is satisfied, it means that we have reached a solution point
 of the QOCT equations, @emph{i.e.} a critical point of the QOCT functional (not
 necessarily a maximum, and not necessarily the global maximum).



@c ----------------------------------
@item @strong{OCTEta}@*
@vindex @code{OCTEta}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: float@*
@emph{Default}: 1.0@*
@* If @t{OCTScheme = oct_mt03}, then you can supply the "eta" and "delta" parameters
 described in [Y. Maday and G. Turinici, @emph{J. Chem. Phys.} @strong{118}, 8191 (2003)], using the
 @t{OCTEta} and @t{OCTDelta} variables.



@c ----------------------------------
@item @strong{OCTExcludedStates}@*
@vindex @code{OCTExcludedStates}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: string@*
@* If the target is the exclusion of several targets, ("OCTTargetOperator = oct_exclude_states")
 then you must declare which states are to be excluded, by setting the OCTExcludedStates variable.
 It must be a string in "list" format: "1-8", or "2,3,4-9", for example. Be careful to include
 in this list only states that have been calculated in a previous "gs" or "unocc" calculation,
 or otherwise the error will be silently ignored.



@c ----------------------------------
@item @strong{OCTFilter}@*
@vindex @code{OCTFilter}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: block@*
@* The block @t{OCTFilter} describes the type and shape of the filter function
 that are applied to the optimized laser field in each iteration.
 The filter forces the laser field to obtain the given form in frequency space.
 Each line of the block describes a filter; this way you can actually have more
 than one filter function (@emph{e.g.} a filter in time and two in frequency space).
 The filters are applied in the given order, @emph{i.e.}, first the filter specified
 by the first line is applied, then second line.
 The syntax of each line is, then:

 @t{%OCTFilter
 @*@ @ domain | function
 @*%}


 Possible arguments for domain are:

 (i) @t{frequency_filter}: Specifies a spectral filter.

 (ii) @t{time_filter}: DISABLED IN THIS VERSION.

 Example:

 @t{%OCTFilter
 @*@ @ time | "exp(-80*( w + 0.1567 )^2  ) + exp(-80*( w - 0.1567 )^2  )"
 @*%}

 Be careful that also the negative-frequency component is filtered since the resulting
 field has to be real-valued.



@emph{Options}:
@itemize @minus
@item @strong{frequency_filter}:  The filter is applied in the frequency domain.
@end itemize

@c ----------------------------------
@item @strong{OCTFixFluenceTo}@*
@vindex @code{OCTFixFluenceTo}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* The algorithm tries to obtain the specified fluence for the laser field.
 This works only in conjunction with either the WG05 or the straight iteration scheme.

 If this variable is not present in the input file, by default the code will not
 attempt a fixed-fluence QOCT run. The same holds if the value given to this
 variable is exactly zero.

 If this variable is given a negative value, then the target fluence will be that of
 the initial laser pulse given as guess in the input file. Note, however, that
 first the code applies the envelope provided by the @t{OCTLaserEnvelope} input
 option, and afterwards it calculates the fluence.



@c ----------------------------------
@item @strong{OCTFixInitialFluence}@*
@vindex @code{OCTFixInitialFluence}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: logical@*
@emph{Default}: yes@*
@* By default, when asking for a fixed-fluence optimization (@t{OCTFixFluenceTo = whatever}),
 the initial laser guess provided in the input file is scaled to match this
 fluence. However, you can force the program to use that initial laser as the initial
 guess, no matter the fluence, by setting @t{OCTFixInitialFluence = no}.



@c ----------------------------------
@item @strong{OCTHarmonicWeight}@*
@vindex @code{OCTHarmonicWeight}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: string@*
@emph{Default}: "1"@*
@* (Experimental) If @t{OCTTargetOperator = oct_tg_plateau}, then the function to optimize is the integral of the
 harmonic spectrum \(H(\omega)\), weighted with a function \(f(\omega)\)
 that is defined as a string here. For example, if
 you set @t{OCTHarmonicWeight  = "step(w-1)"}, the function to optimize is
 the integral of \(step(\omega-1)*H(\omega)\), @emph{i.e.}
 \(\int_1^{\infty} H \left( \omega \right) d\omega\).
 In practice, it is better if you also set an upper limit, @emph{e.g.}
 \(f(\omega) = step(\omega-1) step(2-\omega)\).



@c ----------------------------------
@item @strong{OCTInitialState}@*
@vindex @code{OCTInitialState}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: integer@*
@emph{Default}: oct_is_groundstate@*
@* Describes the initial state of the quantum system.
 Possible arguments are:


@emph{Options}:
@itemize @minus
@item @strong{oct_is_groundstate}:  Start in the ground state.
@item @strong{oct_is_excited}:  Currently not in use.
@item @strong{oct_is_gstransformation}:  Start in a transformation of the ground-state orbitals, as defined in the
 block @t{OCTInitialTransformStates}.
@item @strong{oct_is_userdefined}:  Start in a user-defined state.
@end itemize

@c ----------------------------------
@item @strong{OCTInitialTransformStates}@*
@vindex @code{OCTInitialTransformStates}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: block@*
@* If @t{OCTInitialState = oct_is_gstransformation}, you must specify an
 @t{OCTInitialTransformStates} block, in order to specify which linear
 combination of the states present in @t{restart/gs} is used to
 create the initial state.

 The syntax is the same as the @t{TransformStates} block.



@c ----------------------------------
@item @strong{OCTInitialUserdefined}@*
@vindex @code{OCTInitialUserdefined}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: block@*
@* Define an initial state. Syntax follows the one of the @t{UserDefinedStates} block.
 Example:

 @t{%OCTInitialUserdefined
 @*@ @  1 | 1 | 1 |  "exp(-r^2)*exp(-i*0.2*x)"
 @*%}




@c ----------------------------------
@item @strong{OCTLaserEnvelope}@*
@vindex @code{OCTLaserEnvelope}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: block@*
@* Often a pre-defined time-dependent envelope on the control function is desired.
 This can be achieved by making the penalty factor time-dependent.
 Here, you may specify the required time-dependent envelope.

 It is possible to choose different envelopes for different control functions.
 There should be one line for each control function. Each line should
 have only one element: a string with the name of a time-dependent function,
 that should be correspondingly defined in a @t{TDFunctions} block.



@c ----------------------------------
@item @strong{OCTLocalTarget}@*
@vindex @code{OCTLocalTarget}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: string@*
@* If @t{OCTTargetOperator = oct_tg_local}, then one must supply a function
 that defines the target. This should be done by defining it through a string, using
 the variable @t{OCTLocalTarget}.



@c ----------------------------------
@item @strong{OCTMaxIter}@*
@vindex @code{OCTMaxIter}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: integer@*
@emph{Default}: 10@*
@* The maximum number of iterations.
 Typical values range from 10-100.



@c ----------------------------------
@item @strong{OCTMomentumDerivatives}@*
@vindex @code{OCTMomentumDerivatives}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: block@*
@* This block should contain the derivatives of the expression given in
 @t{OCTClassicalTarget} with respect to the p array components.
 Each line corresponds to a different classical particle, whereas the
 columns correspond to each spatial dimension: the (i,j) block component
 corresponds with the derivative wrt p[i,j].



@c ----------------------------------
@item @strong{OCTNumberCheckPoints}@*
@vindex @code{OCTNumberCheckPoints}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: integer@*
@* During an OCT propagation, the code may write the wavefunctions at some time steps (the
 "check points"). When the inverse backward or forward propagation
 is performed in a following step, the wavefunction should reverse its path
 (almost) exactly. This can be checked to make sure that it is the case -- otherwise
 one should try reducing the time-step, or altering in some other way the
 variables that control the propagation.

 If the backward (or forward) propagation is not retracing the steps of the previous
 forward (or backward) propagation, the code will write a warning.



@c ----------------------------------
@item @strong{OCTOptimizeHarmonicSpectrum}@*
@vindex @code{OCTOptimizeHarmonicSpectrum}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: block@*
@emph{Default}: no@*
@* (Experimental)
 If @t{OCTTargetOperator = oct_tg_hhg}, the target is the harmonic emission spectrum.
 In that case, you must supply an @t{OCTOptimizeHarmonicSpectrum} block in the @t{inp}
 file. The target is given, in general, by:

 \(J_1 = \int_0^\infty d\omega \alpha(\omega) H(\omega)\),

 where \(H(\omega)\) is the harmonic spectrum generated by the system, and
 \(\alpha(\omega)\) is some function that determines what exactly we want
 to optimize. The role of the @t{OCTOptimizeHarmonicSpectrum} block is to determine
 this \(\alpha(\omega)\) function. Currently, this function is defined as:

 \(\alpha(\omega) = \sum_{L=1}^{M} \frac{\alpha_L}{a_L} \sqcap( (\omega - L\omega_0)/a_L )\),

 where \(\omega_0\) is the carrier frequency. \(M\) is
 the number of columns in the @t{OCTOptimizeHarmonicSpectrum} block. The values of @emph{L} will be listed
 in the first row of this block; \(\alpha_L\) in the second row, and \(a_L\) in
 the third.

 Example:

 @t{%OCTOptimizeHarmonicSpectrum
 @*@ @   7    |  9    | 11
 @*@ @  -1    |  1    | -1
 @*@ @   0.01 |  0.01 |  0.01
 @*%}




@c ----------------------------------
@item @strong{OCTPenalty}@*
@vindex @code{OCTPenalty}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: float@*
@emph{Default}: 1.0@*
@* The variable specifies the value of the penalty factor for the
 integrated field strength (fluence). Large value = small fluence.
 A transient shape can be specified using the block @t{OCTLaserEnvelope}.
 In this case @t{OCTPenalty} is multiplied with time-dependent function.
 The value depends on the coupling between the states. A good start might be a
 value from 0.1 (strong fields) to 10 (weak fields).

 Note that if there are several control functions, one can specify this
 variable as a one-line code, each column being the penalty factor for each
 of the control functions. Make sure that the number of columns is equal to the
 number of control functions. If it is not a block, all control functions will
 have the same penalty factor.

 All penalty factors must be positive.



@c ----------------------------------
@item @strong{OCTPositionDerivatives}@*
@vindex @code{OCTPositionDerivatives}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: block@*
@* This block should contain the derivatives of the expression given in
 @t{OCTClassicalTarget} with respect to the q array components.
 Each line corresponds to a different classical particle, whereas the
 columns correspond to each spatial dimension: the (i,j) block component
 corresponds with the derivative wrt q[i,j].



@c ----------------------------------
@item @strong{OCTRandomInitialGuess}@*
@vindex @code{OCTRandomInitialGuess}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* The initial field to start the optimization search is usually given in the @t{inp} file,
 through a @t{TDExternalFields} block. However, you can start from a random guess if you
 set this variable to true.

 Note, however, that this is only valid for the "direct" optimization schemes; moreover
 you still need to provide a @t{TDExternalFields} block.



@c ----------------------------------
@item @strong{OCTScheme}@*
@vindex @code{OCTScheme}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: integer@*
@emph{Default}: oct_zbr98@*
@* Optimal Control Theory can be performed with @t{Octopus} with a variety of different
 algorithms. Not all of them can be used with any choice of target or control function
 representation. For example, some algorithms cannot be used if
 @t{OCTControlRepresentation = control_function_real_time}
 (@t{OCTScheme} > @t{oct_straight_iteration}), and others cannot be used
 if @t{OCTControlRepresentation = control_function_parametrized}
 (@t{OCTScheme}  <  @t{oct_straight_iteration}).


@emph{Options}:
@itemize @minus
@item @strong{oct_nlopt_bobyqa}:  The BOBYQA algorithm, as implemented in the NLOPT library -- therefore, octopus has to
 be compiled with it in order to be able to use this option.
 The seed for the random number generator can be modified by setting
 @t{GSL_RNG_SEED} environment variable.
@item @strong{oct_nlopt_lbfgs}:  The local BFGS, as implemented in the NLOPT library -- therefore, octopus has to
 be compiled with it in order to be able to use this option.
 The seed for the random number generator can be modified by setting
 @t{GSL_RNG_SEED} environment variable.
@item @strong{oct_zbr98}:  Backward-Forward-Backward scheme described in @emph{JCP} @strong{108}, 1953 (1998).
 Only possible if target operator is a projection operator.
 Provides fast, stable and monotonic convergence.
@item @strong{oct_zr98}:  Forward-Backward-Forward scheme described in @emph{JCP} @strong{109}, 385 (1998).
 Works for projection and more general target operators also. The convergence is
 stable but slower than ZBR98.
 Note that local operators show an extremely slow convergence. It ensures monotonic
 convergence.
@item @strong{oct_wg05}:  Forward-Backward scheme described in @emph{J. Opt. B.} @strong{7}, 300 (2005).
 Works for all kinds of target operators, can be used with all kinds of filters, and
 allows a fixed fluence.
 The price is a rather unstable convergence.
 If the restrictions set by the filter and fluence are reasonable, a good overlap can be
 expected within 20 iterations.
 No monotonic convergence.
@item @strong{oct_mt03}:  Basically an improved and generalized scheme.
 Comparable to ZBR98/ZR98. See [Y. Maday and G. Turinici, @emph{J. Chem. Phys.} @strong{118}, 8191 (2003)].
@item @strong{oct_krotov}:  The procedure reported in [D. Tannor, V. Kazakov and V.
 Orlov, in @emph{Time-Dependent Quantum Molecular Dynamics}, edited by J. Broeckhove
 and L. Lathouweres (Plenum, New York, 1992), pp. 347-360].
@item @strong{oct_straight_iteration}:  Straight iteration: one forward and one backward propagation is performed at each
 iteration, both with the same control field. An output field is calculated with the
 resulting wavefunctions.
@item @strong{oct_cg}:  Conjugate-gradients, as implemented in the GNU GSL library. In particular, the
 Fletcher-Reeves version.
 The seed for the random number generator can be modified by setting
 @t{GSL_RNG_SEED} environment variable.
@item @strong{oct_bfgs}:  The methods use the vector Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm.
 Also, it calls the GNU GSL library version of the algorithm. It is a quasi-Newton
 method which builds up an approximation to the second derivatives of the function using
 the difference between successive gradient vectors.  By combining the first and second
 derivatives the algorithm is able to take Newton-type steps towards the function minimum,
 assuming quadratic behavior in that region. We have chosen to implement the "bfgs2" version,
 as GSL calls it, which is supposed to be the most efficient version available, and a faithful
 implementation of the line minimization scheme described in "Practical Methods of Optimization",
 (Fletcher), Algorithms 2.6.2 and 2.6.4.
@item @strong{oct_direct}:  This is a "direct" optimization scheme. This means that we do not make use of the
 "usual" QOCT equations (backward-forward propagations, etc), but we use some gradient-free
 maximization algorithm for the function that we want to optimize. In this case, the
 maximization algorithm is the Nelder-Mead algorithm as implemeted in the GSL. The function
 values are obtained by successive forward propagations.
 The seed for the random number generator can be modified by setting
 @t{GSL_RNG_SEED} environment variable.
@end itemize

@c ----------------------------------
@item @strong{OCTSpatialCurrWeight}@*
@vindex @code{OCTSpatialCurrWeight}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: block@*
@* Can be seen as a position-dependent @t{OCTCurrentWeight}. Consequently, it
 weights contribution of current \(j\) to its functional \(J1_c[j]\) according to the position in space.
 For example, @t{oct_curr_square} thus becomes
 \(J1_c[j] = {\tt OCTCurrentWeight} \int{\left| j(r) \right|^2 {\tt OCTSpatialCurrWeight}(r) dr}\).

 It is defined as @t{OCTSpatialCurrWeight}\((r) = g(x) g(y) g(z)\), where
 \(g(x) = \sum_{i} 1/(1+e^{-{\tt fact} (x-{\tt startpoint}_i)}) - 1/(1+e^{-{\tt fact} (x-{\tt endpoint}_i)})\).
 If not specified, \(g(x) = 1\).

 Each \(g(x)\) is represented by one line of the block that has the following form

 @t{%OCTSpatialCurrWeight
 @*@ @   dimension  |  fact |  startpoint_1  | endpoint_1  | startpoint_2 | endpoint_2 |...
 @*%}

 There are no restrictions on the number of lines, nor on the number of pairs of start- and endpoints.
 Attention: @t{startpoint} and @t{endpoint} have to be supplied pairwise
 with @t{startpoint  <  endpoint}. @t{dimension > 0} is integer, @t{fact} is float.



@c ----------------------------------
@item @strong{OCTStartIterCurrTg}@*
@vindex @code{OCTStartIterCurrTg}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: integer@*
@* Allows for a time-dependent target for the current without defining it for the total
 time-interval of the simulation.
 Thus it can be switched on at the iteration desired, @t{OCTStartIterCurrTg} >= 0
 and  @t{OCTStartIterCurrTg}  <  @t{TDMaximumIter}.
 Tip: If you would like to specify a real time for switching
 the functional on rather than the number of steps, just use something
 like:
 @t{OCTStartIterCurrTg} = 100.0 / @t{TDTimeStep}.



@c ----------------------------------
@item @strong{OCTTargetDensity}@*
@vindex @code{OCTTargetDensity}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: string@*
@* If @t{OCTTargetOperator = oct_tg_density}, then one must supply the target density
 that should be searched for. This one can do by supplying a string through
 the variable @t{OCTTargetDensity}. Alternately, give the special string @t{"OCTTargetDensityFromState"}
 to specify the expression via the block @t{OCTTargetDensityFromState}.



@c ----------------------------------
@item @strong{OCTTargetDensityFromState}@*
@vindex @code{OCTTargetDensityFromState}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: block@*
@emph{Default}: no@*
@* If @t{OCTTargetOperator = oct_tg_density}, and @t{OCTTargetDensity = "OCTTargetDensityFromState"},
 you must specify a @t{OCTTargetDensityState} block, in order to specify which linear
 combination of the states present in @t{restart/gs} is used to
 create the target density.

 The syntax is the same as the @t{TransformStates} block.



@c ----------------------------------
@item @strong{OCTTargetOperator}@*
@vindex @code{OCTTargetOperator}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: integer@*
@emph{Default}: oct_tg_gstransformation@*
@* The variable @t{OCTTargetOperator} prescribes which kind of target functional is
 to be used.


@emph{Options}:
@itemize @minus
@item @strong{oct_tg_velocity}:  (Experimental) The target is a function of the velocities of the nuclei at the end of the influence of
 the external field, defined by @t{OCTVelocityTarget}
@item @strong{oct_tg_hhgnew}:  (Experimental) The target is the optimization of the HHG yield. You must supply the
 @t{OCTHarmonicWeight} string. It attempts to optimize the integral of the harmonic spectrum multiplied
 by some user-defined weight function.
@item @strong{oct_tg_classical}:  (Experimental)
@item @strong{oct_tg_spin}:  (Experimental)
@item @strong{oct_tg_groundstate}:  The target operator is a projection operator on the ground state, @emph{i.e.} the
 objective is to populate the ground state as much as possible.
@item @strong{oct_tg_excited}:  (Experimental) The target operator is an "excited state". This means that the target operator
 is a linear combination of Slater determinants, each one formed by replacing
 in the ground-state Slater determinant one occupied state with one excited
 state (@emph{i.e.} "single excitations"). The description of which excitations are
 used, and with which weights, should be given in a file called
 @t{oct-excited-state-target}.
 See the documentation of subroutine @t{excited_states_elec_init} in the source
 code in order to use this feature.
@item @strong{oct_tg_gstransformation}:  The target operator is a projection operator on a transformation of the ground-state
 orbitals defined by the block @t{OCTTargetTransformStates}.
@item @strong{oct_tg_userdefined}:  (Experimental) Allows to define target state by using @t{OCTTargetUserdefined}.
@item @strong{oct_tg_jdensity}:  (Experimental)
@item @strong{oct_tg_local}:  (Experimental) The target operator is a local operator.
@item @strong{oct_tg_td_local}:  (Experimental) The target operator is a time-dependent local operator.
@item @strong{oct_tg_exclude_state}:  (Experimental) Target operator is the projection onto the complement of a given state, given by the
 block @t{OCTTargetTransformStates}. This means that the target operator is the unity
 operator minus the projector onto that state.
@item @strong{oct_tg_hhg}:  (Experimental) The target is the optimization of the HHG yield. You must supply the @t{OCTOptimizeHarmonicSpectrum}
 block, and it attempts to optimize the maximum of the spectrum around each harmonic peak. You may
 use only one of the gradient-less optimization schemes.
@end itemize

@c ----------------------------------
@item @strong{OCTTargetSpin}@*
@vindex @code{OCTTargetSpin}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: block@*
@* (Experimental) Specify the targeted spin as a 3-component vector. It will be normalized.



@c ----------------------------------
@item @strong{OCTTargetTransformStates}@*
@vindex @code{OCTTargetTransformStates}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: block@*
@emph{Default}: no@*
@* If @t{OCTTargetOperator = oct_tg_gstransformation}, you must specify a
 @t{OCTTargetTransformStates} block, in order to specify which linear
 combination of the states present in @t{restart/gs} is used to
 create the target state.

 The syntax is the same as the @t{TransformStates} block.



@c ----------------------------------
@item @strong{OCTTargetUserdefined}@*
@vindex @code{OCTTargetUserdefined}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: block@*
@* Define a target state. Syntax follows the one of the @t{UserDefinedStates} block.
 Example:

 @t{%OCTTargetUserdefined
 @*@ @  1 | 1 | 1 |  "exp(-r^2)*exp(-i*0.2*x)"
 @*%}




@c ----------------------------------
@item @strong{OCTTdTarget}@*
@vindex @code{OCTTdTarget}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: block@*
@* (Experimental) If @t{OCTTargetOperator = oct_tg_td_local}, then you must supply
 a OCTTdTarget block. The block should only contain one element, a string cotaining the
 definition of the time-dependent local target, @emph{i.e.} a function of x,y,z and t that
 is to be maximized along the evolution.



@c ----------------------------------
@item @strong{OCTVelocityDerivatives}@*
@vindex @code{OCTVelocityDerivatives}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: block@*
@* If @t{OCTTargetOperator = oct_tg_velocity}, and
 @t{OCTScheme = oct_cg} or @t{OCTScheme = oct_bfgs}
 then you must supply the target in terms of the ionic velocities AND
 the derivatives of the target with respect to the ionic velocity components.
 The derivatives are supplied via strings through the block
 @t{OCTVelocityDerivatives}.
 Each velocity component is supplied by @t{"v[n_atom,vec_comp]"},
 while @t{n_atom} is the atom number, corresponding to the
 @t{Coordinates} block, and @t{vec_comp} is the corresponding
 vector component of the velocity. The first line of the
 @t{OCTVelocityDerivatives} block contains the derivatives
 with respect to @t{v[1,*]}, the second with respect to @t{v[2,*]} and so
 on. The first column contains all derivatives with respect @t{v[*,1]},
 the second with respect to @t{v[*,2]} and the third w.r.t. @t{v[*,3]}.
 As an example, we show the @t{OCTVelocityDerivatives} block
 corresponding to the target shown in the @t{OCTVelocityTarget}
 help section:

 @t{%OCTVelocityDerivatives
 @* " 2*(v[1,1]-v[2,1])" | " 2*(v[1,2]-v[2,2])" | " 2*(v[1,3]-v[2,3])"
 @* "-2*(v[1,1]-v[2,1])" | "-2*(v[1,2]-v[2,2])" | "-2*(v[1,3]-v[2,3])"
 @*%}




@c ----------------------------------
@item @strong{OCTVelocityTarget}@*
@vindex @code{OCTVelocityTarget}@*
@emph{Section}: Calculation Modes::Optimal Control@*
@emph{Type}: block@*
@* If @t{OCTTargetOperator = oct_tg_velocity}, then one must supply the
 target to optimize in terms of the ionic velocities. This is done by
 supplying a string through the block @t{OCTVelocityTarget}.
 Each velocity component is supplied by @t{"v[n_atom,vec_comp]"},
 where @t{n_atom} is the atom number, corresponding to the
 @t{Coordinates} block, and @t{vec_comp} is the corresponding
 vector component of the velocity. The target string can be
 supplied by using several lines in this block.
 As an example, the following target can be used to maximize the
 velocity difference between atom 1 and 2 (in a 3D system):

 @t{%OCTVelocityTarget
 @* "(v[1,1]-v[2,1])^2 + (v[1,2]-v[2,2])^2 + "
 @* "(v[1,3]-v[2,3])^2"
 @*%}




@c ----------------------------------
@end itemize
@node Test,,,
@subsection Test
@c ----------------------------------

@itemize
@item @strong{InterpolationTestOrder}@*
@vindex @code{InterpolationTestOrder}@*
@emph{Section}: Calculation Modes::Test@*
@emph{Type}: integer@*
@emph{Default}: 1@*
@* This variable controls the order of the grid interpolation
 used in the corresponding unit test.



@c ----------------------------------
@item @strong{TestBatchOps}@*
@vindex @code{TestBatchOps}@*
@emph{Section}: Calculation Modes::Test@*
@emph{Type}: flag@*
@emph{Default}: ops_axpy + ops_scal + ops_nrm2@*
@* Decides which part of the Hamiltonian is applied.


@emph{Options}:
@itemize @minus
@item @strong{ops_axpy}:  Tests batch_axpy operation
@item @strong{ops_scal}:  Tests batch_scal operation
@item @strong{ops_nrm2}:  Tests batch_nrm2 operation
@item @strong{ops_dotp_matrix}:  Tests X(mesh_batch_dotp_matrix)
@item @strong{ops_dotp_self}:  Tests X(mesh_batch_dotp_self)
@item @strong{ops_dotp_vector}:  Tests X(mesh_batch_dotp_vector)
@end itemize

@c ----------------------------------
@item @strong{TestHamiltonianApply}@*
@vindex @code{TestHamiltonianApply}@*
@emph{Section}: Calculation Modes::Test@*
@emph{Type}: integer@*
@emph{Default}: term_all@*
@* Decides which part of the Hamiltonian is applied.


@emph{Options}:
@itemize @minus
@item @strong{term_all}:  Apply the full Hamiltonian.
@item @strong{term_kinetic}:  Apply only the kinetic operator
@item @strong{term_local_potential}:  Apply only the local potential.
@item @strong{term_non_local_potential}:  Apply only the non_local potential.
@end itemize

@c ----------------------------------
@item @strong{TestMaxBlockSize}@*
@vindex @code{TestMaxBlockSize}@*
@emph{Section}: Calculation Modes::Test@*
@emph{Type}: integer@*
@emph{Default}: 128@*
@* Some tests can work with multiple blocksizes, in this case of
 range of blocksizes will be tested. This variable sets the lower
 bound of that range.

 Currently this variable is only used by the derivatives test.



@c ----------------------------------
@item @strong{TestMinBlockSize}@*
@vindex @code{TestMinBlockSize}@*
@emph{Section}: Calculation Modes::Test@*
@emph{Type}: integer@*
@emph{Default}: 1@*
@* Some tests can work with multiple blocksizes, in this case of
 range of blocksizes will be tested. This variable sets the lower
 bound of that range.

 Currently this variable is only used by the derivatives test.



@c ----------------------------------
@item @strong{TestMode}@*
@vindex @code{TestMode}@*
@emph{Section}: Calculation Modes::Test@*
@emph{Type}: integer@*
@emph{Default}: hartree@*
@* Decides what kind of test should be performed.


@emph{Options}:
@itemize @minus
@item @strong{exp_apply}:  Tests the exponential of the Hamiltonian
@item @strong{boundaries}:  Tests the boundaries conditions
@item @strong{subspace_diag}:  Tests the subspace diagonalization
@item @strong{batch_ops}:  Tests the batch operations
@item @strong{clock}:  Tests for clock
@item @strong{linear_solver}:  Tests the linear solvers
@item @strong{hartree}:  Tests the Poisson solvers used to calculate the Hartree potential.
@item @strong{cgal}:  Tests for cgal interface
@item @strong{dense_eigensolver}:  Tests for dense eigensolvers (especially parallel ones)
@item @strong{grid_interpolation}:  Tests for grid interpolation and multigrid methods.
@item @strong{iihash}:  Tests for the integer-integer hash table.
@item @strong{sihash}:  Tests for the string-integer hash table.
@item @strong{sphash}:  Tests for the string-polymorphic hash table.
@item @strong{mpiwrappers}:  Tests for the MPI wrappers with large integer displacements.
@item @strong{regridding}:  Tests the regridding between two different grids.
@item @strong{helmholtz_decomposition}:  Test for the Helmholtz decomposition subroutines
@item @strong{vecpot_analytical}:  Tests analytically the vector potential from B field.
@item @strong{derivatives}:  Tests and benchmarks the implementation of the finite-difference operators, used to calculate derivatives.
@item @strong{orthogonalization}:  Tests the implementation of the orthogonalization routines.
@item @strong{interpolation}:  Test the interpolation routines.
@item @strong{ion_interaction}:  Tests the ion-ion interaction routines.
@item @strong{projector}:  Tests the code that applies the nonlocal part of the pseudopotentials
 in case of spin-orbit coupling
@item @strong{dft_u}:  Tests the DFT+U part of the code for projections on the basis.
@item @strong{hamiltonian_apply}:  Tests the application of the Hamiltonian, or a part of it
@item @strong{density_calc}:  Calculation of the density.
@end itemize

@c ----------------------------------
@item @strong{TestRepetitions}@*
@vindex @code{TestRepetitions}@*
@emph{Section}: Calculation Modes::Test@*
@emph{Type}: integer@*
@emph{Default}: 1@*
@* This variable controls the behavior of oct-test for performance
 benchmarking purposes. It sets the number of times the
 computational kernel of a test will be executed, in order to
 provide more accurate timings.

 Currently this variable is used by the @t{hartree_test},
 @t{derivatives}, and @t{projector} tests.



@c ----------------------------------
@item @strong{TestType}@*
@vindex @code{TestType}@*
@emph{Section}: Calculation Modes::Test@*
@emph{Type}: integer@*
@emph{Default}: all@*
@* Decides on what type of values the test should be performed.


@emph{Options}:
@itemize @minus
@item @strong{real}:  Test for double-precision real functions.
@item @strong{all}:  Tests for double-precision real and complex functions.
@end itemize

@c ----------------------------------
@item @strong{TestVectorPotentialType}@*
@vindex @code{TestVectorPotentialType}@*
@emph{Section}: Calculation Modes::Test@*
@emph{Type}: integer@*
@emph{Default}: bounded@*
@* Select whether bounded or unbounded type will be used for vector potential tests


@emph{Options}:
@itemize @minus
@item @strong{bounded}:  Analytical Vector Potential formulation is bounded by spatial gaussian
@item @strong{unbounded}:  Analytical Vector Potential is not bounded
@end itemize

@c ----------------------------------
@end itemize
@node Unoccupied States,,,
@subsection Unoccupied States
@c ----------------------------------

@itemize
@item @strong{UnoccShowOccStates}@*
@vindex @code{UnoccShowOccStates}@*
@emph{Section}: Calculation Modes::Unoccupied States@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* If true, the convergence for the occupied states will be shown too in the output.
 This is useful for testing, or if the occupied states fail to converge.
 It will be enabled automatically if only occupied states are being calculated.



@c ----------------------------------
@item @strong{UnoccUseTD}@*
@vindex @code{UnoccUseTD}@*
@emph{Section}: Calculation Modes::Unoccupied States@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* If true, Octopus will use the density and states from the restart/td folder to compute
 the bandstructure, instead of the restart/gs ones.



@c ----------------------------------
@end itemize
@node ClassicalParticles,,,
@section ClassicalParticles
@c ----------------------------------

@itemize
@item @strong{ParticleCharge}@*
@vindex @code{ParticleCharge}@*
@emph{Section}: ClassicalParticles@*
@emph{Type}: float@*
@* Charge of classical particle



@c ----------------------------------
@item @strong{ParticleInitialPosition}@*
@vindex @code{ParticleInitialPosition}@*
@emph{Section}: ClassicalParticles@*
@emph{Type}: block@*
@* Initial position of classical particle, in Km.



@c ----------------------------------
@item @strong{ParticleInitialVelocity}@*
@vindex @code{ParticleInitialVelocity}@*
@emph{Section}: ClassicalParticles@*
@emph{Type}: block@*
@* Initial velocity of classical particle in Km/s.



@c ----------------------------------
@end itemize
@node DFTBPlusInterface,,,
@section DFTBPlusInterface
@c ----------------------------------

@itemize
@item @strong{InitialIonicTemperature}@*
@vindex @code{InitialIonicTemperature}@*
@emph{Section}: DFTBPlusInterface@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* If this variable is present, the ions will have initial velocities
 velocities to the atoms following a Boltzmann distribution with
 this temperature (in Kelvin). Used only if @t{TDDynamics = Ehrenfest}
 and  @t{MoveIons = yes}.



@c ----------------------------------
@item @strong{MaxAngularMomentum}@*
@vindex @code{MaxAngularMomentum}@*
@emph{Section}: DFTBPlusInterface@*
@emph{Type}: block@*
@* Specifies the highest angular momentum for each atom type. All orbitals up
 to that angular momentum will be included in the calculation.
 Possible values for the angular momenta are s, p, d, f.
 These are examples:

 @t{%MaxAngularMomentum
 @*@ @ 'O'   | 'p'
 @*@ @ 'H'   | 's'
 @*%}



@c ----------------------------------
@item @strong{SccTolerance}@*
@vindex @code{SccTolerance}@*
@emph{Section}: DFTBPlusInterface@*
@emph{Type}: float@*
@* Self-consistent-charges convergence tolerance. Once this
 tolerance has been achieved the SCC cycle will stop.



@c ----------------------------------
@end itemize
@node Execution,,,
@section Execution
@c ----------------------------------

@itemize
@item @strong{FromScratch}@*
@vindex @code{FromScratch}@*
@emph{Section}: Execution@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* When this variable is set to true, @t{Octopus} will perform a
 calculation from the beginning, without looking for restart
 information.



@c ----------------------------------
@end itemize
@node Accel,,,
@subsection Accel
@c ----------------------------------

@itemize
@item @strong{AccelBenchmark}@*
@vindex @code{AccelBenchmark}@*
@emph{Section}: Execution::Accel@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* If this variable is set to yes, Octopus will run some
 routines to benchmark the performance of the accelerator device.



@c ----------------------------------
@item @strong{AccelDevice}@*
@vindex @code{AccelDevice}@*
@emph{Section}: Execution::Accel@*
@emph{Type}: integer@*
@emph{Default}: gpu@*
@* This variable selects the OpenCL or CUDA accelerator device
 that Octopus will use. You can specify one of the options below
 or a numerical id to select a specific device.

 Values >= 0 select the device to be used. In case of MPI enabled runs
 devices are distributed in a round robin fashion, starting at this value.


@emph{Options}:
@itemize @minus
@item @strong{gpu}:  If available, Octopus will use a GPU.
@item @strong{cpu}:  If available, Octopus will use a CPU (only for OpenCL).
@item @strong{accelerator}:  If available, Octopus will use an accelerator (only for OpenCL).
@item @strong{accel_default}:  Octopus will use the default device specified by the implementation.
 implementation.
@end itemize

@c ----------------------------------
@item @strong{AccelPlatform}@*
@vindex @code{AccelPlatform}@*
@emph{Section}: Execution::Accel@*
@emph{Type}: integer@*
@* This variable selects the OpenCL platform that Octopus will
 use. You can give an explicit platform number or use one of
 the options that select a particular vendor
 implementation. Platform 0 is used by default.

 This variable has no effect for CUDA.


@emph{Options}:
@itemize @minus
@item @strong{amd}:  Use the AMD OpenCL platform.
@item @strong{nvidia}:  Use the Nvidia OpenCL platform.
@item @strong{ati}:  Use the ATI (old AMD) OpenCL platform.
@item @strong{intel}:  Use the Intel OpenCL platform.
@end itemize

@c ----------------------------------
@item @strong{AllowCPUonly}@*
@vindex @code{AllowCPUonly}@*
@emph{Section}: Execution::Accel@*
@emph{Type}: logical@*
@* In order to prevent waste of resources, the code will normally stop when the GPU is disabled due to
 incomplete implementations or incompatibilities. AllowCPUonly = yes overrides this and allows the
 code execution also in these cases.



@c ----------------------------------
@item @strong{CudaAwareMPI}@*
@vindex @code{CudaAwareMPI}@*
@emph{Section}: Execution::Accel@*
@emph{Type}: logical@*
@* If Octopus was compiled with CUDA support and MPI support and if the MPI
 implementation is CUDA-aware (i.e., it supports communication using device pointers),
 this switch can be set to true to use the CUDA-aware MPI features. The advantage
 of this approach is that it can do, e.g., peer-to-peer copies between devices without
 going through the host memmory.
 The default is false, except when the configure switch --enable-cudampi is set, in which
 case this variable is set to true.



@c ----------------------------------
@item @strong{DisableAccel}@*
@vindex @code{DisableAccel}@*
@emph{Section}: Execution::Accel@*
@emph{Type}: logical@*
@emph{Default}: yes@*
@* If Octopus was compiled with OpenCL or CUDA support, it will
 try to initialize and use an accelerator device. By setting this
 variable to @t{yes} you force Octopus not to use an accelerator even it is available.



@c ----------------------------------
@item @strong{InitializeGPUBuffers}@*
@vindex @code{InitializeGPUBuffers}@*
@emph{Section}: Execution::Accel@*
@emph{Type}: logical@*
@* Initialize new GPU buffers to zero on creation (use only for debugging, as it has a performance impact!).



@c ----------------------------------
@end itemize
@node Debug,,,
@subsection Debug
@c ----------------------------------

@itemize
@item @strong{Debug}@*
@vindex @code{Debug}@*
@emph{Section}: Execution::Debug@*
@emph{Type}: flag@*
@emph{Default}: no@*
@* This variable controls the amount of debugging information
 generated by Octopus. You can use include more than one option
 with the + operator.


@emph{Options}:
@itemize @minus
@item @strong{no}:  (default) @t{Octopus} does not enter debug mode.
@item @strong{propagation_graph}:  Octopus generates a file with information for the propagation diagram.
@item @strong{extra_checks}:  This enables Octopus to perform some extra checks, to ensure
 code correctness, that might be too costly for regular runs.
@item @strong{info}:  Octopus prints additional information to the terminal.
@item @strong{trace}:  Octopus generates a stack trace as it enters end exits
 subroutines. This information is reported if Octopus stops with
 an error.
@item @strong{interaction_graph}:  Octopus generates a dot file containing the graph for a multisystem run.
@item @strong{trace_term}:  The trace is printed to the terminal as Octopus enters or exits subroutines. This slows down execution considerably.
@item @strong{interaction_graph_full}:  Octopus generates a dot file containing the graph for a multisystem run including ghost interactions.
@item @strong{trace_file}:  The trace is written to files in the @t{debug}
 directory. For each node (when running in parallel) there is a file called
 @t{debug_trace.<rank>}. Writing these files slows down the code by a huge factor and
 it is usually only necessary for parallel runs.
@end itemize

@c ----------------------------------
@item @strong{DebugTrapSignals}@*
@vindex @code{DebugTrapSignals}@*
@emph{Section}: Execution::Debug@*
@emph{Type}: logical@*
@emph{Default}: yes@*
@* If true, trap signals to handle them in octopus itself and
 print a custom backtrace. If false, do not trap signals; then,
 core dumps can be produced or gdb can be used to stop at the
 point a signal was produced (e.g. a segmentation fault).



@c ----------------------------------
@item @strong{ExperimentalFeatures}@*
@vindex @code{ExperimentalFeatures}@*
@emph{Section}: Execution::Debug@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* If true, allows the use of certain parts of the code that are
 still under development and are not suitable for production
 runs. This should not be used unless you know what you are doing.
 See details on
 <a href=http://octopus-code.org/experimental_features>wiki page</a>.



@c ----------------------------------
@item @strong{ForceComplex}@*
@vindex @code{ForceComplex}@*
@emph{Section}: Execution::Debug@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* Normally @t{Octopus} determines automatically the type necessary
 for the wavefunctions. When set to yes this variable will
 force the use of complex wavefunctions.

 Warning: This variable is designed for testing and
 benchmarking and normal users need not use it.



@c ----------------------------------
@item @strong{MPIDebugHook}@*
@vindex @code{MPIDebugHook}@*
@emph{Section}: Execution::Debug@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* When debugging the code in parallel it is usually difficult to find the origin
 of race conditions that appear in MPI communications. This variable introduces
 a facility to control separate MPI processes. If set to yes, all nodes will
 start up, but will get trapped in an endless loop. In every cycle of the loop
 each node is sleeping for one second and is then checking if a file with the
 name @t{node_hook.xxx} (where @t{xxx} denotes the node number) exists. A given node can
 only be released from the loop if the corresponding file is created. This allows
 to selectively run, @emph{e.g.}, a compute node first followed by the master node. Or, by
 reversing the file creation of the node hooks, to run the master first followed
 by a compute node.



@c ----------------------------------
@item @strong{ReportMemory}@*
@vindex @code{ReportMemory}@*
@emph{Section}: Execution::Debug@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* If true, after each SCF iteration @t{Octopus} will print
 information about the memory the code is using. The quantity
 reported is an approximation to the size of the heap and
 generally it is a lower bound to the actual memory @t{Octopus} is
 using.



@c ----------------------------------
@end itemize
@node IO,,,
@subsection IO
@c ----------------------------------

@itemize
@item @strong{MaxwellRestartWriteInterval}@*
@vindex @code{MaxwellRestartWriteInterval}@*
@emph{Section}: Execution::IO@*
@emph{Type}: integer@*
@emph{Default}: 50@*
@* Restart data is written when the iteration number is a multiple of the
 @t{MaxwellRestartWriteInterval} variable. (Other output is controlled by @t{MaxwellOutputInterval}.)



@c ----------------------------------
@item @strong{RestartOptions}@*
@vindex @code{RestartOptions}@*
@emph{Section}: Execution::IO@*
@emph{Type}: block@*
@* @t{Octopus} usually stores binary information, such as the wavefunctions, to be used
 in subsequent calculations. The most common example is the ground-state states
 that are used to start a time-dependent calculation. This variable allows to control
 where this information is written to or read from. The format of this block is the following:
 for each line, the first column indicates the type of data, the second column indicates
 the path to the directory that should be used to read and write that restart information, and the
 third column, which is optional, allows one to set some flags to modify the way how the data
 is read or written. For example, if you are running a time-dependent calculation, you can
 indicate where @t{Octopus} can find the ground-state information in the following way:

 @t{%RestartOptions
 @*@ @ restart_gs | "gs_restart"
 @*@ @ restart_td | "td_restart"
 @*%}

 The second line of the above example also tells @t{Octopus} that the time-dependent restart data
 should be read from and written to the "td_restart" directory.

 In case you want to change the path of all the restart directories, you can use the @t{restart_all} option.
 When using the @t{restart_all} option, it is still possible to have a different restart directory for specific
 data types. For example, when including the following block in your input file:

 @t{%RestartOptions
 @*@ @ restart_all | "my_restart"
 @*@ @ restart_td@   | "td_restart"
 @*%}

 the time-dependent restart information will be stored in the "td_restart" directory, while all the remaining
 restart information will be stored in the "my_restart" directory.

 By default, the name of the "restart_all" directory is set to "restart".

 Some @t{CalculationMode}s also take into account specific flags set in the third column of the @t{RestartOptions}
 block. These are used to determine if some specific part of the restart data is to be taken into account
 or not when reading the restart information. For example, when restarting a ground-state calculation, one can
 set the @t{restart_rho} flags, so that the density used is not built from the saved wavefunctions, but is
 instead read from the restart directory. In this case, the block should look like this:

 @t{%RestartOptions
 @*@ @ restart_gs | "restart" | restart_rho
 @*%}

 A list of available flags is given below, but note that the code might ignore some of them, which will happen if they
 are not available for that particular calculation, or might assume some of them always present, which will happen
 in case they are mandatory.

 Finally, note that all the restart information of a given data type is always stored in a subdirectory of the
 specified path. The name of this subdirectory is fixed and cannot be changed. For example, ground-state information
 will always be stored in a subdirectory named "gs". This makes it safe in most situations to use the same path for
 all the data types. The name of these subdirectories is indicated in the description of the data types below.

 Currently, the available restart data types and flags are the following:


@emph{Options}:
@itemize @minus
@item @strong{restart_all}:  (data type)
 Option to globally change the path of all the restart information.
@item @strong{restart_oct}:  (data type)
 The data for optimal control calculations.
 This information is stored under the "opt-control" subdirectory.
@item @strong{restart_partition}:  (data type)
 The data for the mesh partitioning.
 This information is stored under the "partition" subdirectory.
@item @strong{restart_proj}:  (data type)
 The ground-state to be used with the td_occup and populations options of @t{TDOutput}.
 This information should be a ground state, so the "gs" subdirectory is used.
@item @strong{restart_skip}:  (flag)
 This flag allows to selectively skip the reading and writting of specific restart information.
@item @strong{restart_gs}:  (data type)
 The data resulting from a ground-state calculation.
 This information is stored under the "gs" subdirectory.
@item @strong{restart_states}:  (flag)
 Read the electronic states. (not yet implemented)
@item @strong{restart_rho}:  (flag)
 Read the electronic density.
@item @strong{restart_unocc}:  (data type)
 The data resulting from an unoccupied states calculation. This information also corresponds to a ground state and
 can be used as such, so it is stored under the same subdirectory as the one of restart_gs.
@item @strong{restart_td}:  (data type)
 The data resulting from a real-time time-dependent calculation.
 This information is stored under the "td" subdirectory.
@item @strong{restart_em_resp}:  (data type)
 The data resulting from the calculation of the electromagnetic response using the Sternheimer approach.
 This information is stored under the "em_resp" subdirectory.
@item @strong{restart_vhxc}:  (flag)
 Read the Hartree and XC potentials.
@item @strong{restart_em_resp_fd}:  (data type)
 The data resulting from the calculation of the electromagnetic response using finite-differences.
 This information is stored under the "em_resp_fd" subdirectory.
@item @strong{restart_kdotp}:  (data type)
 The data resulting from the calculation of effective masses by k.p perturbation theory.
 This information is stored under the "kdotp" subdirectory.
@item @strong{restart_vib_modes}:  (data type)
 The data resulting from the calculation of vibrational modes.
 This information is stored under the "vib_modes" subdirectory.
@item @strong{restart_mix}:  (flag)
 Read the SCF mixing information.
@item @strong{restart_vdw}:  (data type)
 The data resulting from the calculation of van der Waals coefficients.
 This information is stored under the "vdw" subdirectory.
@item @strong{restart_casida}:  (data type)
 The data resulting from a Casida calculation.
 This information is stored under the "casida" subdirectory.
@end itemize

@c ----------------------------------
@item @strong{RestartWallTimePeriod}@*
@vindex @code{RestartWallTimePeriod}@*
@emph{Section}: Execution::IO@*
@emph{Type}: float@*
@emph{Default}: 120@*
@* Period Time (in minutes) at which the restart file will be written.
 If a finite time (in minutes) is specified, the code will write the restart file every period.



@c ----------------------------------
@item @strong{RestartWrite}@*
@vindex @code{RestartWrite}@*
@emph{Section}: Execution::IO@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* If this variable is set to no, restart information is not
 written. Note that some run modes will ignore this
 option and write some restart information anyway.



@c ----------------------------------
@item @strong{RestartWriteInterval}@*
@vindex @code{RestartWriteInterval}@*
@emph{Section}: Execution::IO@*
@emph{Type}: integer@*
@emph{Default}: 50@*
@* Restart data is written when the iteration number is a multiple
 of the @t{RestartWriteInterval} variable. For
 time-dependent runs this includes the update of the output
 controlled by the @t{TDOutput} variable. (Other output is
 controlled by @t{OutputInterval}.)



@c ----------------------------------
@item @strong{RestartWriteTime}@*
@vindex @code{RestartWriteTime}@*
@emph{Section}: Execution::IO@*
@emph{Type}: float@*
@emph{Default}: 5@*
@* The RestartWriteTime (in minutes) will be subtracted from the WallTime to allow time for writing the restart file.
 In huge calculations, this value should be increased.



@c ----------------------------------
@item @strong{SlakoDir}@*
@vindex @code{SlakoDir}@*
@emph{Section}: Execution::IO@*
@emph{Type}: string@*
@emph{Default}: "./"@*
@* Folder containing the Slako files



@c ----------------------------------
@item @strong{Walltime}@*
@vindex @code{Walltime}@*
@emph{Section}: Execution::IO@*
@emph{Type}: float@*
@* Time in minutes before which the restart file will be written. This is to make sure that at least one restart
 file can be written before the code might be killed to to exceeding the given CPU time.
 If a finite time (in minutes) is specified, the code will write the restart file when the next
 iteration (plus the RestartWriteTime) would exceed the given time.
 A value less than 1 second (1/60 minutes) will disable the timer.



@c ----------------------------------
@item @strong{WorkDir}@*
@vindex @code{WorkDir}@*
@emph{Section}: Execution::IO@*
@emph{Type}: string@*
@emph{Default}: "."@*
@* By default, all files are written and read from the working directory,
 @emph{i.e.} the directory from which the executable was launched. This behavior can
 be changed by setting this variable. If you set @t{WorkDir} to a name other than ".",
 the following directories are written and read in that directory:
@itemize

 @item
"casida/"
 @item
"em_resp_fd/"
 @item
"em_resp/"
 @item
"geom/"
 @item
"kdotp/"
 @item
"local.general"
 @item
"pcm/"
 @item
"profiling/"
 @item
"restart/"
 @item
"static/"
 @item
"td.general/"
 @item
"vdw/"
 @item
"vib_modes/"
@end itemize

 Furthermore, some of the debug information (see @t{Debug}) is also written to @t{WorkDir} and
 the non-absolute paths defined in @t{OutputIterDir} are relative to @t{WorkDir}.



@c ----------------------------------
@item @strong{stderr}@*
@vindex @code{stderr}@*
@emph{Section}: Execution::IO@*
@emph{Type}: string@*
@emph{Default}: "-"@*
@* The standard error by default goes to, well, to standard error. This can
 be changed by setting this variable: if you give it a name (other than "-")
 the output stream is printed in that file instead.



@c ----------------------------------
@item @strong{stdout}@*
@vindex @code{stdout}@*
@emph{Section}: Execution::IO@*
@emph{Type}: string@*
@emph{Default}: "-"@*
@* The standard output by default goes to, well, to standard output. This can
 be changed by setting this variable: if you give it a name (other than "-")
 the output stream is printed in that file instead.



@c ----------------------------------
@end itemize
@node Optimization,,,
@subsection Optimization
@c ----------------------------------

@itemize
@item @strong{HamiltonianApplyPacked}@*
@vindex @code{HamiltonianApplyPacked}@*
@emph{Section}: Execution::Optimization@*
@emph{Type}: logical@*
@emph{Default}: yes@*
@* If set to yes (the default), Octopus will 'pack' the
 wave-functions when operating with them. This might involve some
 additional copying but makes operations more efficient.
 See also the related @t{StatesPack} variable.



@c ----------------------------------
@item @strong{MemoryLimit}@*
@vindex @code{MemoryLimit}@*
@emph{Section}: Execution::Optimization@*
@emph{Type}: integer@*
@emph{Default}: -1@*
@* If positive, @t{Octopus} will stop if more memory than @t{MemoryLimit}
 is requested (in kb). Note that this variable only works when
 @t{ProfilingMode = prof_memory(_full)}.



@c ----------------------------------
@item @strong{MeshBlockDirection}@*
@vindex @code{MeshBlockDirection}@*
@emph{Section}: Execution::Optimization@*
@emph{Type}: integer@*
@* Determines the direction in which the dimensions are chosen to compute
 the blocked index for sorting the mesh points (see MeshBlockSize).
 The default is increase_with_dimensions, corresponding to xyz ordering
 in 3D.


@emph{Options}:
@itemize @minus
@item @strong{increase_with_dimension}:  The fastest changing index is in the first dimension, i.e., in 3D this
 corresponds to ordering in xyz directions.
@item @strong{decrease_with_dimension}:  The fastest changing index is in the last dimension, i.e., in 3D this
 corresponds to ordering in zyx directions.
@end itemize

@c ----------------------------------
@item @strong{MeshBlockSize}@*
@vindex @code{MeshBlockSize}@*
@emph{Section}: Execution::Optimization@*
@emph{Type}: block@*
@* To improve memory-access locality when calculating derivatives,
 @t{Octopus} arranges mesh points in blocks. This variable
 controls the size of this blocks in the different
 directions. The default is selected according to the value of
 the @t{StatesBlockSize} variable. (This variable only affects the
 performance of @t{Octopus} and not the results.)



@c ----------------------------------
@item @strong{MeshLocalBlockDirection}@*
@vindex @code{MeshLocalBlockDirection}@*
@emph{Section}: Execution::Optimization@*
@emph{Type}: integer@*
@* Determines the direction in which the dimensions are chosen to compute
 the blocked index for sorting the mesh points (see MeshLocalBlockSize).
 The default is increase_with_dimensions, corresponding to xyz ordering
 in 3D.


@emph{Options}:
@itemize @minus
@item @strong{increase_with_dimension}:  The fastest changing index is in the first dimension, i.e., in 3D this
 corresponds to ordering in xyz directions.
@item @strong{decrease_with_dimension}:  The fastest changing index is in the last dimension, i.e., in 3D this
 corresponds to ordering in zyx directions.
@end itemize

@c ----------------------------------
@item @strong{MeshLocalBlockSize}@*
@vindex @code{MeshLocalBlockSize}@*
@emph{Section}: Execution::Optimization@*
@emph{Type}: block@*
@* To improve memory-access locality when calculating derivatives,
 @t{Octopus} arranges mesh points in blocks. This variable
 controls the size of this blocks in the different
 directions. The default is selected according to the value of
 the @t{StatesBlockSize} variable. (This variable only affects the
 performance of @t{Octopus} and not the results.)



@c ----------------------------------
@item @strong{MeshLocalOrder}@*
@vindex @code{MeshLocalOrder}@*
@emph{Section}: Execution::Optimization@*
@emph{Type}: integer@*
@emph{Default}: blocks@*
@* This variable controls how the grid points are mapped to a
 linear array. This influences the performance of the code.


@emph{Options}:
@itemize @minus
@item @strong{order_blocks}:  The grid is mapped using small parallelepipedic grids. The size
 of the blocks is controlled by @t{MeshBlockSize}.
@item @strong{order_cube}:  The grid is mapped using a full cube, i.e. without blocking.
@item @strong{order_global}:  Use the ordering from the global mesh
@end itemize

@c ----------------------------------
@item @strong{MeshOrder}@*
@vindex @code{MeshOrder}@*
@emph{Section}: Execution::Optimization@*
@emph{Type}: integer@*
@* This variable controls how the grid points are mapped to a
 linear array for global arrays. For runs that are parallel
 in domains, the local mesh order may be different (see
 @t{MeshLocalOrder}).
 The default is blocks when serial in domains and cube when
 parallel in domains with the local mesh order set to blocks.


@emph{Options}:
@itemize @minus
@item @strong{order_blocks}:  The grid is mapped using small parallelepipedic grids. The size
 of the blocks is controlled by @t{MeshBlockSize}.
@item @strong{order_original}:  The original order of the indices is used to map the grid.
@item @strong{order_cube}:  The grid is mapped using a full cube, i.e. without blocking.
@end itemize

@c ----------------------------------
@item @strong{NLOperatorCompactBoundaries}@*
@vindex @code{NLOperatorCompactBoundaries}@*
@emph{Section}: Execution::Optimization@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* (Experimental) When set to yes, for finite systems Octopus will
 map boundary points for finite-differences operators to a few
 memory locations. This increases performance, however it is
 experimental and has not been thoroughly tested.



@c ----------------------------------
@item @strong{OperateAccel}@*
@vindex @code{OperateAccel}@*
@emph{Section}: Execution::Optimization@*
@emph{Type}: integer@*
@emph{Default}: map@*
@* This variable selects the subroutine used to apply non-local
 operators over the grid when an accelerator device is used.


@emph{Options}:
@itemize @minus
@item @strong{invmap}:  The standard implementation ported to OpenCL.
@item @strong{map}:  A different version, more suitable for GPUs.
@end itemize

@c ----------------------------------
@item @strong{OperateComplex}@*
@vindex @code{OperateComplex}@*
@emph{Section}: Execution::Optimization@*
@emph{Type}: integer@*
@emph{Default}: optimized@*
@* This variable selects the subroutine used to apply non-local
 operators over the grid for complex functions.


@emph{Options}:
@itemize @minus
@item @strong{fortran}:  The standard Fortran function.
@item @strong{optimized}:  This version is optimized using vector primitives (if available).
@end itemize

@c ----------------------------------
@item @strong{OperateComplexSingle}@*
@vindex @code{OperateComplexSingle}@*
@emph{Section}: Execution::Optimization@*
@emph{Type}: integer@*
@emph{Default}: optimized@*
@* This variable selects the subroutine used to apply non-local
 operators over the grid for single-precision complex functions.


@emph{Options}:
@itemize @minus
@item @strong{fortran}:  The standard Fortran function.
@item @strong{optimized}:  This version is optimized using vector primitives (if available).
@end itemize

@c ----------------------------------
@item @strong{OperateDouble}@*
@vindex @code{OperateDouble}@*
@emph{Section}: Execution::Optimization@*
@emph{Type}: integer@*
@emph{Default}: optimized@*
@* This variable selects the subroutine used to apply non-local
 operators over the grid for real functions.


@emph{Options}:
@itemize @minus
@item @strong{fortran}:  The standard Fortran function.
@item @strong{optimized}:  This version is optimized using vector primitives (if available).
@end itemize

@c ----------------------------------
@item @strong{OperateSingle}@*
@vindex @code{OperateSingle}@*
@emph{Section}: Execution::Optimization@*
@emph{Type}: integer@*
@emph{Default}: optimized@*
@* This variable selects the subroutine used to apply non-local
 operators over the grid for single-precision real functions.


@emph{Options}:
@itemize @minus
@item @strong{fortran}:  The standard Fortran function.
@item @strong{optimized}:  This version is optimized using vector primitives (if available).
@end itemize

@c ----------------------------------
@item @strong{ProfilingAllNodes}@*
@vindex @code{ProfilingAllNodes}@*
@emph{Section}: Execution::Optimization@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* This variable controls whether all nodes print the time
 profiling output. If set to no, the default, only the root node
 will write the profile. If set to yes, all nodes will print it.



@c ----------------------------------
@item @strong{ProfilingMode}@*
@vindex @code{ProfilingMode}@*
@emph{Section}: Execution::Optimization@*
@emph{Type}: integer@*
@emph{Default}: no@*
@* Use this variable to run @t{Octopus} in profiling mode. In this mode
 @t{Octopus} records the time spent in certain areas of the code and
 the number of times this code is executed. These numbers
 are written in @t{./profiling.NNN/profiling.nnn} with @t{nnn} being the
 node number (@t{000} in serial) and @t{NNN} the number of processors.
 This is mainly for development purposes. Note, however, that
 @t{Octopus} should be compiled with @t{--disable-debug} to do proper
 profiling. Warning: you may encounter strange results with OpenMP.


@emph{Options}:
@itemize @minus
@item @strong{no}:  No profiling information is generated.
@item @strong{prof_io}:  Count the number of file open and close.
@item @strong{prof_time}:  Profile the time spent in defined profiling regions.
@item @strong{prof_memory}:  As well as the time, summary information on memory usage and the largest arrays are reported.
@item @strong{prof_memory_full}:  As well as the time and summary memory information, a
 log is reported of every allocation and deallocation.
@item @strong{likwid}:  Enable instrumentation using LIKWID.
@end itemize

@c ----------------------------------
@item @strong{ProfilingOutputTree}@*
@vindex @code{ProfilingOutputTree}@*
@emph{Section}: Execution::Optimization@*
@emph{Type}: logical@*
@emph{Default}: yes@*
@* This variable controls whether the profiling output is additionally
 written as a tree.



@c ----------------------------------
@item @strong{ProfilingOutputYAML}@*
@vindex @code{ProfilingOutputYAML}@*
@emph{Section}: Execution::Optimization@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* This variable controls whether the profiling output is additionally
 written to a YAML file.



@c ----------------------------------
@item @strong{StatesBlockSize}@*
@vindex @code{StatesBlockSize}@*
@emph{Section}: Execution::Optimization@*
@emph{Type}: integer@*
@* Some routines work over blocks of eigenfunctions, which
 generally improves performance at the expense of increased
 memory consumption. This variable selects the size of the
 blocks to be used. If GPUs are used, the default is 32;
 otherwise it is 4.



@c ----------------------------------
@item @strong{StatesCLDeviceMemory}@*
@vindex @code{StatesCLDeviceMemory}@*
@emph{Section}: Execution::Optimization@*
@emph{Type}: float@*
@emph{Default}: -512@*
@* This variable selects the amount of OpenCL device memory that
 will be used by Octopus to store the states.

 A positive number smaller than 1 indicates a fraction of the total
 device memory. A number larger than one indicates an absolute
 amount of memory in megabytes. A negative number indicates an
 amount of memory in megabytes that would be subtracted from
 the total device memory.



@c ----------------------------------
@item @strong{StatesPack}@*
@vindex @code{StatesPack}@*
@emph{Section}: Execution::Optimization@*
@emph{Type}: logical@*
@* When set to yes, states are stored in packed mode, which improves
 performance considerably. Not all parts of the code will profit from
 this, but should nevertheless work regardless of how the states are
 stored.

 If GPUs are used and this variable is set to yes, Octopus
 will store the wave-functions in device (GPU) memory. If
 there is not enough memory to store all the wave-functions,
 execution will stop with an error.

 See also the related @t{HamiltonianApplyPacked} variable.

 The default is yes.



@c ----------------------------------
@end itemize
@node Parallelization,,,
@subsection Parallelization
@c ----------------------------------

@itemize
@item @strong{MeshPartition}@*
@vindex @code{MeshPartition}@*
@emph{Section}: Execution::Parallelization@*
@emph{Type}: integer@*
@* When using METIS to perform the mesh partitioning, decides which
 algorithm is used. By default, @t{graph} partitioning
 is used for 8 or more partitions, and @t{rcb} for fewer.


@emph{Options}:
@itemize @minus
@item @strong{rcb}:  Recursive coordinate bisection partitioning.
@item @strong{graph}:  Graph partitioning (called 'k-way' by METIS).
@end itemize

@c ----------------------------------
@item @strong{MeshPartitionPackage}@*
@vindex @code{MeshPartitionPackage}@*
@emph{Section}: Execution::Parallelization@*
@emph{Type}: integer@*
@* Decides which library to use to perform the mesh partition.
 By default ParMETIS is used when available, otherwise METIS is used.


@emph{Options}:
@itemize @minus
@item @strong{metis}:  METIS library.
@item @strong{parmetis}:  (Experimental) Use ParMETIS libary to perform the mesh partition.
 Only available if the code was compiled with ParMETIS support.
@item @strong{part_hilbert}:  Use the ordering along the Hilbert curve for partitioning.
@end itemize

@c ----------------------------------
@item @strong{MeshPartitionStencil}@*
@vindex @code{MeshPartitionStencil}@*
@emph{Section}: Execution::Parallelization@*
@emph{Type}: integer@*
@emph{Default}: stencil_star@*
@* To partition the mesh, it is necessary to calculate the connection
 graph connecting the points. This variable selects which stencil
 is used to do this.


@emph{Options}:
@itemize @minus
@item @strong{stencil_star}:  An order-one star stencil.
@item @strong{laplacian}:  The stencil used for the Laplacian is used to calculate the
 partition. This in principle should give a better partition, but
 it is slower and requires more memory.
@end itemize

@c ----------------------------------
@item @strong{MeshPartitionVirtualSize}@*
@vindex @code{MeshPartitionVirtualSize}@*
@emph{Section}: Execution::Parallelization@*
@emph{Type}: integer@*
@emph{Default}: mesh mpi_grp size@*
@* Gives the possibility to change the partition nodes.
 Afterward, it crashes.



@c ----------------------------------
@item @strong{MeshUseTopology}@*
@vindex @code{MeshUseTopology}@*
@emph{Section}: Execution::Parallelization@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* (experimental) If enabled, @t{Octopus} will use an MPI virtual
 topology to map the processors. This can improve performance
 for certain interconnection systems.



@c ----------------------------------
@item @strong{ParDomains}@*
@vindex @code{ParDomains}@*
@emph{Section}: Execution::Parallelization@*
@emph{Type}: integer@*
@emph{Default}: auto@*
@* This variable controls the number of processors used for the
 parallelization in domains.
 The special value @t{auto}, the default, lets Octopus
 decide how many processors will be assigned for this
 strategy. To disable parallelization in domains, you can use
 @t{ParDomains = no} (or set the number of processors to
 1).

 The total number of processors required is the multiplication
 of the processors assigned to each parallelization strategy.


@emph{Options}:
@itemize @minus
@item @strong{auto}:  The number of processors is assigned automatically.
@item @strong{no}:  This parallelization strategy is not used.
@end itemize

@c ----------------------------------
@item @strong{ParKPoints}@*
@vindex @code{ParKPoints}@*
@emph{Section}: Execution::Parallelization@*
@emph{Type}: integer@*
@emph{Default}: auto@*
@* This variable controls the number of processors used for the
 parallelization in K-Points and/or spin.
 The special value @t{auto} lets Octopus decide how many processors will be
 assigned for this strategy. To disable parallelization in
 KPoints, you can use @t{ParKPoints = no} (or set the
 number of processors to 1).

 The total number of processors required is the multiplication
 of the processors assigned to each parallelization strategy.


@emph{Options}:
@itemize @minus
@item @strong{auto}:  The number of processors is assigned automatically.
@item @strong{no}:  This parallelization strategy is not used.
@end itemize

@c ----------------------------------
@item @strong{ParOther}@*
@vindex @code{ParOther}@*
@emph{Section}: Execution::Parallelization@*
@emph{Type}: integer@*
@emph{Default}: auto@*
@* This variable controls the number of processors used for the
 'other' parallelization mode, that is CalculatioMode
 dependent. For @t{CalculationMode = casida}, it means
 parallelization in electron-hole pairs.

 The special value @t{auto},
 the default, lets Octopus decide how many processors will be
 assigned for this strategy. To disable parallelization in
 Other, you can use @t{ParOther = no} (or set the
 number of processors to 1).

 The total number of processors required is the multiplication
 of the processors assigned to each parallelization strategy.


@emph{Options}:
@itemize @minus
@item @strong{auto}:  The number of processors is assigned automatically.
@item @strong{no}:  This parallelization strategy is not used.
@end itemize

@c ----------------------------------
@item @strong{ParStates}@*
@vindex @code{ParStates}@*
@emph{Section}: Execution::Parallelization@*
@emph{Type}: integer@*
@* This variable controls the number of processors used for the
 parallelization in states. The special value @t{auto} lets
 Octopus decide how many processors will be assigned for this
 strategy. To disable parallelization in states, you can use
 @t{ParStates = no} (or set the number of processors to 1).

 The default value depends on the @t{CalculationMode}. For
 @t{CalculationMode = td} the default is @t{auto}, while
 for for other modes the default is @t{no}.

 The total number of processors required is the multiplication
 of the processors assigned to each parallelization strategy.


@emph{Options}:
@itemize @minus
@item @strong{auto}:  The number of processors is assigned automatically.
@item @strong{no}:  This parallelization strategy is not used.
@end itemize

@c ----------------------------------
@item @strong{ParallelXC}@*
@vindex @code{ParallelXC}@*
@emph{Section}: Execution::Parallelization@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* When enabled, additional parallelization
 will be used for the calculation of the XC functional.



@c ----------------------------------
@item @strong{ParallelizationNumberSlaves}@*
@vindex @code{ParallelizationNumberSlaves}@*
@emph{Section}: Execution::Parallelization@*
@emph{Type}: integer@*
@* Slaves are nodes used for task parallelization. The number of
 such nodes is given by this variable multiplied by the number
 of domains used in domain parallelization.



@c ----------------------------------
@item @strong{ParallelizationOfDerivatives}@*
@vindex @code{ParallelizationOfDerivatives}@*
@emph{Section}: Execution::Parallelization@*
@emph{Type}: integer@*
@emph{Default}: non_blocking@*
@* This option selects how the communication of mesh boundaries is performed.


@emph{Options}:
@itemize @minus
@item @strong{blocking}:  Blocking communication.
@item @strong{non_blocking}:  Communication is based on non-blocking point-to-point communication.
@end itemize

@c ----------------------------------
@item @strong{ParallelizationPoissonAllNodes}@*
@vindex @code{ParallelizationPoissonAllNodes}@*
@emph{Section}: Execution::Parallelization@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* When running in parallel, this variable selects whether the
 Poisson solver should divide the work among all nodes or only
 among the parallelization-in-domains groups.



@c ----------------------------------
@item @strong{PartitionPrint}@*
@vindex @code{PartitionPrint}@*
@emph{Section}: Execution::Parallelization@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* (experimental) If disabled, @t{Octopus} will not compute
 nor print the partition information, such as local points,
 no. of neighbours, ghost points and boundary points.



@c ----------------------------------
@item @strong{ReorderRanks}@*
@vindex @code{ReorderRanks}@*
@emph{Section}: Execution::Parallelization@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* This variable controls whether the ranks are reorganized to have a more
 compact distribution with respect to domain parallelization which needs
 to communicate most often. Depending on the system, this can improve
 communication speeds.



@c ----------------------------------
@item @strong{ScaLAPACKCompatible}@*
@vindex @code{ScaLAPACKCompatible}@*
@emph{Section}: Execution::Parallelization@*
@emph{Type}: logical@*
@* Whether to use a layout for states parallelization which is compatible with ScaLAPACK.
 The default is yes for @t{CalculationMode = gs, unocc, go} without k-point parallelization,
 and no otherwise. (Setting to other than default is experimental.)
 The value must be yes if any ScaLAPACK routines are called in the course of the run;
 it must be set by hand for @t{td} with @t{TDDynamics = bo}.
 This variable has no effect unless you are using states parallelization and have linked ScaLAPACK.
 Note: currently, use of ScaLAPACK is not compatible with task parallelization (@emph{i.e.} slaves).



@c ----------------------------------
@end itemize
@node Symmetries,,,
@subsection Symmetries
@c ----------------------------------

@itemize
@item @strong{SymmetriesCompute}@*
@vindex @code{SymmetriesCompute}@*
@emph{Section}: Execution::Symmetries@*
@emph{Type}: logical@*
@* If disabled, @t{Octopus} will not compute
 nor print the symmetries.

 By default, symmetries are computed when running in 3
 dimensions for systems with less than 100 atoms.
 For periodic systems, the default is always true, irrespective of the number of atoms.



@c ----------------------------------
@item @strong{SymmetriesTolerance}@*
@vindex @code{SymmetriesTolerance}@*
@emph{Section}: Execution::Symmetries@*
@emph{Type}: float@*
@* For periodic systems, this variable controls the tolerance used by the symmetry finder
 (spglib) to find the spacegroup and symmetries of the crystal.



@c ----------------------------------
@end itemize
@node Units,,,
@subsection Units
@c ----------------------------------

@itemize
@item @strong{Units}@*
@vindex @code{Units}@*
@emph{Section}: Execution::Units@*
@emph{Type}: virtual@*
@emph{Default}: atomic@*
@* (Virtual) These are the units that can be used in the input file.




@c ----------------------------------
@item @strong{UnitsOutput}@*
@vindex @code{UnitsOutput}@*
@emph{Section}: Execution::Units@*
@emph{Type}: integer@*
@emph{Default}: atomic@*
@* This variable selects the units that Octopus use for output.

 Atomic units seem to be the preferred system in the atomic and
 molecular physics community. Internally, the code works in
 atomic units. However, for output, some people like
 to use a system based on electron-Volts (eV) for energies
 and Angstroms (&Aring;) for length.

 Normally time units are derived from energy and length units,
 so it is measured in \(\hbar\)/Hartree or
 \(\hbar\)/eV.

 Warning 1: All files read on input will also be treated using
 these units, including XYZ geometry files.

 Warning 2: Some values are treated in their most common units,
 for example atomic masses (a.m.u.), electron effective masses
 (electron mass), vibrational frequencies
 (cm<sup>-1</sup>) or temperatures (Kelvin). The unit of charge is always
 the electronic charge @emph{e}.



@emph{Options}:
@itemize @minus
@item @strong{atomic}:  Atomic units.
@item @strong{ev_angstrom}:  Electronvolts for energy, Angstroms for length, the rest of the
 units are derived from these and \(\hbar=1\).
@end itemize

@c ----------------------------------
@item @strong{UnitsXYZFiles}@*
@vindex @code{UnitsXYZFiles}@*
@emph{Section}: Execution::Units@*
@emph{Type}: integer@*
@emph{Default}: angstrom_units@*
@* This variable selects in which units I/O of XYZ files should be
 performed.


@emph{Options}:
@itemize @minus
@item @strong{bohr_units}:  The XYZ will be assumed to be in Bohr atomic units.
@item @strong{angstrom_units}:  XYZ files will be assumed to be always in Angstrom,
 independently of the units used by Octopus. This ensures
 compatibility with most programs, that assume XYZ files have
 coordinates in Angstrom.
@end itemize

@c ----------------------------------
@end itemize
@node Hamiltonian,,,
@section Hamiltonian
@c ----------------------------------

@itemize
@item @strong{AdaptivelyCompressedExchange}@*
@vindex @code{AdaptivelyCompressedExchange}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* (Experimental) If set to yes, Octopus will use the adaptively compressed exchange
 operator (ACE) for HF and hybrid calculations, as defined in
  Lin, J. Chem. Theory Comput. 2016, 12, 2242.



@c ----------------------------------
@item @strong{CalculateSelfInducedMagneticField}@*
@vindex @code{CalculateSelfInducedMagneticField}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* The existence of an electronic current implies the creation of a self-induced magnetic
 field, which may in turn back-react on the system. Of course, a fully consistent treatment
 of this kind of effect should be done in QED theory, but we will attempt a first
 approximation to the problem by considering the lowest-order relativistic terms
 plugged into the normal Hamiltonian equations (spin-other-orbit coupling terms, etc.).
 For the moment being, none of this is done, but a first step is taken by calculating
 the induced magnetic field of a system that has a current, by considering the magnetostatic
 approximation and Biot-Savart law:

 \( \nabla^2 \vec{A} + 4\pi\alpha \vec{J} = 0\)

 \( \vec{B} = \vec{\nabla} \times \vec{A}\)

 If @t{CalculateSelfInducedMagneticField} is set to yes, this @emph{B} field is
 calculated at the end of a @t{gs} calculation (nothing is done -- yet -- in the @t{td}case)
 and printed out, if the @t{Output} variable contains the @t{potential} keyword (the prefix
 of the output files is @t{Bind}).



@c ----------------------------------
@item @strong{ClassicalPotential}@*
@vindex @code{ClassicalPotential}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: integer@*
@emph{Default}: no@*
@* Whether and how to add to the external potential the potential generated by
 the classical charges read from block @t{PDBClassical}, for QM/MM calculations.
 Not available in periodic systems.


@emph{Options}:
@itemize @minus
@item @strong{no}:   No classical charges.
@item @strong{point_charges}:   Classical charges are treated as point charges.
@item @strong{gaussian_smeared}:   Classical charges are treated as Gaussian distributions.
  Smearing widths are hard-coded by species (experimental).
@end itemize

@c ----------------------------------
@item @strong{CurrentDensity}@*
@vindex @code{CurrentDensity}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: integer@*
@emph{Default}: gradient_corrected@*
@* This variable selects the method used to
 calculate the current density. For the moment this variable is
 for development purposes and users should not need to use
 it.


@emph{Options}:
@itemize @minus
@item @strong{gradient}:  The calculation of current is done using the gradient operator. (Experimental)
@item @strong{gradient_corrected}:  The calculation of current is done using the gradient operator
 with additional corrections for the total current from non-local operators.
@item @strong{hamiltonian}:  The current density is obtained from the commutator of the
 Hamiltonian with the position operator. (Experimental)
@end itemize

@c ----------------------------------
@item @strong{EnablePhotons}@*
@vindex @code{EnablePhotons}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* This variable can be used to enable photons in several types of calculations.
 It can be used to activate the one-photon OEP formalism.
 In the case of CalculationMode = casida, it enables photon modes as
 described in ACS Photonics 2019, 6, 11, 2757-2778.
 Finally, if set to yes when solving the ferquency-dependent Sternheimer
 equation, the photons are coupled to the electronic subsystem.



@c ----------------------------------
@item @strong{EwaldAlpha}@*
@vindex @code{EwaldAlpha}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: float@*
@emph{Default}: 0.21@*
@* The value 'Alpha' that controls the splitting of the Coulomb
 interaction in the Ewald sum used to calculation the ion-ion
 interaction for periodic systems. This value affects the speed
 of the calculation, normally users do not need to modify it.



@c ----------------------------------
@item @strong{ExternalCurrent}@*
@vindex @code{ExternalCurrent}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* If an external current density will be used.



@c ----------------------------------
@item @strong{FilterPotentials}@*
@vindex @code{FilterPotentials}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: integer@*
@emph{Default}: filter_ts@*
@* @t{Octopus} can filter the pseudopotentials so that they no
 longer contain Fourier components larger than the mesh itself. This is
 very useful to decrease the egg-box effect, and so should be used in
 all instances where atoms move (@emph{e.g.} geometry optimization,
 molecular dynamics, and vibrational modes).


@emph{Options}:
@itemize @minus
@item @strong{filter_none}:  Do not filter.
@item @strong{filter_TS}:  The filter of M. Tafipolsky and R. Schmid, @emph{J. Chem. Phys.} @strong{124}, 174102 (2006).
@item @strong{filter_BSB}:  The filter of E. L. Briggs, D. J. Sullivan, and J. Bernholc, @emph{Phys. Rev. B} @strong{54}, 14362 (1996).
@end itemize

@c ----------------------------------
@item @strong{ForceTotalEnforce}@*
@vindex @code{ForceTotalEnforce}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* (Experimental) If this variable is set to "yes", then the sum
 of the total forces will be enforced to be zero.



@c ----------------------------------
@item @strong{GaugeFieldDelay}@*
@vindex @code{GaugeFieldDelay}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: float@*
@emph{Default}: 0.@*
@* The application of the gauge field acts as a probe of the system. For dynamical
 systems one can apply this probe with a delay relative to the start of the simulation.



@c ----------------------------------
@item @strong{GaugeFieldDynamics}@*
@vindex @code{GaugeFieldDynamics}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: integer@*
@emph{Default}: polarization@*
@* This variable select the dynamics of the gauge field used to
 apply a finite electric field to periodic systems in
 time-dependent runs.


@emph{Options}:
@itemize @minus
@item @strong{none}:  The gauge field does not have dynamics. The induced polarization field is zero.
@item @strong{polarization}:  The gauge field follows the dynamic described in
 Bertsch et al, Phys. Rev. B 62 7998 (2000).
@end itemize

@c ----------------------------------
@item @strong{GaugeFieldPropagate}@*
@vindex @code{GaugeFieldPropagate}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* Propagate the gauge field with initial condition set by GaugeVectorField or zero if not specified



@c ----------------------------------
@item @strong{GaugeVectorField}@*
@vindex @code{GaugeVectorField}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: block@*
@* The gauge vector field is used to include a uniform (but time-dependent)
 external electric field in a time-dependent run for
 a periodic system. An optional second row specifies the initial
 value for the time derivative of the gauge field (which is set
 to zero by default). By default this field is not included.
 If @t{KPointsUseSymmetries = yes}, then @t{SymmetryBreakDir}
 must be set in the same direction.
 This is used with utility @t{oct-dielectric_function}
 according to GF Bertsch, J-I Iwata, A Rubio, and K Yabana,
 @emph{Phys. Rev. B} @strong{62}, 7998-8002 (2000).



@c ----------------------------------
@item @strong{GyromagneticRatio}@*
@vindex @code{GyromagneticRatio}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: float@*
@emph{Default}: 2.0023193043768@*
@* The gyromagnetic ratio of the electron. This is of course a physical
 constant, and the default value is the exact one that you should not
 touch, unless:
 (i)  You want to disconnect the anomalous Zeeman term in the Hamiltonian
 (then set it to zero; this number only affects that term);
 (ii) You are using an effective Hamiltonian, as is the case when
 you calculate a 2D electron gas, in which case you have an effective
 gyromagnetic factor that depends on the material.



@c ----------------------------------
@item @strong{MagneticConstrain}@*
@vindex @code{MagneticConstrain}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: integer@*
@emph{Default}: no@*
@* This variable selects which magnetic constrain expression is added to the Hamiltonian.


@emph{Options}:
@itemize @minus
@item @strong{constrain_none}:  No constrain is added to the Hamiltonian.
@item @strong{constrain_dir}:  We are adding a constrain for the direction of the magnetic moments only,
 see PRB 91, 054420 (2015).
@item @strong{constrain_full}:  We are adding a constrain for the direction and norm of the magnetic moments only,
 see PRB 91, 054420 (2015).
@end itemize

@c ----------------------------------
@item @strong{MagneticConstrainStrength}@*
@vindex @code{MagneticConstrainStrength}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: float@*
@emph{Default}: 0.01@*
@* This variable determines the value of the Lagrange multiplier used for the constrain term.



@c ----------------------------------
@item @strong{MaxwellHamiltonianOperator}@*
@vindex @code{MaxwellHamiltonianOperator}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: integer@*
@emph{Default}: faraday_ampere@*
@* With this variable the the Maxwell Hamiltonian operator can be selected


@emph{Options}:
@itemize @minus
@item @strong{faraday_ampere_old}:  old version
@item @strong{faraday_ampere}:  The propagation operation in vacuum with Spin 1 matrices without Gauss law condition.
@item @strong{faraday_ampere_medium}:  The propagation operation in medium with Spin 1 matrices without Gauss law condition
@item @strong{faraday_ampere_gauss}:  The propagation operation is done by 4x4 matrices also with Gauss laws constraint.
@item @strong{faraday_ampere_gauss_medium}:  The propagation operation is done by 4x4 matrices also with Gauss laws constraint in medium
@end itemize

@c ----------------------------------
@item @strong{MaxwellMediumCalculation}@*
@vindex @code{MaxwellMediumCalculation}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: integer@*
@emph{Default}: RS@*
@* For linear media the calculation of the Maxwell Operator acting on the RS state can be done
 directly using the Riemann-Silberstein representation or by calculating the curl of the
 electric and magnetic fields.


@emph{Options}:
@itemize @minus
@item @strong{RS}:  Medium calculation directly via Hamiltonian
@item @strong{EM}:  Medium calculation via curl of electric field and magnetic field
@end itemize

@c ----------------------------------
@item @strong{ParticleMass}@*
@vindex @code{ParticleMass}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: float@*
@emph{Default}: 1.0@*
@* It is possible to make calculations for a particle with a mass
 different from one (atomic unit of mass, or mass of the electron).
 This is useful to describe non-electronic systems, or for
 esoteric purposes.



@c ----------------------------------
@item @strong{RashbaSpinOrbitCoupling}@*
@vindex @code{RashbaSpinOrbitCoupling}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* (Experimental.) For systems described in 2D (electrons confined to 2D in semiconductor structures), one
 may add the Bychkov-Rashba spin-orbit coupling term [Bychkov and Rashba, @emph{J. Phys. C: Solid
 State Phys.} @strong{17}, 6031 (1984)]. This variable determines the strength
 of this perturbation, and has dimensions of energy times length.



@c ----------------------------------
@item @strong{RelativisticCorrection}@*
@vindex @code{RelativisticCorrection}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: integer@*
@emph{Default}: non_relativistic@*
@* The default value means that @emph{no} relativistic correction is used. To
 include spin-orbit coupling turn @t{RelativisticCorrection} to @t{spin_orbit}
 (this will only work if @t{SpinComponents} has been set to @t{non_collinear}, which ensures
 the use of spinors).


@emph{Options}:
@itemize @minus
@item @strong{non_relativistic}:  No relativistic corrections.
@item @strong{spin_orbit}:  Spin-orbit.
@end itemize

@c ----------------------------------
@item @strong{RiemannSilbersteinSign}@*
@vindex @code{RiemannSilbersteinSign}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: integer@*
@emph{Default}: plus@*
@* Sign for the imaginary part of the Riemann Silberstein vector which represents the magnetic field


@emph{Options}:
@itemize @minus
@item @strong{minus}:  Riemann Silberstein sign is minus
@item @strong{plus}:  Riemann Silberstein sign is plus
@end itemize

@c ----------------------------------
@item @strong{SOStrength}@*
@vindex @code{SOStrength}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: float@*
@emph{Default}: 1.0@*
@* Tuning of the spin-orbit coupling strength: setting this value to zero turns off spin-orbit terms in
 the Hamiltonian, and setting it to one corresponds to full spin-orbit.



@c ----------------------------------
@item @strong{StaticElectricField}@*
@vindex @code{StaticElectricField}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: block@*
@* A static constant electric field may be added to the usual Hamiltonian,
 by setting the block @t{StaticElectricField}.
 The three possible components of the block (which should only have one
 line) are the three components of the electric field vector.
 It can be applied in a periodic direction of a large supercell via
 the single-point Berry phase.



@c ----------------------------------
@item @strong{StaticMagneticField}@*
@vindex @code{StaticMagneticField}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: block@*
@* A static constant magnetic field may be added to the usual Hamiltonian,
 by setting the block @t{StaticMagneticField}.
 The three possible components of the block (which should only have one
 line) are the three components of the magnetic field vector. Note that
 if you are running the code in 1D mode, this will not work, and if you
 are running the code in 2D mode the magnetic field will have to be in
 the @emph{z}-direction, so that the first two columns should be zero.
 Possible in periodic system only in these cases: 2D system, 1D periodic,
 with @t{StaticMagneticField2DGauge = linear_y};
 3D system, 1D periodic, field is zero in @emph{y}- and @emph{z}-directions (given
 currently implemented gauges).

 The magnetic field should always be entered in atomic units, regardless
 of the @t{Units} variable. Note that we use the "Gaussian" system
 meaning 1 au[B] = \( 2.350517568\times 10^9\) Gauss, which corresponds to
 \(2.3505175678\times 10^5\) Tesla.



@c ----------------------------------
@item @strong{StaticMagneticField2DGauge}@*
@vindex @code{StaticMagneticField2DGauge}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: integer@*
@emph{Default}: linear_xy@*
@* The gauge of the static vector potential \(A\) when a magnetic field
 \(B = \left( 0, 0, B_z \right)\) is applied to a 2D-system.


@emph{Options}:
@itemize @minus
@item @strong{linear_xy}:  Linear gauge with \(A = \frac{1}{2c} \left( -y, x \right) B_z\). (Cannot be used for periodic systems.)
@item @strong{linear_y}:  Linear gauge with \(A = \frac{1}{c} \left( -y, 0 \right) B_z\). Can be used for @t{PeriodicDimensions = 1}
 but not @t{PeriodicDimensions = 2}.
@end itemize

@c ----------------------------------
@item @strong{TheoryLevel}@*
@vindex @code{TheoryLevel}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: integer@*
@* The calculations can be run with different "theory levels" that
 control how electrons are simulated. The default is
 @t{dft}. When hybrid functionals are requested, through
 the @t{XCFunctional} variable, the default is
 @t{hartree_fock}.


@emph{Options}:
@itemize @minus
@item @strong{hartree}:  Calculation within the Hartree method (experimental). Note that, contrary to popular
 belief, the Hartree potential is self-interaction-free. Therefore, this run
 mode will not yield the same result as @t{kohn-sham} without exchange-correlation.
@item @strong{independent_particles}:  Particles will be considered as independent, @emph{i.e.} as non-interacting.
 This mode is mainly used for testing purposes, as the code is usually
 much faster with @t{independent_particles}.
@item @strong{hartree_fock}:  This is the traditional Hartree-Fock scheme. Like the Hartree scheme, it is fully
 self-interaction-free.
@item @strong{kohn_sham}:  This is the default density-functional theory scheme. Note that you can also use
 hybrid functionals in this scheme, but they will be handled the "DFT" way, @emph{i.e.},
 solving the OEP equation.
@item @strong{generalized_kohn_sham}:  This is similar to the @t{kohn-sham} scheme, except that this allows for nonlocal operators.
 This is the default mode to run hybrid functionals, meta-GGA functionals, or DFT+U.
 It can be more convenient to use @t{kohn-sham} DFT within the OEP scheme to get similar (but not the same) results.
 Note that within this scheme you can use a correlation functional, or a hybrid
 functional (see @t{XCFunctional}). In the latter case, you will be following the
 quantum-chemistry recipe to use hybrids.
@item @strong{rdmft}:  (Experimental) Reduced Density Matrix functional theory.
@end itemize

@c ----------------------------------
@item @strong{TimeZero}@*
@vindex @code{TimeZero}@*
@emph{Section}: Hamiltonian@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* (Experimental) If set to yes, the ground state and other time
 dependent calculation will assume that they are done at time
 zero, so that all time depedent field at that time will be
 included.



@c ----------------------------------
@end itemize
@node DFT+U,,,
@subsection DFT+U
@c ----------------------------------

@itemize
@item @strong{ACBN0IntersiteCutoff}@*
@vindex @code{ACBN0IntersiteCutoff}@*
@emph{Section}: Hamiltonian::DFT+U@*
@emph{Type}: float@*
@* The cutoff radius defining the maximal intersite distance considered.
 Only available with ACBN0 functional with intersite interaction.



@c ----------------------------------
@item @strong{ACBN0IntersiteInteraction}@*
@vindex @code{ACBN0IntersiteInteraction}@*
@emph{Section}: Hamiltonian::DFT+U@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* If set to yes, Octopus will determine the effective intersite interaction V
 Only available with ACBN0 functional.
 It is strongly recommended to set AOLoewdin=yes when using the option.



@c ----------------------------------
@item @strong{ACBN0RotationallyInvariant}@*
@vindex @code{ACBN0RotationallyInvariant}@*
@emph{Section}: Hamiltonian::DFT+U@*
@emph{Type}: logical@*
@* If set to yes, Octopus will use for U and J a formula which is rotationally invariant.
 This is different from the original formula for U and J.
 This is activated by default, except in the case of spinors, as this is not yet implemented in this case.



@c ----------------------------------
@item @strong{ACBN0Screening}@*
@vindex @code{ACBN0Screening}@*
@emph{Section}: Hamiltonian::DFT+U@*
@emph{Type}: float@*
@emph{Default}: 1.0@*
@* If set to 0, no screening will be included in the ACBN0 functional, and the U
 will be estimated from bare Hartree-Fock. If set to 1 (default), the full screening
 of the U, as defined in the ACBN0 functional, is used.



@c ----------------------------------
@item @strong{DFTUBasisFromStates}@*
@vindex @code{DFTUBasisFromStates}@*
@emph{Section}: Hamiltonian::DFT+U@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* If set to yes, Octopus will construct the localized basis from
 user-defined states. The states are taken at the Gamma point (or the first k-point of the
 states in the restart_proj folder.
 The states are defined via the block DFTUBasisStates



@c ----------------------------------
@item @strong{DFTUBasisStates}@*
@vindex @code{DFTUBasisStates}@*
@emph{Section}: Hamiltonian::DFT+U@*
@emph{Type}: block@*
@emph{Default}: none@*
@* Each line of this block contains the index of a state to be used to construct the
 localized basis. See DFTUBasisFromStates for details.



@c ----------------------------------
@item @strong{DFTUDoubleCounting}@*
@vindex @code{DFTUDoubleCounting}@*
@emph{Section}: Hamiltonian::DFT+U@*
@emph{Type}: integer@*
@emph{Default}: dft_u_fll@*
@* This variable selects which DFT+U
 double counting term is used.


@emph{Options}:
@itemize @minus
@item @strong{dft_u_fll}:  (Default) The Fully Localized Limit (FLL)
@item @strong{dft_u_amf}:  (Experimental) Around mean field double counting, as defined in PRB 44, 943 (1991) and PRB 49, 14211 (1994).
@end itemize

@c ----------------------------------
@item @strong{DFTUPoissonSolver}@*
@vindex @code{DFTUPoissonSolver}@*
@emph{Section}: Hamiltonian::DFT+U@*
@emph{Type}: integer@*
@* This variable selects which Poisson solver
 is used to compute the Coulomb integrals over a submesh.
 These are non-periodic Poisson solvers.
 The FFT Poisson solver with spherical cutoff is used by default.



@emph{Options}:
@itemize @minus
@item @strong{dft_u_poisson_direct}:  Direct Poisson solver. Slow but working in all cases.
@item @strong{dft_u_poisson_isf}:  (Experimental) ISF Poisson solver on a submesh.
 This does not work for non-orthogonal cells nor domain parallelization.
@item @strong{dft_u_poisson_psolver}:  (Experimental) PSolver Poisson solver on a submesh.
 This does not work for non-orthogonal cells nor domain parallelization.
 Requires the PSolver external library.
@item @strong{dft_u_poisson_fft}:  (Default) FFT Poisson solver on a submesh.
 This uses the 0D periodic version of the FFT kernels.
@end itemize

@c ----------------------------------
@item @strong{SkipSOrbitals}@*
@vindex @code{SkipSOrbitals}@*
@emph{Section}: Hamiltonian::DFT+U@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* If set to yes, Octopus will determine the effective U for all atomic orbitals
 from the peusopotential but s orbitals. Only available with ACBN0 functional.



@c ----------------------------------
@item @strong{UseAllAtomicOrbitals}@*
@vindex @code{UseAllAtomicOrbitals}@*
@emph{Section}: Hamiltonian::DFT+U@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* If set to yes, Octopus will determine the effective U for all atomic orbitals
 from the peusopotential. Only available with ACBN0 functional.
 It is strongly recommended to set AOLoewdin=yes when using the option.



@c ----------------------------------
@end itemize
@node PCM,,,
@subsection PCM
@c ----------------------------------

@itemize
@item @strong{PCMCalcMethod}@*
@vindex @code{PCMCalcMethod}@*
@emph{Section}: Hamiltonian::PCM@*
@emph{Type}: integer@*
@emph{Default}: pcm_direct@*
@* Defines the method to be used to obtain the PCM potential.


@emph{Options}:
@itemize @minus
@item @strong{pcm_direct}:  Direct sum of the potential generated by the polarization charges regularized
 with a Gaussian smearing [A. Delgado, et al., J Chem Phys 143, 144111 (2015)].
@item @strong{pcm_poisson}:  Solving the Poisson equation for the polarization charge density.
@end itemize

@c ----------------------------------
@item @strong{PCMCalculation}@*
@vindex @code{PCMCalculation}@*
@emph{Section}: Hamiltonian::PCM@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* If true, the calculation is performed accounting for solvation effects
 by using the Integral Equation Formalism Polarizable Continuum Model IEF-PCM
 formulated in real-space and real-time (@emph{J. Chem. Phys.} @strong{143}, 144111 (2015),
 @emph{Chem. Rev.} @strong{105}, 2999 (2005), @emph{J. Chem. Phys.} @strong{139}, 024105 (2013)).
 At the moment, this option is available only for @t{TheoryLevel = DFT}.
 PCM is tested for CalculationMode = gs, while still experimental for other values (in particular, CalculationMode = td).



@c ----------------------------------
@item @strong{PCMCavity}@*
@vindex @code{PCMCavity}@*
@emph{Section}: Hamiltonian::PCM@*
@emph{Type}: string@*
@* Name of the file containing the geometry of the cavity hosting the solute molecule.
 The data must be in atomic units and the file must contain the following information sequentially:
  T               < Number of tesserae
  s_x(1:T)        < coordinates x of the tesserae
  s_y(1:T)        < coordinates y of the tesserae
  s_z(1:T)        < coordinates z of the tesserae
  A(1:T)          < areas of the tesserae
  R_sph(1:T)      < Radii of the spheres to which the tesserae belong
  normal(1:T,1:3) < Outgoing unitary vectors at the tesserae surfaces



@c ----------------------------------
@item @strong{PCMChargeSmearNN}@*
@vindex @code{PCMChargeSmearNN}@*
@emph{Section}: Hamiltonian::PCM@*
@emph{Type}: integer@*
@emph{Default}: 2 * max_area * PCMSmearingFactor@*
@* Defines the number of nearest neighbor mesh-points to be taken around each
 cavity tessera in order to smear the charge when PCMCalcMethod = pcm_poisson.
 Setting PCMChargeSmearNN = 1 means first nearest neighbors, PCMChargeSmearNN = 2
 second nearest neighbors, and so on.
 The default value is such that the neighbor mesh contains points in a radius
 equal to the width used for the gaussian smearing.



@c ----------------------------------
@item @strong{PCMDebyeRelaxTime}@*
@vindex @code{PCMDebyeRelaxTime}@*
@emph{Section}: Hamiltonian::PCM@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* Relaxation time of the solvent within Debye model (\(\tau\)). Recall Debye dieletric function:
 \(\varepsilon(\omega)=\varepsilon_d+\frac{\varepsilon_0-\varepsilon_d}{1-i\omega\tau}\)



@c ----------------------------------
@item @strong{PCMDrudeLDamping}@*
@vindex @code{PCMDrudeLDamping}@*
@emph{Section}: Hamiltonian::PCM@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* Damping factor of the solvent charges oscillations within Drude-Lorentz model (\(\gamma\)).
 Recall Drude-Lorentz dielectric function: \(\varepsilon(\omega)=1+\frac{A}{\omega_0^2-\omega^2+i\gamma\omega}\)



@c ----------------------------------
@item @strong{PCMDrudeLOmega}@*
@vindex @code{PCMDrudeLOmega}@*
@emph{Section}: Hamiltonian::PCM@*
@emph{Type}: float@*
@emph{Default}: \(\sqrt{1/(\varepsilon_0-1)}\)@*
@* Resonance frequency of the solvent within Drude-Lorentz model (\(\omega_0\)).
 Recall Drude-Lorentz dielectric function: \(\varepsilon(\omega)=1+\frac{A}{\omega_0^2-\omega^2+i\gamma\omega}\)
 Default values of \(\omega_0\) guarantee to recover static dielectric constant.



@c ----------------------------------
@item @strong{PCMDynamicEpsilon}@*
@vindex @code{PCMDynamicEpsilon}@*
@emph{Section}: Hamiltonian::PCM@*
@emph{Type}: float@*
@emph{Default}: PCMStaticEpsilon@*
@* High-frequency dielectric constant of the solvent (\(\varepsilon_d\)).
 \(\varepsilon_d=\varepsilon_0\) indicate equilibrium with solvent.



@c ----------------------------------
@item @strong{PCMEoMInitialCharges}@*
@vindex @code{PCMEoMInitialCharges}@*
@emph{Section}: Hamiltonian::PCM@*
@emph{Type}: integer@*
@* If =0 the propagation of the solvent polarization charges starts from internally generated initial charges
  in equilibrium with the initial potential.
 For Debye EOM-PCM, if >0 the propagation of the solvent polarization charges starts from initial charges from input file.
 										if =1, initial pol. charges due to solute electrons are read from input file.
 										else if =2, initial pol. charges due to external potential are read from input file.
 										else if =3, initial pol. charges due to solute electrons and external potential are read from input file.
 Files should be located in pcm directory and are called ASC_e.dat and ASC_ext.dat, respectively.
 The latter files are generated after any PCM run and contain the last values of the polarization charges.



@c ----------------------------------
@item @strong{PCMEpsilonModel}@*
@vindex @code{PCMEpsilonModel}@*
@emph{Section}: Hamiltonian::PCM@*
@emph{Type}: integer@*
@emph{Default}: pcm_debye@*
@* Define the dielectric function model.


@emph{Options}:
@itemize @minus
@item @strong{pcm_debye}:  Debye model: \(\varepsilon(\omega)=\varepsilon_d+\frac{\varepsilon_0-\varepsilon_d}{1-i\omega\tau}\)
@item @strong{pcm_drude}:  Drude-Lorentz model: \(\varepsilon(\omega)=1+\frac{A}{\omega_0^2-\omega^2+i\gamma\omega}\)
@end itemize

@c ----------------------------------
@item @strong{PCMGamessBenchmark}@*
@vindex @code{PCMGamessBenchmark}@*
@emph{Section}: Hamiltonian::PCM@*
@emph{Type}: logical@*
@emph{Default}: .false.@*
@* If PCMGamessBenchmark is set to "yes", the pcm_matrix is also written in a Gamess format.
 for benchamarking purposes.



@c ----------------------------------
@item @strong{PCMKick}@*
@vindex @code{PCMKick}@*
@emph{Section}: Hamiltonian::PCM@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* This variable controls the effect the kick has on the polarization of the solvent.
 If .true.  ONLY the FAST degrees-of-freedom of the solvent follow the kick. The potential due to polarization charges behaves
  as another kick, i.e., it is a delta-perturbation.
 If .false. ALL           degrees-of-freedom of the solvent follow the kick. The potential due to polarization charges evolves
  following an equation of motion. When Debye dielectric model is used, just a part of the potential behaves as another kick.



@c ----------------------------------
@item @strong{PCMLocalField}@*
@vindex @code{PCMLocalField}@*
@emph{Section}: Hamiltonian::PCM@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* This variable is a flag for including local field effects when an external field is applied. The total field interacting with
 the molecule (also known as cavity field) is not the bare field in the solvent (the so-called Maxwell field), but it also
 include a contribution due to the polarization of the solvent. The latter is calculated here within the PCM framework.
 See [G. Gil, et al., J. Chem. Theory Comput., 2019, 15 (4), pp 23062319].



@c ----------------------------------
@item @strong{PCMQtotTol}@*
@vindex @code{PCMQtotTol}@*
@emph{Section}: Hamiltonian::PCM@*
@emph{Type}: float@*
@emph{Default}: 0.5@*
@* If @t{PCMRenormCharges=.true.} and  \(\delta Q = |[\sum_i q_i| - ((\epsilon-1)/\epsilon)*|Q_M]|>PCMQtotTol\)
 the polarization charges will be normalized as
 \(q_i^\prime=q_i + signfunction(e, n, \delta Q) (q_i/q_{tot})*\delta Q\)
 with \(q_{tot} = \sum_i q_i\). For values of \(\delta Q > 0.5\)
 (printed by the code in the file pcm/pcm_info.out) even, if polarization charges are renormalized,
 the calculated results might be inaccurate or erroneous.



@c ----------------------------------
@item @strong{PCMRadiusScaling}@*
@vindex @code{PCMRadiusScaling}@*
@emph{Section}: Hamiltonian::PCM@*
@emph{Type}: float@*
@* Scales the radii of the spheres used to build the solute cavity surface.
 The default value depends on the choice of @t{PCMVdWRadii}:
 1.2 for @t{pcm_vdw_optimized} and 1.0 for @t{pcm_vdw_species}.



@c ----------------------------------
@item @strong{PCMRenormCharges}@*
@vindex @code{PCMRenormCharges}@*
@emph{Section}: Hamiltonian::PCM@*
@emph{Type}: logical@*
@emph{Default}: .false.@*
@* If .true. renormalization of the polarization charges is performed to enforce fulfillment
 of the Gauss law, \(\sum_i q_i^{e/n} = -[(\epsilon-1)/\epsilon] Q_M^{e/n}\) where
 \(q_i^{e/n}\) are the polarization charges induced by the electrons/nuclei of the molecule
 and \(Q_M^{e/n}\) is the nominal electronic/nuclear charge of the system. This can be needed
 to treat molecules in weakly polar solvents.



@c ----------------------------------
@item @strong{PCMSmearingFactor}@*
@vindex @code{PCMSmearingFactor}@*
@emph{Section}: Hamiltonian::PCM@*
@emph{Type}: float@*
@emph{Default}: 1.0@*
@* Parameter used to control the width (area of each tessera) of the Gaussians used to distribute
 the polarization charges on each tessera (arXiv:1507.05471). If set to zero, the solvent
 reaction potential in real-space is defined by using point charges.



@c ----------------------------------
@item @strong{PCMSolute}@*
@vindex @code{PCMSolute}@*
@emph{Section}: Hamiltonian::PCM@*
@emph{Type}: logical@*
@emph{Default}: yes@*
@* This variable is a flag for including polarization effects of the solvent due to the solute.
 (Useful for analysis) When external fields are applied, turning off the solvent-molecule interaction (PCMSolute=no) and
 activating the solvent polarization due to the applied field (PCMLocalField=yes) allows to include only local field effects.



@c ----------------------------------
@item @strong{PCMSpheresOnH}@*
@vindex @code{PCMSpheresOnH}@*
@emph{Section}: Hamiltonian::PCM@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* If true, spheres centered at the Hydrogens atoms are included to build the solute cavity surface.



@c ----------------------------------
@item @strong{PCMStaticEpsilon}@*
@vindex @code{PCMStaticEpsilon}@*
@emph{Section}: Hamiltonian::PCM@*
@emph{Type}: float@*
@emph{Default}: 1.0@*
@* Static dielectric constant of the solvent (\(\varepsilon_0\)). 1.0 indicates gas phase.



@c ----------------------------------
@item @strong{PCMTDLevel}@*
@vindex @code{PCMTDLevel}@*
@emph{Section}: Hamiltonian::PCM@*
@emph{Type}: integer@*
@emph{Default}: eq@*
@* When CalculationMode=td, PCMTDLevel it sets the way the time-depenendent solvent polarization is propagated.


@emph{Options}:
@itemize @minus
@item @strong{eq}:  If PCMTDLevel=eq, the solvent is always in equilibrium with the solute or the external field, i.e.,
 the solvent polarization follows instantaneously the changes in solute density or in the external field.
 PCMTDLevel=neq and PCMTDLevel=eom are both nonequilibrium runs.
@item @strong{neq}:  If PCMTDLevel=neq, solvent polarization charges are splitted in two terms:
 one that follows instantaneously the changes in the solute density or in the external field (dynamical polarization charges),
 and another that lag behind in the evolution w.r.t. the solute density or the external field (inertial polarization charges).
@item @strong{eom}:  If PCMTDLevel=eom, solvent polarization charges evolves following an equation of motion, generalizing 'neq' propagation.
 The equation of motion used here depends on the value of PCMEpsilonModel.
@end itemize

@c ----------------------------------
@item @strong{PCMTessMinDistance}@*
@vindex @code{PCMTessMinDistance}@*
@emph{Section}: Hamiltonian::PCM@*
@emph{Type}: float@*
@emph{Default}: 0.1@*
@* Minimum distance between tesserae.
 Any two tesserae having smaller distance in the starting tesselation will be merged together.



@c ----------------------------------
@item @strong{PCMTessSubdivider}@*
@vindex @code{PCMTessSubdivider}@*
@emph{Section}: Hamiltonian::PCM@*
@emph{Type}: integer@*
@emph{Default}: 1@*
@* Allows to subdivide further each tessera refining the discretization of the cavity tesselation.
 Can take only two values, 1 or 4. 1 corresponds to 60 tesserae per sphere, while 4 corresponds to 240 tesserae per sphere.



@c ----------------------------------
@item @strong{PCMUpdateIter}@*
@vindex @code{PCMUpdateIter}@*
@emph{Section}: Hamiltonian::PCM@*
@emph{Type}: integer@*
@emph{Default}: 1@*
@* Defines how often the PCM potential is updated during time propagation.



@c ----------------------------------
@item @strong{PCMVdWRadii}@*
@vindex @code{PCMVdWRadii}@*
@emph{Section}: Hamiltonian::PCM@*
@emph{Type}: integer@*
@emph{Default}: pcm_vdw_optimized@*
@* This variable selects which van der Waals radius will be used to generate the solvent cavity.


@emph{Options}:
@itemize @minus
@item @strong{pcm_vdw_optimized}:  Use the van der Waals radius optimized by Stefan Grimme in J. Comput. Chem. 27: 1787-1799, 2006,
 except for C, N and O, reported in J. Chem. Phys. 120, 3893 (2004).
@item @strong{pcm_vdw_species}:  The vdW radii are set from the @t{share/pseudopotentials/elements} file. These values are obtained from
 Alvarez S., Dalton Trans., 2013, 42, 8617-8636. Values can be changed in the @t{Species} block.
@end itemize

@c ----------------------------------
@end itemize
@node Poisson,,,
@subsection Poisson
@c ----------------------------------

@itemize
@item @strong{AlphaFMM}@*
@vindex @code{AlphaFMM}@*
@emph{Section}: Hamiltonian::Poisson@*
@emph{Type}: float@*
@emph{Default}: 0.291262136@*
@* Dimensionless parameter for the correction of the self-interaction of the
 electrostatic Hartree potential, when using @t{PoissonSolver = FMM}.

 Octopus represents charge density on a real-space grid, each
 point containing a value \(\rho\) corresponding to the charge
 density in the cell centered in such point. Therefore, the
 integral for the Hartree potential at point \(i\), \(V_H(i)\), can be reduced to a summation:

 \(V_H(i) = \frac{\Omega}{4\pi\varepsilon_0} \sum_{i \neq j}
 \frac{\rho(\vec{r}(j))}{|\vec{r}(j) - \vec{r}(i)|} + V_{self.int.}(i)\)
 where \(\Omega\) is the volume element of the mesh, and \(\vec{r}(j)\) is the
 position of the point \(j\). The \(V_{self.int.}(i)\) corresponds to
 the integral over the cell centered on the point \(i\) that is necessary to
 calculate the Hartree potential at point \(i\):

 \(V_{self.int.}(i)=\frac{1}{4\pi\varepsilon_0}
 \int_{\Omega(i)}d\vec{r} \frac{\rho(\vec{r}(i))}{|\vec{r}-\vec{r}(i)|}\)

 In the FMM version implemented into Octopus, a correction method
 for \(V_H(i)\) is used
 (see Garc&iacute;a-Risue&ntilde;o @emph{et al.}, @emph{J. Comp. Chem.} @strong{35}, 427 (2014)).
 This method defines cells neighbouring cell \(i\), which
 have volume \(\Omega(i)/8\) (in 3D) and charge density obtained by
 interpolation. In the calculation of \(V_H(i)\), in order to avoid
 double counting of charge, and to cancel part of the errors arising
 from considering the distances constant in the summation above, a
 term \(-\alpha_{FMM}V_{self.int.}(i)\) is added to the summation (see
 the paper for the explicit formulae).



@c ----------------------------------
@item @strong{DeltaEFMM}@*
@vindex @code{DeltaEFMM}@*
@emph{Section}: Hamiltonian::Poisson@*
@emph{Type}: float@*
@emph{Default}: 0.0001@*
@* Dimensionless parameter for relative convergence of @t{PoissonSolver = FMM}.
 Sets energy error bound.
 Strong inhomogeneous systems may violate the error bound.
 For inhomogeneous systems we have an error-controlled sequential version available
 (from Ivo Kabadshow).

 Our implementation of FMM (based on H. Dachsel, @emph{J. Chem. Phys.} @strong{131},
 244102 (2009)) can keep the error of the Hartree energy below an
 arbitrary bound. The quotient of the value chosen for the maximum
 error in the Hartree energy and the value of the Hartree energy is
 @t{DeltaEFMM}.




@c ----------------------------------
@item @strong{DressedOrbitals}@*
@vindex @code{DressedOrbitals}@*
@emph{Section}: Hamiltonian::Poisson@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* Allows for the calculation of coupled elecron-photon problems
 by applying the dressed orbital approach. Details can be found in
 https://arxiv.org/abs/1812.05562
 At the moment, N electrons in d (<=3) spatial dimensions, coupled
 to one photon mode can be described. The photon mode is included by
 raising the orbital dimension to d+1 and changing the particle interaction
 kernel and the local potential, where the former is included automatically,
 but the latter needs to by added by hand as a user_defined_potential!
 Coordinate 1-d: electron; coordinate d+1: photon.



@c ----------------------------------
@item @strong{Poisson1DSoftCoulombParam}@*
@vindex @code{Poisson1DSoftCoulombParam}@*
@emph{Section}: Hamiltonian::Poisson@*
@emph{Type}: float@*
@emph{Default}: 1.0 bohr@*
@* When @t{Dimensions = 1}, to prevent divergence, the Coulomb interaction treated by the Poisson
 solver is not \(1/r\) but \(1/\sqrt{a^2 + r^2}\), where this variable sets the value of \(a\).



@c ----------------------------------
@item @strong{PoissonCutoffRadius}@*
@vindex @code{PoissonCutoffRadius}@*
@emph{Section}: Hamiltonian::Poisson@*
@emph{Type}: float@*
@* When @t{PoissonSolver = fft} and @t{PoissonFFTKernel} is neither @t{multipole_corrections}
 nor @t{fft_nocut},
 this variable controls the distance after which the electron-electron interaction goes to zero.
 A warning will be written if the value is too large and will cause spurious interactions between images.
 The default is half of the FFT box max dimension in a finite direction.



@c ----------------------------------
@item @strong{PoissonFFTKernel}@*
@vindex @code{PoissonFFTKernel}@*
@emph{Section}: Hamiltonian::Poisson@*
@emph{Type}: integer@*
@* Defines which kernel is used to impose the correct boundary
 conditions when using FFTs to solve the Poisson equation. The
 default is selected depending on the dimensionality and
 periodicity of the system:
 @*In 1D, @t{spherical} if finite, @t{fft_nocut} if periodic.
 @*In 2D, @t{spherical} if finite, @t{cylindrical} if 1D-periodic, @t{fft_nocut} if 2D-periodic.
 @*In 3D, @t{spherical} if finite, @t{cylindrical} if 1D-periodic, @t{planar} if 2D-periodic,
 @t{fft_nocut} if 3D-periodic.
 See C. A. Rozzi et al., @emph{Phys. Rev. B} @strong{73}, 205119 (2006) for 3D implementation and
 A. Castro et al., @emph{Phys. Rev. B} @strong{80}, 033102 (2009) for 2D implementation.


@emph{Options}:
@itemize @minus
@item @strong{spherical}:  FFTs using spherical cutoff (in 2D or 3D).
@item @strong{cylindrical}:  FFTs using cylindrical cutoff (in 2D or 3D).
@item @strong{planar}:  FFTs using planar cutoff (in 3D).
@item @strong{fft_nocut}:  FFTs without using a cutoff (for fully periodic systems).
@item @strong{multipole_correction}:  The boundary conditions are imposed by using a multipole expansion. Only appropriate for finite systems.
 Further specification occurs with variables @t{PoissonSolverBoundaries} and @t{PoissonSolverMaxMultipole}.
@end itemize

@c ----------------------------------
@item @strong{PoissonSolver}@*
@vindex @code{PoissonSolver}@*
@emph{Section}: Hamiltonian::Poisson@*
@emph{Type}: integer@*
@* Defines which method to use to solve the Poisson equation. Some incompatibilities apply depending on
 dimensionality, periodicity, etc.
 For a comparison of the accuracy and performance of the methods in Octopus, see P Garcia-Risue&ntilde;o,
 J Alberdi-Rodriguez @emph{et al.}, @emph{J. Comp. Chem.} @strong{35}, 427-444 (2014)
 or <a href=http://arxiv.org/abs/1211.2092>arXiV</a>.
 Defaults:
 @* 1D and 2D: @t{fft}.
 @* 3D: @t{cg_corrected} if curvilinear, @t{isf} if not periodic, @t{fft} if periodic.
 @* Dressed orbitals: @t{direct_sum}.


@emph{Options}:
@itemize @minus
@item @strong{direct_sum}:  Direct evaluation of the Hartree potential (only for finite systems).
@item @strong{FMM}:  (Experimental) Fast multipole method. Requires FMM library.
@item @strong{NoPoisson}:  Do not use a Poisson solver at all.
@item @strong{fft}:  The Poisson equation is solved using FFTs. A cutoff technique
 for the Poisson kernel is selected so the proper boundary
 conditions are imposed according to the periodicity of the
 system. This can be overridden by the @t{PoissonFFTKernel}
 variable. To choose the FFT library use @t{FFTLibrary}
@item @strong{psolver}:  Solver based on Interpolating Scaling Functions as implemented in the PSolver library.
 Parallelization in k-points requires @t{PoissonSolverPSolverParallelData} = no.
 Requires the PSolver external library.
@item @strong{poke}:  (Experimental) Solver from the Poke library.
@item @strong{cg}:  Conjugate gradients (only for finite systems).
@item @strong{cg_corrected}:  Conjugate gradients, corrected for boundary conditions (only for finite systems).
@item @strong{multigrid}:  Multigrid method (only for finite systems).
@item @strong{isf}:  Interpolating Scaling Functions Poisson solver (only for finite systems).
@end itemize

@c ----------------------------------
@item @strong{PoissonSolverBoundaries}@*
@vindex @code{PoissonSolverBoundaries}@*
@emph{Section}: Hamiltonian::Poisson@*
@emph{Type}: integer@*
@emph{Default}: multipole@*
@* For finite systems, some Poisson solvers (@t{multigrid},
 @t{cg_corrected}, and @t{fft} with @t{PoissonFFTKernel = multipole_correction})
 require the calculation of the
 boundary conditions with an auxiliary method. This variable selects that method.


@emph{Options}:
@itemize @minus
@item @strong{multipole}:  A multipole expansion of the density is used to approximate the potential on the boundaries.
@item @strong{exact}:  An exact integration of the Poisson equation is done over the boundaries. This option is
 experimental, and not implemented for domain parallelization.
@end itemize

@c ----------------------------------
@item @strong{PoissonSolverMaxIter}@*
@vindex @code{PoissonSolverMaxIter}@*
@emph{Section}: Hamiltonian::Poisson@*
@emph{Type}: integer@*
@emph{Default}: 500@*
@* The maximum number of iterations for conjugate-gradient
 Poisson solvers.



@c ----------------------------------
@item @strong{PoissonSolverMaxMultipole}@*
@vindex @code{PoissonSolverMaxMultipole}@*
@emph{Section}: Hamiltonian::Poisson@*
@emph{Type}: integer@*
@* Order of the multipolar expansion for boundary corrections.

 The Poisson solvers @t{multigrid}, @t{cg}, and @t{cg_corrected}
 (and @t{fft} with @t{PoissonFFTKernel = multipole_correction})
 do a multipolar expansion of the given
 charge density, such that \(\rho = \rho_{multip.expansion}+\Delta
 \rho\). The Hartree potential due to the \(\rho_{multip.expansion}\) is
 calculated analytically, while the Hartree potential due to \(\Delta \rho\)
 is calculated with either a multigrid or cg solver.
 The order of the multipolar expansion is set by this variable.

 Default is 4 for @t{PoissonSolver = cg_corrected} and @t{multigrid}, and 2
 for @t{fft} with @t{PoissonFFTKernel = multipole_correction}.



@c ----------------------------------
@item @strong{PoissonSolverNodes}@*
@vindex @code{PoissonSolverNodes}@*
@emph{Section}: Hamiltonian::Poisson@*
@emph{Type}: integer@*
@* How many nodes to use to solve the Poisson equation. A value of
 0, the default, implies that all available nodes are used.



@c ----------------------------------
@item @strong{PoissonSolverThreshold}@*
@vindex @code{PoissonSolverThreshold}@*
@emph{Section}: Hamiltonian::Poisson@*
@emph{Type}: float@*
@emph{Default}: 1e-6@*
@* The tolerance for the Poisson solution, used by the @t{cg},
 @t{cg_corrected}, and @t{multigrid} solvers.



@c ----------------------------------
@item @strong{PoissonTestPeriodicThreshold}@*
@vindex @code{PoissonTestPeriodicThreshold}@*
@emph{Section}: Hamiltonian::Poisson@*
@emph{Type}: float@*
@emph{Default}: 1e-5@*
@* This threshold determines the accuracy of the periodic copies of
 the Gaussian charge distribution that are taken into account when
 computing the analytical solution for periodic systems.
 Be aware that the default leads to good results for systems
 that are periodic in 1D - for 3D it is very costly because of the
 large number of copies needed.



@c ----------------------------------
@end itemize
@node Multigrid,,,
@subsubsection Multigrid
@c ----------------------------------

@itemize
@item @strong{PoissonSolverMGMaxCycles}@*
@vindex @code{PoissonSolverMGMaxCycles}@*
@emph{Section}: Hamiltonian::Poisson::Multigrid@*
@emph{Type}: integer@*
@emph{Default}: 60@*
@* Maximum number of multigrid cycles that are performed if
 convergence is not achieved.



@c ----------------------------------
@item @strong{PoissonSolverMGPostsmoothingSteps}@*
@vindex @code{PoissonSolverMGPostsmoothingSteps}@*
@emph{Section}: Hamiltonian::Poisson::Multigrid@*
@emph{Type}: integer@*
@emph{Default}: 4@*
@* Number of Gauss-Seidel smoothing steps after coarse-level
 correction in the multigrid Poisson solver.



@c ----------------------------------
@item @strong{PoissonSolverMGPresmoothingSteps}@*
@vindex @code{PoissonSolverMGPresmoothingSteps}@*
@emph{Section}: Hamiltonian::Poisson::Multigrid@*
@emph{Type}: integer@*
@emph{Default}: 1@*
@* Number of Gauss-Seidel smoothing steps before coarse-level
 correction in the multigrid Poisson solver.



@c ----------------------------------
@item @strong{PoissonSolverMGRelaxationFactor}@*
@vindex @code{PoissonSolverMGRelaxationFactor}@*
@emph{Section}: Hamiltonian::Poisson::Multigrid@*
@emph{Type}: float@*
@* Relaxation factor of the relaxation operator used for the
 multigrid method. This is mainly for debugging,
 since overrelaxation does not help in a multigrid scheme.
 The default is 1.0, except 0.6666 for the @t{gauss_jacobi} method.



@c ----------------------------------
@item @strong{PoissonSolverMGRelaxationMethod}@*
@vindex @code{PoissonSolverMGRelaxationMethod}@*
@emph{Section}: Hamiltonian::Poisson::Multigrid@*
@emph{Type}: integer@*
@* Method used to solve the linear system approximately in each grid for the
 multigrid procedure that solves Poisson equation. Default is @t{gauss_seidel},
 unless curvilinear coordinates are used, in which case the default is @t{gauss_jacobi}.


@emph{Options}:
@itemize @minus
@item @strong{gauss_seidel}:  Gauss-Seidel.
@item @strong{gauss_jacobi}:  Gauss-Jacobi.
@item @strong{gauss_jacobi2}:  Alternative implementation of Gauss-Jacobi.
@end itemize

@c ----------------------------------
@item @strong{PoissonSolverMGRestrictionMethod}@*
@vindex @code{PoissonSolverMGRestrictionMethod}@*
@emph{Section}: Hamiltonian::Poisson::Multigrid@*
@emph{Type}: integer@*
@emph{Default}: fullweight@*
@* Method used from fine-to-coarse grid transfer.


@emph{Options}:
@itemize @minus
@item @strong{injection}:  Injection
@item @strong{fullweight}:  Fullweight restriction
@end itemize

@c ----------------------------------
@end itemize
@node PSolver,,,
@subsubsection PSolver
@c ----------------------------------

@itemize
@item @strong{PoissonSolverPSolverParallelData}@*
@vindex @code{PoissonSolverPSolverParallelData}@*
@emph{Section}: Hamiltonian::Poisson::PSolver@*
@emph{Type}: logical@*
@emph{Default}: yes@*
@* Indicates whether data is partitioned within the PSolver library.
 If data is distributed among processes, Octopus uses parallel data-structures
 and, thus, less memory.
 If "yes", data is parallelized. The @emph{z}-axis of the input vector
 is split among the MPI processes.
 If "no", entire input and output vector is saved in all the MPI processes.
 If k-points parallelization is used, "no" must be selected.



@c ----------------------------------
@end itemize
@node XC,,,
@subsection XC
@c ----------------------------------

@itemize
@item @strong{DFTULevel}@*
@vindex @code{DFTULevel}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: integer@*
@emph{Default}: no@*
@* This variable selects which DFT+U expression is added to the Hamiltonian.


@emph{Options}:
@itemize @minus
@item @strong{dft_u_none}:  No +U term is not applied.
@item @strong{dft_u_empirical}:  An empiricial Hubbard U is added on the orbitals specified in the block species
 with hubbard_l and hubbard_u
@item @strong{dft_u_acbn0}:  Octopus determines the effective U term using the
 ACBN0 functional as defined in PRX 5, 011006 (2015)
@end itemize

@c ----------------------------------
@item @strong{HFSingularity}@*
@vindex @code{HFSingularity}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: integer@*
@emph{Default}: general@*
@* (Experimental) This variable selects the method used for the treatment of the
 singularity of the Coulomb potential in Hatree-Fock and hybrid-functional DFT calculations.
 This shoulbe be only applied for periodic systems and is only
 used for FFT kernels of the Poisson solvers.


@emph{Options}:
@itemize @minus
@item @strong{none}:  The singularity is replaced by zero.
@item @strong{general}:  The general treatment of the singularity, as described in Carrier et al, PRB 75 205126 (2007).
 This is the default option
@item @strong{fcc}:  The treatment of the singulariy as described in Gygi and Baldereschi, PRB 34, 4405 (1986).
 This is formally valid for cubic systems only.
@item @strong{spherical_bz}:  The divergence in q=0 is treated analytically assuming a spherical Brillouin zone
@end itemize

@c ----------------------------------
@item @strong{HFSingularityNk}@*
@vindex @code{HFSingularityNk}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: integer@*
@emph{Default}: 60 in 3D, 1200 in 1D@*
@* Number of k-point used (total number of k-points) is (2*Nk+1)^3) in the numerical integration
 of the auxiliary function f(q). See PRB 75, 205126 (2007) for more details.
 Only for HFSingularity=general.
 Also used in 1D.



@c ----------------------------------
@item @strong{HFSingularityNsteps}@*
@vindex @code{HFSingularityNsteps}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: integer@*
@emph{Default}: 7 in 3D, 15 in 1D@*
@* Number of grid refinement steps in the numerical integration of the auxiliary function f(q).
 See PRB 75, 205126 (2007) for more details. Only for HFSingularity=general.
 Also used in 1D.



@c ----------------------------------
@item @strong{Interaction1D}@*
@vindex @code{Interaction1D}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: integer@*
@emph{Default}: interaction_soft_coulomb@*
@* When running in 1D, one has to soften the Coulomb interaction. This softening
 is not unique, and several possibilities exist in the literature.


@emph{Options}:
@itemize @minus
@item @strong{interaction_exp_screened}:  Exponentially screened Coulomb interaction.
 See, @emph{e.g.}, M Casula, S Sorella, and G Senatore, @emph{Phys. Rev. B} @strong{74}, 245427 (2006).
@item @strong{interaction_soft_coulomb}:  Soft Coulomb interaction of the form \(1/\sqrt{x^2 + \alpha^2}\).
@end itemize

@c ----------------------------------
@item @strong{Interaction1DScreening}@*
@vindex @code{Interaction1DScreening}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: float@*
@emph{Default}: 1.0@*
@* Defines the screening parameter \(\alpha\) of the softened Coulomb interaction
 when running in 1D.



@c ----------------------------------
@item @strong{KLIPhotonCOC}@*
@vindex @code{KLIPhotonCOC}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: logical@*
@emph{Default}: .false.@*
@* Activate the center of charge translation of the electric dipole operator which should avoid the dependence of the photon KLI on an permanent dipole.



@c ----------------------------------
@item @strong{OEPLevel}@*
@vindex @code{OEPLevel}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: integer@*
@emph{Default}: oep_kli@*
@* At what level shall @t{Octopus} handle the optimized effective potential (OEP) equation.


@emph{Options}:
@itemize @minus
@item @strong{oep_none}:  Do not solve OEP equation.
@item @strong{oep_kli}:  Krieger-Li-Iafrate (KLI) approximation.
 Ref: JB Krieger, Y Li, GJ Iafrate, @emph{Phys. Lett. A} @strong{146}, 256 (1990).
@item @strong{oep_full}:  (Experimental) Full solution of OEP equation using the Sternheimer approach.
 The linear solver will be controlled by the variables in section @t{Linear Response::Solver},
 and the iterations for OEP by @t{Linear Response::SCF in LR calculations} and variable
 @t{OEPMixing}. Note that default for @t{LRMaximumIter} is set to 10.
 Ref: S. Kuemmel and J. Perdew, @emph{Phys. Rev. Lett.} @strong{90}, 043004 (2003).
@end itemize

@c ----------------------------------
@item @strong{OEPMixing}@*
@vindex @code{OEPMixing}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: float@*
@emph{Default}: 1.0@*
@* The linear mixing factor used to solve the Sternheimer
 equation in the full OEP procedure.



@c ----------------------------------
@item @strong{OEPMixingScheme}@*
@vindex @code{OEPMixingScheme}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: integer@*
@emph{Default}: 1.0@*
@* Different Mixing Schemes are possible


@emph{Options}:
@itemize @minus
@item @strong{OEP_MIXING_SCHEME_CONST}:  Use a constant
 Reference: S. Kuemmel and J. Perdew, @emph{Phys. Rev. Lett.} @strong{90}, 4, 043004 (2003)
@item @strong{OEP_MIXING_SCHEME_BB}:  Use the Barzilai-Borwein (BB) Method
 Reference: T. W. Hollins, S. J. Clark, K. Refson, and N. I. Gidopoulos,
 @emph{Phys. Rev. B} @strong{85}, 235126 (2012)
@item @strong{OEP_MIXING_SCHEME_DENS}:  Use the inverse of the electron density
 Reference: S. Kuemmel and J. Perdew, @emph{Phys. Rev. B} @strong{68}, 035103 (2003)
@end itemize

@c ----------------------------------
@item @strong{PhotonModes}@*
@vindex @code{PhotonModes}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: block@*
@* Each line of the block should specify one photon mode. The syntax is the following:

 %PhotonModes
  omega1 | lambda1| PolX1 | PolY1 | PolZ1
  ...
 %

 The first column is the mode frequency, in units of energy.
 The second column is the coupling strength, in units of energy.
 The remaining columns specify the polarization direction of the mode.
 If the polarization vector should be normalized to one. If that is not the case
 the code will normalize it.



@c ----------------------------------
@item @strong{SICCorrection}@*
@vindex @code{SICCorrection}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: integer@*
@emph{Default}: sic_none@*
@* This variable controls which form of self-interaction correction to use. Note that
 this correction will be applied to the functional chosen by @t{XCFunctional}.


@emph{Options}:
@itemize @minus
@item @strong{sic_none}:  No self-interaction correction.
@item @strong{sic_pz}:  Perdew-Zunger SIC, handled by the OEP technique.
@item @strong{sic_amaldi}:  Amaldi correction term.
@item @strong{sic_adsic}:  Average-density SIC.
 C. Legrand @emph{et al.}, @emph{J. Phys. B} @strong{35}, 1115 (2002).
@end itemize

@c ----------------------------------
@item @strong{VDWCorrection}@*
@vindex @code{VDWCorrection}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: integer@*
@emph{Default}: no@*
@* (Experimental) This variable selects which van der Waals
 correction to apply to the correlation functional.


@emph{Options}:
@itemize @minus
@item @strong{none}:  No correction is applied.
@item @strong{vdw_ts}:  The scheme of Tkatchenko and Scheffler, Phys. Rev. Lett. 102
 073005 (2009).
@item @strong{vdw_d3}:  The DFT-D3 scheme of S. Grimme, J. Antony, S. Ehrlich, and
 S. Krieg, J. Chem. Phys. 132, 154104 (2010).
@end itemize

@c ----------------------------------
@item @strong{VDWD3Functional}@*
@vindex @code{VDWD3Functional}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: string@*
@* (Experimental) You can use this variable to override the
 parametrization used by the DFT-D3 van deer Waals
 correction. Normally you need not set this variable, as the
 proper value will be selected by Octopus (if available).

 This variable takes a string value, the valid values can
 be found in the source file 'external_libs/dftd3/core.f90'.
 For example you can use:

  VDWD3Functional = 'pbe'




@c ----------------------------------
@item @strong{VDWSelfConsistent}@*
@vindex @code{VDWSelfConsistent}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: logical@*
@emph{Default}: yes@*
@* This variable controls whether the VDW correction is applied
 self-consistently, the default, or just as a correction to
 the total energy. This option only works with vdw_ts.



@c ----------------------------------
@item @strong{VDW_TS_cutoff}@*
@vindex @code{VDW_TS_cutoff}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: float@*
@emph{Default}: 10.0@*
@* Set the value of the cutoff (unit of length) for the VDW correction in periodic system
 in the Tkatchenko and Scheffler (vdw_ts) scheme only.



@c ----------------------------------
@item @strong{VDW_TS_damping}@*
@vindex @code{VDW_TS_damping}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: float@*
@emph{Default}: 20.0@*
@* Set the value of the damping function (in unit of 1/length) steepness for the VDW correction in the
 Tkatchenko-Scheffler scheme. See Equation (12) of Phys. Rev. Lett. 102 073005 (2009).



@c ----------------------------------
@item @strong{VDW_TS_sr}@*
@vindex @code{VDW_TS_sr}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: float@*
@emph{Default}: 0.94@*
@* Set the value of the sr parameter in the damping function of the VDW correction in the
 Tkatchenko-Scheffler scheme. See Equation (12) of Phys. Rev. Lett. 102 073005 (2009).
 This parameter depends on the xc functional used.
 The default value is 0.94, which holds for PBE. For PBE0, a value of 0.96 should be used.



@c ----------------------------------
@item @strong{XCFunctional}@*
@vindex @code{XCFunctional}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: integer@*
@* Defines the exchange and correlation functionals to be used,
 specified as a sum of an exchange functional and a
 correlation functional, or a single exchange-correlation functional
 (@emph{e.g.} @t{hyb_gga_xc_pbeh}). For more information on the functionals, see
 <a href=https://gitlab.com/libxc/libxc/wikis/Functionals-list-4.0.4>
 Libxc documentation</a>. The list provided here is from libxc 4; if you have
 linked against a different libxc version, you may have a somewhat different set
 of available functionals. Note that kinetic-energy functionals are not supported.

 The default functional will be selected by Octopus to be consistent
 with the pseudopotentials you are using. If you are not using
 pseudopotentials, Octopus cannot determine the functional used to
 generate the pseudopotential, or the pseudopotential functionals
 are inconsistent, Octopus will use the following defaults:

 @*1D: @t{lda_x_1d + lda_c_1d_csc}
 @*2D: @t{lda_x_2d + lda_c_2d_amgb}
 @*3D: @t{lda_x + lda_c_pz_mod}


@emph{Options}:
@itemize @minus
@item @strong{none}:  Exchange and correlation set to zero (not from libxc).
@item @strong{gga_c_tca}:  Tognetti, Cortona, Adamo
@item @strong{lda_c_pz_mod}:  Perdew & Zunger (Modified)
@item @strong{gga_x_pbe}:  Perdew, Burke & Ernzerhof exchange
@item @strong{gga_x_pbe_r}:  Perdew, Burke & Ernzerhof exchange (revised)
@item @strong{gga_x_b86}:  Becke 86 Xalpha,beta,gamma
@item @strong{gga_x_herman}:  Herman et al original GGA
@item @strong{gga_x_b86_mgc}:  Becke 86 Xalpha,beta,gamma (with mod. grad. correction)
@item @strong{gga_x_b88}:  Becke 88
@item @strong{gga_x_g96}:  Gill 96
@item @strong{gga_x_pw86}:  Perdew & Wang 86
@item @strong{gga_x_pw91}:  Perdew & Wang 91
@item @strong{lda_c_ob_pz}:  Ortiz & Ballone (PZ)
@item @strong{gga_x_optx}:  Handy & Cohen OPTX 01
@item @strong{gga_x_dk87_r1}:  dePristo & Kress 87 (version R1)
@item @strong{gga_x_dk87_r2}:  dePristo & Kress 87 (version R2)
@item @strong{gga_x_lg93}:  Lacks & Gordon 93
@item @strong{gga_x_ft97_a}:  Filatov & Thiel 97 (version A)
@item @strong{gga_x_ft97_b}:  Filatov & Thiel 97 (version B)
@item @strong{gga_x_pbe_sol}:  Perdew, Burke & Ernzerhof exchange (solids)
@item @strong{gga_x_rpbe}:  Hammer, Hansen & Norskov (PBE-like)
@item @strong{gga_x_wc}:  Wu & Cohen
@item @strong{gga_x_mpw91}:  Modified form of PW91 by Adamo & Barone
@item @strong{lda_c_pw}:  Perdew & Wang
@item @strong{gga_x_am05}:  Armiento & Mattsson 05 exchange
@item @strong{gga_x_pbea}:  Madsen (PBE-like)
@item @strong{gga_x_mpbe}:  Adamo & Barone modification to PBE
@item @strong{gga_x_xpbe}:  xPBE reparametrization by Xu & Goddard
@item @strong{gga_x_2d_b86_mgc}:  Becke 86 MGC for 2D systems
@item @strong{gga_x_bayesian}:  Bayesian best fit for the enhancement factor
@item @strong{gga_x_pbe_jsjr}:  JSJR reparametrization by Pedroza, Silva & Capelle
@item @strong{gga_x_2d_b88}:  Becke 88 in 2D
@item @strong{gga_x_2d_b86}:  Becke 86 Xalpha,beta,gamma
@item @strong{gga_x_2d_pbe}:  Perdew, Burke & Ernzerhof exchange in 2D
@item @strong{gga_c_pbe}:  Perdew, Burke & Ernzerhof correlation
@item @strong{lda_c_pw_mod}:  Perdew & Wang (Modified)
@item @strong{gga_c_lyp}:  Lee, Yang & Parr
@item @strong{gga_c_p86}:  Perdew 86
@item @strong{gga_c_pbe_sol}:  Perdew, Burke & Ernzerhof correlation SOL
@item @strong{gga_c_pw91}:  Perdew & Wang 91
@item @strong{gga_c_am05}:  Armiento & Mattsson 05 correlation
@item @strong{gga_c_xpbe}:  xPBE reparametrization by Xu & Goddard
@item @strong{gga_c_lm}:  Langreth and Mehl correlation
@item @strong{gga_c_pbe_jrgx}:  JRGX reparametrization by Pedroza, Silva & Capelle
@item @strong{gga_x_optb88_vdw}:  Becke 88 reoptimized to be used with vdW functional of Dion et al
@item @strong{lda_c_ob_pw}:  Ortiz & Ballone (PW)
@item @strong{gga_x_pbek1_vdw}:  PBE reparametrization for vdW
@item @strong{gga_x_optpbe_vdw}:  PBE reparametrization for vdW
@item @strong{gga_x_rge2}:  Regularized PBE
@item @strong{gga_c_rge2}:  Regularized PBE
@item @strong{gga_x_rpw86}:  refitted Perdew & Wang 86
@item @strong{gga_x_kt1}:  Exchange part of Keal and Tozer version 1
@item @strong{gga_xc_kt2}:  Keal and Tozer version 2
@item @strong{gga_c_wl}:  Wilson & Levy
@item @strong{gga_c_wi}:  Wilson & Ivanov
@item @strong{gga_x_mb88}:  Modified Becke 88 for proton transfer
@item @strong{lda_c_2d_amgb}:  Attaccalite et al
@item @strong{gga_x_sogga}:  Second-order generalized gradient approximation
@item @strong{gga_x_sogga11}:  Second-order generalized gradient approximation 2011
@item @strong{gga_c_sogga11}:  Second-order generalized gradient approximation 2011
@item @strong{gga_c_wi0}:  Wilson & Ivanov initial version
@item @strong{gga_xc_th1}:  Tozer and Handy v. 1
@item @strong{gga_xc_th2}:  Tozer and Handy v. 2
@item @strong{gga_xc_th3}:  Tozer and Handy v. 3
@item @strong{gga_xc_th4}:  Tozer and Handy v. 4
@item @strong{gga_x_c09x}:  C09x to be used with the VdW of Rutgers-Chalmers
@item @strong{gga_c_sogga11_x}:  To be used with HYB_GGA_X_SOGGA11_X
@item @strong{lda_c_2d_prm}:  Pittalis, Rasanen & Marques correlation in 2D
@item @strong{gga_x_lb}:  van Leeuwen & Baerends
@item @strong{gga_xc_hcth_93}:  HCTH functional fitted to  93 molecules
@item @strong{gga_xc_hcth_120}:  HCTH functional fitted to 120 molecules
@item @strong{gga_xc_hcth_147}:  HCTH functional fitted to 147 molecules
@item @strong{gga_xc_hcth_407}:  HCTH functional fitted to 407 molecules
@item @strong{gga_xc_edf1}:  Empirical functionals from Adamson, Gill, and Pople
@item @strong{gga_xc_xlyp}:  XLYP functional
@item @strong{gga_xc_kt1}:  Keal and Tozer version 1
@item @strong{gga_xc_b97_d}:  Grimme functional to be used with C6 vdW term
@item @strong{lda_c_vbh}:  von Barth & Hedin
@item @strong{gga_xc_pbe1w}:  Functionals fitted for water
@item @strong{gga_xc_mpwlyp1w}:  Functionals fitted for water
@item @strong{gga_xc_pbelyp1w}:  Functionals fitted for water
@item @strong{lda_c_1d_csc}:  Casula, Sorella, and Senatore 1D correlation
@item @strong{gga_x_lbm}:  van Leeuwen & Baerends modified
@item @strong{gga_x_ol2}:  Exchange form based on Ou-Yang and Levy v.2
@item @strong{gga_x_apbe}:  mu fixed from the semiclassical neutral atom
@item @strong{gga_c_apbe}:  mu fixed from the semiclassical neutral atom
@item @strong{gga_x_htbs}:  Haas, Tran, Blaha, and Schwarz
@item @strong{gga_x_airy}:  Constantin et al based on the Airy gas
@item @strong{gga_x_lag}:  Local Airy Gas
@item @strong{gga_xc_mohlyp}:  Functional for organometallic chemistry
@item @strong{gga_xc_mohlyp2}:  Functional for barrier heights
@item @strong{gga_xc_th_fl}:  Tozer and Handy v. FL
@item @strong{gga_xc_th_fc}:  Tozer and Handy v. FC
@item @strong{gga_xc_th_fcfo}:  Tozer and Handy v. FCFO
@item @strong{gga_xc_th_fco}:  Tozer and Handy v. FCO
@item @strong{lda_x_2d}:  Exchange in 2D
@item @strong{lda_x}:  Exchange
@item @strong{gga_c_optc}:  Optimized correlation functional of Cohen and Handy
@item @strong{lda_xc_teter93}:  Teter 93 parametrization
@item @strong{lda_c_wigner}:  Wigner parametrization
@item @strong{mgga_x_lta}:  Local tau approximation of Ernzerhof & Scuseria
@item @strong{mgga_x_tpss}:  Tao, Perdew, Staroverov & Scuseria exchange
@item @strong{mgga_x_m06_l}:  M06-L exchange functional from Minnesota
@item @strong{mgga_x_gvt4}:  GVT4 from Van Voorhis and Scuseria
@item @strong{mgga_x_tau_hcth}:  tau-HCTH from Boese and Handy
@item @strong{mgga_x_br89}:  Becke-Roussel 89
@item @strong{mgga_x_bj06}:  Becke & Johnson correction to Becke-Roussel 89
@item @strong{mgga_x_tb09}:  Tran & Blaha correction to Becke & Johnson
@item @strong{mgga_x_rpp09}:  Rasanen, Pittalis, and Proetto correction to Becke & Johnson
@item @strong{mgga_x_2d_prhg07}:  Pittalis, Rasanen, Helbig, Gross Exchange Functional
@item @strong{mgga_x_2d_prhg07_prp10}:  PRGH07 with PRP10 correction
@item @strong{mgga_x_revtpss}:  revised Tao, Perdew, Staroverov & Scuseria exchange
@item @strong{mgga_x_pkzb}:  Perdew, Kurth, Zupan, and Blaha
@item @strong{lda_x_1d}:  Exchange in 1D
@item @strong{lda_c_ml1}:  Modified LSD (version 1) of Proynov and Salahub
@item @strong{mgga_x_ms0}:  MS exchange of Sun, Xiao, and Ruzsinszky
@item @strong{mgga_x_ms1}:  MS1 exchange of Sun, et al
@item @strong{mgga_x_ms2}:  MS2 exchange of Sun, et al
@item @strong{hyb_mgga_x_ms2h}:  MS2 hybrid exchange of Sun, et al
@item @strong{mgga_x_m11_l}:  M11-L exchange functional from Minnesota
@item @strong{mgga_x_mn12_l}:  MN12-L exchange functional from Minnesota
@item @strong{mgga_xc_cc06}:  Cancio and Chou 2006
@item @strong{lda_c_ml2}:  Modified LSD (version 2) of Proynov and Salahub
@item @strong{mgga_x_mk00}:  Exchange for accurate virtual orbital energies
@item @strong{mgga_c_tpss}:  Tao, Perdew, Staroverov & Scuseria correlation
@item @strong{mgga_c_vsxc}:  VSxc from Van Voorhis and Scuseria (correlation part)
@item @strong{mgga_c_m06_l}:  M06-L correlation functional from Minnesota
@item @strong{mgga_c_m06_hf}:  M06-HF correlation functional from Minnesota
@item @strong{mgga_c_m06}:  M06 correlation functional from Minnesota
@item @strong{mgga_c_m06_2x}:  M06-2X correlation functional from Minnesota
@item @strong{mgga_c_m05}:  M05 correlation functional from Minnesota
@item @strong{mgga_c_m05_2x}:  M05-2X correlation functional from Minnesota
@item @strong{mgga_c_pkzb}:  Perdew, Kurth, Zupan, and Blaha
@item @strong{mgga_c_bc95}:  Becke correlation 95
@item @strong{lda_c_gombas}:  Gombas parametrization
@item @strong{mgga_c_revtpss}:  revised TPSS correlation
@item @strong{mgga_xc_tpsslyp1w}:  Functionals fitted for water
@item @strong{mgga_x_mk00b}:  Exchange for accurate virtual orbital energies (v. B)
@item @strong{mgga_x_bloc}:  functional with balanced localization
@item @strong{mgga_x_modtpss}:  Modified Tao, Perdew, Staroverov & Scuseria exchange
@item @strong{gga_c_pbeloc}:  Semilocal dynamical correlation
@item @strong{mgga_c_tpssloc}:  Semilocal dynamical correlation
@item @strong{hyb_mgga_x_mn12_sx}:  MN12-SX hybrid exchange functional from Minnesota
@item @strong{mgga_x_mbeef}:  mBEEF exchange
@item @strong{lda_c_pw_rpa}:  Perdew & Wang fit of the RPA
@item @strong{mgga_x_mbeefvdw}:  mBEEF-vdW exchange
@item @strong{mgga_xc_b97m_v}:  Mardirossian and Head-Gordon
@item @strong{gga_xc_vv10}:  Vydrov and Van Voorhis
@item @strong{mgga_x_mvs}:  MVS exchange of Sun, Perdew, and Ruzsinszky
@item @strong{gga_c_pbefe}:  PBE for formation energies
@item @strong{lda_xc_ksdt}:  Karasiev et al. parametrization
@item @strong{lda_c_1d_loos}:  P-F Loos correlation LDA
@item @strong{mgga_x_mn15_l}:  MN15-L exhange functional from Minnesota
@item @strong{mgga_c_mn15_l}:  MN15-L correlation functional from Minnesota
@item @strong{gga_c_op_pw91}:  one-parameter progressive functional (PW91 version)
@item @strong{mgga_x_scan}:  SCAN exchange of Sun, Ruzsinszky, and Perdew
@item @strong{hyb_mgga_x_scan0}:  SCAN hybrid exchange
@item @strong{gga_x_pbefe}:  PBE for formation energies
@item @strong{hyb_gga_xc_b97_1p}:  version of B97 by Cohen and Handy
@item @strong{mgga_c_scan}:  SCAN correlation
@item @strong{hyb_mgga_x_mn15}:  MN15 hybrid exchange functional from Minnesota
@item @strong{mgga_c_mn15}:  MN15 correlation functional from Minnesota
@item @strong{lda_c_rc04}:  Ragot-Cortona
@item @strong{gga_x_cap}:  Correct Asymptotic Potential
@item @strong{gga_x_eb88}:  Non-empirical (excogitated) B88 functional of Becke and Elliott
@item @strong{gga_c_pbe_mol}:  Del Campo, Gazquez, Trickey and Vela (PBE-like)
@item @strong{hyb_gga_xc_pbe_mol0}:  PBEmol0
@item @strong{hyb_gga_xc_pbe_sol0}:  PBEsol0
@item @strong{hyb_gga_xc_pbeb0}:  PBEbeta0
@item @strong{hyb_gga_xc_pbe_molb0}:  PBEmolbeta0
@item @strong{hyb_mgga_x_bmk}:  Boese-Martin for kinetics
@item @strong{gga_c_bmk}:  Boese-Martin for kinetics
@item @strong{lda_c_vwn_1}:  Vosko, Wilk, & Nusair (1)
@item @strong{gga_c_tau_hcth}:  correlation part of tau-hcth
@item @strong{hyb_mgga_x_tau_hcth}:  Hybrid version of tau-HCTH
@item @strong{gga_c_hyb_tau_hcth}:  correlation part of hyb_tau-hcth
@item @strong{mgga_x_b00}:  Becke 2000
@item @strong{gga_x_beefvdw}:  BEEF-vdW exchange
@item @strong{gga_xc_beefvdw}:  BEEF-vdW exchange-correlation
@item @strong{lda_c_chachiyo}:  Chachiyo simple 2 parameter correlation
@item @strong{mgga_xc_hle17}:  high local exchange 2017
@item @strong{lda_c_lp96}:  Liu-Parr correlation
@item @strong{hyb_gga_xc_pbe50}:  PBE0 with 50% exx
@item @strong{lda_c_vwn_2}:  Vosko, Wilk, & Nusair (2)
@item @strong{gga_x_pbetrans}:  Gradient-based interpolation between PBE and revPBE
@item @strong{mgga_c_scan_rvv10}:  SCAN correlation + rVV10 correlation
@item @strong{mgga_x_revm06_l}:  revised M06-L exchange functional from Minnesota
@item @strong{mgga_c_revm06_l}:  Revised M06-L correlation functional from Minnesota
@item @strong{hyb_mgga_x_m08_hx}:  M08-HX exchange functional from Minnesota
@item @strong{hyb_mgga_x_m08_so}:  M08-SO exchange functional from Minnesota
@item @strong{hyb_mgga_x_m11}:  M11 hybrid exchange functional from Minnesota
@item @strong{gga_x_chachiyo}:  Chachiyo exchange
@item @strong{lda_c_vwn_3}:  Vosko, Wilk, & Nusair (3)
@item @strong{lda_c_rpa}:  Random Phase Approximation
@item @strong{lda_c_vwn_4}:  Vosko, Wilk, & Nusair (4)
@item @strong{gga_x_gam}:  GAM functional from Minnesota
@item @strong{gga_c_gam}:  GAM functional from Minnesota
@item @strong{gga_x_hcth_a}:  HCTH-A
@item @strong{gga_x_ev93}:  Engel and Vosko
@item @strong{hyb_mgga_x_dldf}:  Dispersionless Density Functional
@item @strong{mgga_c_dldf}:  Dispersionless Density Functional
@item @strong{gga_x_bcgp}:  Burke, Cancio, Gould, and Pittalis
@item @strong{gga_c_bcgp}:  Burke, Cancio, Gould, and Pittalis
@item @strong{lda_c_hl}:  Hedin & Lundqvist
@item @strong{hyb_gga_xc_b3pw91}:  The original (ACM) hybrid of Becke
@item @strong{hyb_gga_xc_b3lyp}:  The (in)famous B3LYP
@item @strong{hyb_gga_xc_b3p86}:  Perdew 86 hybrid similar to B3PW91
@item @strong{hyb_gga_xc_o3lyp}:  hybrid using the optx functional
@item @strong{hyb_gga_xc_mpw1k}:  mixture of mPW91 and PW91 optimized for kinetics
@item @strong{hyb_gga_xc_pbeh}:  aka PBE0 or PBE1PBE
@item @strong{hyb_gga_xc_b97}:  Becke 97
@item @strong{hyb_gga_xc_b97_1}:  Becke 97-1
@item @strong{gga_x_lambda_oc2_n}:  lambda_OC2(N) version of PBE
@item @strong{hyb_gga_xc_b97_2}:  Becke 97-2
@item @strong{hyb_gga_xc_x3lyp}:  hybrid by Xu and Goddard
@item @strong{hyb_gga_xc_b1wc}:  Becke 1-parameter mixture of WC and PBE
@item @strong{hyb_gga_xc_b97_k}:  Boese-Martin for Kinetics
@item @strong{hyb_gga_xc_b97_3}:  Becke 97-3
@item @strong{hyb_gga_xc_mpw3pw}:  mixture with the mPW functional
@item @strong{hyb_gga_xc_b1lyp}:  Becke 1-parameter mixture of B88 and LYP
@item @strong{hyb_gga_xc_b1pw91}:  Becke 1-parameter mixture of B88 and PW91
@item @strong{hyb_gga_xc_mpw1pw}:  Becke 1-parameter mixture of mPW91 and PW91
@item @strong{hyb_gga_xc_mpw3lyp}:  mixture of mPW and LYP
@item @strong{gga_x_b86_r}:  Revised Becke 86 Xalpha,beta,gamma (with mod. grad. correction)
@item @strong{hyb_gga_xc_sb98_1a}:  Schmider-Becke 98 parameterization 1a
@item @strong{mgga_xc_zlp}:  Zhao, Levy & Parr, Eq. (21)
@item @strong{hyb_gga_xc_sb98_1b}:  Schmider-Becke 98 parameterization 1b
@item @strong{hyb_gga_xc_sb98_1c}:  Schmider-Becke 98 parameterization 1c
@item @strong{hyb_gga_xc_sb98_2a}:  Schmider-Becke 98 parameterization 2a
@item @strong{hyb_gga_xc_sb98_2b}:  Schmider-Becke 98 parameterization 2b
@item @strong{hyb_gga_xc_sb98_2c}:  Schmider-Becke 98 parameterization 2c
@item @strong{hyb_gga_x_sogga11_x}:  Hybrid based on SOGGA11 form
@item @strong{hyb_gga_xc_hse03}:  the 2003 version of the screened hybrid HSE
@item @strong{hyb_gga_xc_hse06}:  the 2006 version of the screened hybrid HSE
@item @strong{hyb_gga_xc_hjs_pbe}:  HJS hybrid screened exchange PBE version
@item @strong{hyb_gga_xc_hjs_pbe_sol}:  HJS hybrid screened exchange PBE_SOL version
@item @strong{lda_xc_zlp}:  Zhao, Levy & Parr, Eq. (20)
@item @strong{hyb_gga_xc_hjs_b88}:  HJS hybrid screened exchange B88 version
@item @strong{hyb_gga_xc_hjs_b97x}:  HJS hybrid screened exchange B97x version
@item @strong{hyb_gga_xc_cam_b3lyp}:  CAM version of B3LYP
@item @strong{hyb_gga_xc_tuned_cam_b3lyp}:  CAM version of B3LYP tuned for excitations
@item @strong{hyb_gga_xc_bhandh}:  Becke half-and-half
@item @strong{hyb_gga_xc_bhandhlyp}:  Becke half-and-half with B88 exchange
@item @strong{hyb_gga_xc_mb3lyp_rc04}:  B3LYP with RC04 LDA
@item @strong{hyb_mgga_x_m05}:  M05 hybrid exchange functional from Minnesota
@item @strong{hyb_mgga_x_m05_2x}:  M05-2X hybrid exchange functional from Minnesota
@item @strong{hyb_mgga_xc_b88b95}:  Mixture of B88 with BC95 (B1B95)
@item @strong{hyb_mgga_xc_b86b95}:  Mixture of B86 with BC95
@item @strong{hyb_mgga_xc_pw86b95}:  Mixture of PW86 with BC95
@item @strong{hyb_mgga_xc_bb1k}:  Mixture of B88 with BC95 from Zhao and Truhlar
@item @strong{hyb_mgga_x_m06_hf}:  M06-HF hybrid exchange functional from Minnesota
@item @strong{hyb_mgga_xc_mpw1b95}:  Mixture of mPW91 with BC95 from Zhao and Truhlar
@item @strong{hyb_mgga_xc_mpwb1k}:  Mixture of mPW91 with BC95 for kinetics
@item @strong{hyb_mgga_xc_x1b95}:  Mixture of X with BC95
@item @strong{hyb_mgga_xc_xb1k}:  Mixture of X with BC95 for kinetics
@item @strong{hyb_mgga_x_m06}:  M06 hybrid exchange functional from Minnesota
@item @strong{gga_x_lambda_ch_n}:  lambda_CH(N) version of PBE
@item @strong{hyb_mgga_x_m06_2x}:  M06-2X hybrid exchange functional from Minnesota
@item @strong{hyb_mgga_xc_pw6b95}:  Mixture of PW91 with BC95 from Zhao and Truhlar
@item @strong{hyb_mgga_xc_pwb6k}:  Mixture of PW91 with BC95 from Zhao and Truhlar for kinetics
@item @strong{hyb_gga_xc_mpwlyp1m}:  MPW with 1 par. for metals/LYP
@item @strong{hyb_gga_xc_revb3lyp}:  Revised B3LYP
@item @strong{hyb_gga_xc_camy_blyp}:  BLYP with yukawa screening
@item @strong{hyb_gga_xc_pbe0_13}:  PBE0-1/3
@item @strong{hyb_mgga_xc_tpssh}:  TPSS hybrid
@item @strong{hyb_mgga_xc_revtpssh}:  revTPSS hybrid
@item @strong{hyb_gga_xc_b3lyps}:  B3LYP* functional
@item @strong{gga_x_lambda_lo_n}:  lambda_LO(N) version of PBE
@item @strong{hyb_gga_xc_wb97}:  Chai and Head-Gordon
@item @strong{hyb_gga_xc_wb97x}:  Chai and Head-Gordon
@item @strong{hyb_gga_xc_lrc_wpbeh}:  Long-range corrected functional by Rorhdanz et al
@item @strong{hyb_gga_xc_wb97x_v}:  Mardirossian and Head-Gordon
@item @strong{hyb_gga_xc_lcy_pbe}:  PBE with yukawa screening
@item @strong{hyb_gga_xc_lcy_blyp}:  BLYP with yukawa screening
@item @strong{hyb_gga_xc_lc_vv10}:  Vydrov and Van Voorhis
@item @strong{gga_x_hjs_b88_v2}:  HJS screened exchange corrected B88 version
@item @strong{hyb_gga_xc_camy_b3lyp}:  B3LYP with Yukawa screening
@item @strong{gga_c_q2d}:  Chiodo et al
@item @strong{hyb_gga_xc_wb97x_d}:  Chai and Head-Gordon
@item @strong{hyb_gga_xc_hpbeint}:  hPBEint
@item @strong{hyb_gga_xc_lrc_wpbe}:  Long-range corrected functional by Rorhdanz et al
@item @strong{hyb_mgga_x_mvsh}:  MVSh hybrid
@item @strong{hyb_gga_xc_b3lyp5}:  B3LYP with VWN functional 5 instead of RPA
@item @strong{hyb_gga_xc_edf2}:  Empirical functional from Lin, George and Gill
@item @strong{hyb_gga_xc_cap0}:  Correct Asymptotic Potential hybrid
@item @strong{hyb_gga_xc_lc_wpbe}:  Long-range corrected functional by Vydrov and Scuseria
@item @strong{hyb_gga_xc_hse12}:  HSE12 by Moussa, Schultz and Chelikowsky
@item @strong{hyb_gga_xc_hse12s}:  Short-range HSE12 by Moussa, Schultz, and Chelikowsky
@item @strong{hyb_gga_xc_hse_sol}:  HSEsol functional by Schimka, Harl, and Kresse
@item @strong{hyb_gga_xc_cam_qtp_01}:  CAM-QTP(01): CAM-B3LYP retuned using ionization potentials of water
@item @strong{hyb_gga_xc_mpw1lyp}:  Becke 1-parameter mixture of mPW91 and LYP
@item @strong{hyb_gga_xc_mpw1pbe}:  Becke 1-parameter mixture of mPW91 and PBE
@item @strong{hyb_gga_xc_kmlyp}:  Kang-Musgrave hybrid
@item @strong{gga_x_q2d}:  Chiodo et al
@item @strong{gga_x_pbe_mol}:  Del Campo, Gazquez, Trickey and Vela (PBE-like)
@item @strong{lda_c_gl}:  Gunnarson & Lundqvist
@item @strong{gga_x_wpbeh}:  short-range version of the PBE
@item @strong{gga_x_hjs_pbe}:  HJS screened exchange PBE version
@item @strong{gga_x_hjs_pbe_sol}:  HJS screened exchange PBE_SOL version
@item @strong{gga_x_hjs_b88}:  HJS screened exchange B88 version
@item @strong{gga_x_hjs_b97x}:  HJS screened exchange B97x version
@item @strong{gga_x_ityh}:  short-range recipe for exchange GGA functionals
@item @strong{gga_x_sfat}:  short-range recipe for exchange GGA functionals
@item @strong{hyb_mgga_xc_wb97m_v}:  Mardirossian and Head-Gordon
@item @strong{lda_x_rel}:  Relativistic exchange
@item @strong{gga_x_sg4}:  Semiclassical GGA at fourth order
@item @strong{gga_c_sg4}:  Semiclassical GGA at fourth order
@item @strong{gga_x_gg99}:  Gilbert and Gill 1999
@item @strong{lda_xc_1d_ehwlrg_1}:  LDA constructed from slab-like systems of 1 electron
@item @strong{lda_xc_1d_ehwlrg_2}:  LDA constructed from slab-like systems of 2 electrons
@item @strong{lda_xc_1d_ehwlrg_3}:  LDA constructed from slab-like systems of 3 electrons
@item @strong{gga_x_pbepow}:  PBE power
@item @strong{mgga_x_tm}:  Tao and Mo 2016
@item @strong{mgga_x_vt84}:  meta-GGA version of VT{8,4} GGA
@item @strong{mgga_x_sa_tpss}:  TPSS with correct surface asymptotics
@item @strong{gga_x_kgg99}:  Gilbert and Gill 1999 (mixed)
@item @strong{gga_xc_hle16}:  high local exchange 2016
@item @strong{lda_x_erf}:  Attenuated exchange LDA (erf)
@item @strong{lda_xc_lp_a}:  Lee-Parr reparametrization B
@item @strong{lda_xc_lp_b}:  Lee-Parr reparametrization B
@item @strong{lda_x_rae}:  Rae self-energy corrected exchange
@item @strong{lda_c_mcweeny}:  McWeeny 76
@item @strong{lda_c_br78}:  Brual & Rothstein 78
@item @strong{gga_c_scan_e0}:  GGA component of SCAN
@item @strong{lda_c_pk09}:  Proynov and Kong 2009
@item @strong{gga_c_gapc}:  GapC
@item @strong{gga_c_gaploc}:  Gaploc
@item @strong{gga_c_zvpbeint}:  another spin-dependent correction to PBEint
@item @strong{gga_c_zvpbesol}:  another spin-dependent correction to PBEsol
@item @strong{gga_c_tm_lyp}:  Takkar and McCarthy reparametrization
@item @strong{gga_c_tm_pbe}:  Thakkar and McCarthy reparametrization
@item @strong{gga_c_w94}:  Wilson 94 (Eq. 25)
@item @strong{mgga_c_kcis}:  Krieger, Chen, Iafrate, and Savin
@item @strong{hyb_mgga_xc_b0kcis}:  Hybrid based on KCIS
@item @strong{mgga_xc_lp90}:  Lee & Parr, Eq. (56)
@item @strong{gga_c_cs1}:  A dynamical correlation functional
@item @strong{hyb_mgga_xc_mpw1kcis}:  Modified Perdew-Wang + KCIS hybrid
@item @strong{hyb_mgga_xc_mpwkcis1k}:  Modified Perdew-Wang + KCIS hybrid with more exact exchange
@item @strong{hyb_mgga_xc_pbe1kcis}:  Perdew-Burke-Ernzerhof + KCIS hybrid
@item @strong{hyb_mgga_xc_tpss1kcis}:  TPSS hybrid with KCIS correlation
@item @strong{gga_x_ak13}:  Armiento & Kuemmel 2013
@item @strong{gga_x_b88m}:  Becke 88 reoptimized to be used with mgga_c_tau1
@item @strong{mgga_c_b88}:  Meta-GGA correlation by Becke
@item @strong{hyb_gga_xc_b5050lyp}:  Like B3LYP but more exact exchange
@item @strong{lda_c_ow_lyp}:  Wigner with corresponding LYP parameters
@item @strong{lda_c_ow}:  Optimized Wigner
@item @strong{mgga_x_gx}:  GX functional of Loos
@item @strong{mgga_x_pbe_gx}:  PBE-GX functional of Loos
@item @strong{lda_xc_gdsmfb}:  Groth et al. parametrization
@item @strong{lda_c_gk72}:  Gordon and Kim 1972
@item @strong{lda_c_karasiev}:  Karasiev reparameterization of Chachiyo
@item @strong{mgga_x_revscan}:  revised SCAN
@item @strong{mgga_c_revscan}:  revised SCAN correlation
@item @strong{hyb_mgga_x_revscan0}:  revised SCAN hybrid exchange
@item @strong{mgga_c_scan_vv10}:  SCAN correlation +  VV10 correlation
@item @strong{mgga_c_revscan_vv10}:  revised SCAN correlation
@item @strong{mgga_x_br89_explicit}:  Becke-Roussel 89 with an explicit inversion of x(y)
@item @strong{gga_x_lv_rpw86}:  Berland and Hyldgaard
@item @strong{hyb_mgga_xc_b98}:  Becke 98
@item @strong{gga_x_pbe_tca}:  PBE revised by Tognetti et al
@item @strong{lda_c_xalpha}:  Slater Xalpha
@item @strong{rdmft_xc_m}:  RDMFT Mueller functional (not from libxc).
@item @strong{gga_x_pbeint}:  PBE for hybrid interfaces
@item @strong{gga_c_zpbeint}:  spin-dependent gradient correction to PBEint
@item @strong{gga_c_pbeint}:  PBE for hybrid interfaces
@item @strong{gga_c_zpbesol}:  spin-dependent gradient correction to PBEsol
@item @strong{mgga_xc_otpss_d}:  oTPSS_D functional of Goerigk and Grimme
@item @strong{gga_xc_opbe_d}:  oPBE_D functional of Goerigk and Grimme
@item @strong{gga_xc_opwlyp_d}:  oPWLYP-D functional of Goerigk and Grimme
@item @strong{gga_xc_oblyp_d}:  oBLYP-D functional of Goerigk and Grimme
@item @strong{gga_x_vmt84_ge}:  VMT{8,4} with constraint satisfaction with mu = mu_GE
@item @strong{gga_x_vmt84_pbe}:  VMT{8,4} with constraint satisfaction with mu = mu_PBE
@item @strong{lda_c_vwn}:  Vosko, Wilk, & Nusair (5)
@item @strong{lda_xc_cmplx}:  Complex-scaled LDA exchange and correlation (not from libxc).
@item @strong{pbe_xc_cmplx}:  Complex-scaled PBE exchange and correlation (not from libxc).
@item @strong{lb94_xc_cmplx}:  Complex-scaled LB94 exchange and correlation (not from libxc).
@item @strong{gga_x_vmt_ge}:  Vela, Medel, and Trickey with mu = mu_GE
@item @strong{gga_x_vmt_pbe}:  Vela, Medel, and Trickey with mu = mu_PBE
@item @strong{mgga_c_cs}:  Colle and Salvetti
@item @strong{mgga_c_mn12_sx}:  MN12-SX correlation functional from Minnesota
@item @strong{mgga_c_mn12_l}:  MN12-L correlation functional from Minnesota
@item @strong{mgga_c_m11_l}:  M11-L correlation functional from Minnesota
@item @strong{mgga_c_m11}:  M11 correlation functional from Minnesota
@item @strong{mgga_c_m08_so}:  M08-SO correlation functional from Minnesota
@item @strong{mgga_c_m08_hx}:  M08-HX correlation functional from Minnesota
@item @strong{gga_c_n12_sx}:  N12-SX functional from Minnesota
@item @strong{gga_c_n12}:  N12 functional from Minnesota
@item @strong{lda_c_vwn_rpa}:  Vosko, Wilk, & Nusair (RPA)
@item @strong{ks_inversion}:  Inversion of KS potential (not from libxc).
@item @strong{hyb_gga_x_n12_sx}:  N12-SX functional from Minnesota
@item @strong{gga_x_n12}:  N12 functional from Minnesota
@item @strong{gga_c_regtpss}:  Regularized TPSS correlation (ex-VPBE)
@item @strong{gga_c_op_xalpha}:  one-parameter progressive functional (XALPHA version)
@item @strong{gga_c_op_g96}:  one-parameter progressive functional (G96 version)
@item @strong{gga_c_op_pbe}:  one-parameter progressive functional (PBE version)
@item @strong{gga_c_op_b88}:  one-parameter progressive functional (B88 version)
@item @strong{gga_c_ft97}:  Filatov & Thiel correlation
@item @strong{gga_c_spbe}:  PBE correlation to be used with the SSB exchange
@item @strong{lda_c_pz}:  Perdew & Zunger
@item @strong{oep_x}:  OEP: Exact exchange (not from libxc).
@item @strong{slater_x}:  Slater approximation to the exact exchange (not from libxc).
@item @strong{fbe_x}:  Exchange functional based on the force balance equation (not from libxc).
@item @strong{gga_x_ssb_sw}:  Swart, Sola and Bickelhaupt correction to PBE
@item @strong{xc_half_hartree}:  Half-Hartree exchange for two electrons (supports complex scaling) (not from libxc).
 Defined by \(v_{xc}(r) = v_H(r) / 2\).
@item @strong{vdw_c_vdwdf}:  van der Waals density functional vdW-DF correlation from libvdwxc (not from libxc).  Use with gga_x_pbe_r.
@item @strong{vdw_c_vdwdf2}:  van der Waals density functional vdW-DF2 correlation from libvdwxc (not from libxc).  Use with gga_x_rpw86.
@item @strong{gga_x_ssb}:  Swart, Sola and Bickelhaupt
@item @strong{vdw_c_vdwdfcx}:  van der Waals density functional vdW-DF-cx correlation from libvdwxc (not from libxc).  Use with gga_x_lv_rpw86.
@item @strong{hyb_gga_xc_mvorb_hse06}:  Density-based mixing parameter of HSE06 (not from libxc).
@item @strong{hyb_gga_xc_mvorb_pbeh}:  Density-based mixing parameter of PBEH (not from libxc).
 At the moment this is not supported for libxc >= 4.0.
@item @strong{gga_x_ssb_d}:  Swart, Sola and Bickelhaupt dispersion
@item @strong{gga_xc_hcth_407p}:  HCTH/407+
@item @strong{gga_xc_hcth_p76}:  HCTH p=7/6
@item @strong{gga_xc_hcth_p14}:  HCTH p=1/4
@item @strong{gga_xc_b97_gga1}:  Becke 97 GGA-1
@item @strong{gga_c_hcth_a}:  HCTH-A
@item @strong{gga_x_bpccac}:  BPCCAC (GRAC for the energy)
@item @strong{gga_c_revtca}:  Tognetti, Cortona, Adamo (revised)
@end itemize

@c ----------------------------------
@item @strong{XCKernel}@*
@vindex @code{XCKernel}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: integer@*
@* Defines the exchange-correlation kernel. Only LDA kernels are available currently.
 The options are the same as @t{XCFunctional}.
 Note: the kernel is only needed for Casida, Sternheimer, or optimal-control calculations.
 Defaults:
 @*1D: @t{lda_x_1d + lda_c_1d_csc}
 @*2D: @t{lda_x_2d + lda_c_2d_amgb}
 @*3D: @t{lda_x + lda_c_pz_mod}


@emph{Options}:
@itemize @minus
@item @strong{xc_functional}:  The same functional defined by @t{XCFunctional}.
@end itemize

@c ----------------------------------
@item @strong{XCKernelLRCAlpha}@*
@vindex @code{XCKernelLRCAlpha}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* Set to a non-zero value to add a long-range correction for solids to the kernel.
 This is the \(\alpha\) parameter defined in S. Botti @emph{et al.}, @emph{Phys. Rev. B}
 69, 155112 (2004). The \(\Gamma = \Gamma` = 0\) term \(-\alpha/q^2\) is taken
 into account by introducing an additional pole to the polarizability (see R. Stubner
 @emph{et al.}, @emph{Phys. Rev. B} 70, 245119 (2004)). The rest of the terms are included by
 multiplying the Hartree term by \(1 - \alpha / 4 \pi\). The use of non-zero
 \(\alpha\) in combination with @t{HamiltonianVariation} = @t{V_ext_only}
 corresponds to account of only the \(\Gamma = \Gamma` = 0\) term.
 Applicable only to isotropic systems. (Experimental)



@c ----------------------------------
@item @strong{XCUseGaugeIndependentKED}@*
@vindex @code{XCUseGaugeIndependentKED}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: logical@*
@emph{Default}: yes@*
@* If true, when evaluating the XC functional, a term including the (paramagnetic or total) current
 is added to the kinetic-energy density such as to make it gauge-independent.
 Applies only to meta-GGA (and hybrid meta-GGA) functionals.



@c ----------------------------------
@item @strong{Xalpha}@*
@vindex @code{Xalpha}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: float@*
@emph{Default}: 1.0@*
@* The parameter of the Slater X\(\alpha\) functional. Applies only for
 @t{XCFunctional = xc_lda_c_xalpha}.



@c ----------------------------------
@item @strong{libvdwxcDebug}@*
@vindex @code{libvdwxcDebug}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: logical@*
@* Dump libvdwxc inputs and outputs to files.



@c ----------------------------------
@item @strong{libvdwxcMode}@*
@vindex @code{libvdwxcMode}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: integer@*
@* Whether libvdwxc should run with serial fftw3, fftw3-mpi, or pfft.
 to specify fftw3-mpi in serial for debugging.
 pfft is not implemented at the moment.


@emph{Options}:
@itemize @minus
@item @strong{libvdwxc_mode_auto}:  Use serial fftw3 if actually running in serial, else fftw3-mpi.
@item @strong{libvdwxc_mode_serial}:  Run with serial fftw3.  Works only when not parallelizing over domains.
@item @strong{libvdwxc_mode_mpi}:  Run with fftw3-mpi.  Works only if Octopus is compiled with MPI.
@end itemize

@c ----------------------------------
@item @strong{libvdwxcVDWFactor}@*
@vindex @code{libvdwxcVDWFactor}@*
@emph{Section}: Hamiltonian::XC@*
@emph{Type}: float@*
@* Prefactor of non-local van der Waals functional.
 Setting a prefactor other than one is wrong, but useful
 for debugging.



@c ----------------------------------
@end itemize
@node DensityCorrection,,,
@subsubsection DensityCorrection
@c ----------------------------------

@itemize
@item @strong{XCDensityCorrection}@*
@vindex @code{XCDensityCorrection}@*
@emph{Section}: Hamiltonian::XC::DensityCorrection@*
@emph{Type}: integer@*
@emph{Default}: none@*
@* This variable controls the long-range correction of the XC
 potential using the <a href=http://arxiv.org/abs/1107.4339>XC density representation</a>.


@emph{Options}:
@itemize @minus
@item @strong{none}:  No correction is applied.
@item @strong{long_range_x}:  The correction is applied to the exchange potential.
@end itemize

@c ----------------------------------
@item @strong{XCDensityCorrectionCutoff}@*
@vindex @code{XCDensityCorrectionCutoff}@*
@emph{Section}: Hamiltonian::XC::DensityCorrection@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* The value of the cutoff applied to the XC density.



@c ----------------------------------
@item @strong{XCDensityCorrectionMinimum}@*
@vindex @code{XCDensityCorrectionMinimum}@*
@emph{Section}: Hamiltonian::XC::DensityCorrection@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* When enabled, the cutoff optimization will
 return the first minimum of the \(q_{xc}\) function if it does
 not find a value of -1 (<a href=http://arxiv.org/abs/1107.4339>details</a>).
 This is required for atoms or small
 molecules, but may cause numerical problems.



@c ----------------------------------
@item @strong{XCDensityCorrectionNormalize}@*
@vindex @code{XCDensityCorrectionNormalize}@*
@emph{Section}: Hamiltonian::XC::DensityCorrection@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* When enabled, the correction will be
 normalized to reproduce the exact boundary conditions of
 the XC potential.



@c ----------------------------------
@item @strong{XCDensityCorrectionOptimize}@*
@vindex @code{XCDensityCorrectionOptimize}@*
@emph{Section}: Hamiltonian::XC::DensityCorrection@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* When enabled, the density cutoff will be
 optimized to replicate the boundary conditions of the exact
 XC potential. If the variable is set to no, the value of
 the cutoff must be given by the @t{XCDensityCorrectionCutoff}
 variable.



@c ----------------------------------
@end itemize
@node Linear Response,,,
@section Linear Response
@c ----------------------------------

@itemize
@item @strong{MagneticGaugeCorrection}@*
@vindex @code{MagneticGaugeCorrection}@*
@emph{Section}: Linear Response@*
@emph{Type}: integer@*
@emph{Default}: gipaw@*
@* For magnetic linear response: how to handle gauge-invariance in the description
 of the coupling of electrons to the magnetic field.


@emph{Options}:
@itemize @minus
@item @strong{none}:  No correction.
 No correction.
@item @strong{gipaw}:  GIPAW correction: C Pickard and F Mauri, @emph{Phys. Rev. Lett.} @strong{91}, 196401 (2003).
 GIPAW correction: C Pickard and F Mauri, @emph{Phys. Rev. Lett.} @strong{91}, 196401 (2003).
@item @strong{icl}:  ICL correction: S Ismail-Beigi, EK Chang, and SG Louie, @emph{Phys. Rev. Lett.} @strong{87}, 087402 (2001).
 ICL correction: S Ismail-Beigi, EK Chang, and SG Louie, @emph{Phys. Rev. Lett.} @strong{87}, 087402 (2001).
@end itemize

@c ----------------------------------
@item @strong{ResponseMethod}@*
@vindex @code{ResponseMethod}@*
@emph{Section}: Linear Response@*
@emph{Type}: integer@*
@emph{Default}: sternheimer@*
@* Some response properties can be calculated either via
 Sternheimer linear response or by using finite
 differences. You can use this variable to select how you want
 them to be calculated, it applies to @t{em_resp} and @t{vib_modes}
 calculation modes. By default, the Sternheimer linear-response
 technique is used.


@emph{Options}:
@itemize @minus
@item @strong{sternheimer}:  The linear response is obtained by solving a self-consistent
 Sternheimer equation for the variation of the orbitals. This
 is the recommended method.
@item @strong{finite_differences}:  Properties are calculated as a finite-differences derivative of
 the energy obtained by several ground-state calculations. This
 method, slow and limited only to static response, is kept
 mainly because it is simple and useful for testing purposes.
@end itemize

@c ----------------------------------
@end itemize
@node Casida,,,
@subsection Casida
@c ----------------------------------

@itemize
@item @strong{CasidaCalcForces}@*
@vindex @code{CasidaCalcForces}@*
@emph{Section}: Linear Response::Casida@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* (Experimental) Enable calculation of excited-state forces. Requires previous @t{vib_modes} calculation.



@c ----------------------------------
@item @strong{CasidaCalcForcesKernel}@*
@vindex @code{CasidaCalcForcesKernel}@*
@emph{Section}: Linear Response::Casida@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* If false, the derivative of the kernel will not be included in the excited-state force calculation.



@c ----------------------------------
@item @strong{CasidaCalcForcesSCF}@*
@vindex @code{CasidaCalcForcesSCF}@*
@emph{Section}: Linear Response::Casida@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* If true, the ground-state forces will be included in the excited-state forces, so they are total forces.
 If false, the excited-state forces that are produced are only the gradients of the excitation energy.



@c ----------------------------------
@item @strong{CasidaCalcTriplet}@*
@vindex @code{CasidaCalcTriplet}@*
@emph{Section}: Linear Response::Casida@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* For a non-spin-polarized ground state, singlet or triplet excitations can be calculated
 using different matrix elements. Default is to calculate singlets. This variable has no
 effect for a spin-polarized calculation.



@c ----------------------------------
@item @strong{CasidaDistributedMatrix}@*
@vindex @code{CasidaDistributedMatrix}@*
@emph{Section}: Linear Response::Casida@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* Large matrices with more than a few thousand rows and columns usually do
 not fit into the memory of one processor anymore. With this option, the
 Casida matrix is distributed in block-cyclic fashion over all cores in the
 ParOther group. The diagonalization is done in parallel using ScaLAPACK
 or ELPA, if available. For very large matrices (>100000), only the
 ParOther strategy should be used because the diagonalization dominates
 the run time of the computation.



@c ----------------------------------
@item @strong{CasidaHermitianConjugate}@*
@vindex @code{CasidaHermitianConjugate}@*
@emph{Section}: Linear Response::Casida@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* The Casida matrix is Hermitian, so it should not matter whether we calculate the upper or
 lower diagonal. Numerical issues may cause small differences however. Use this variable to
 calculate the Hermitian conjugate of the usual matrix, for testing.



@c ----------------------------------
@item @strong{CasidaKSEnergyWindow}@*
@vindex @code{CasidaKSEnergyWindow}@*
@emph{Section}: Linear Response::Casida@*
@emph{Type}: float@*
@* An alternative to @t{CasidaKohnShamStates} for specifying which occupied-unoccupied
 transitions will be used: all those whose eigenvalue differences are less than this
 number will be included. If a value less than 0 is supplied, this criterion will not be used.



@c ----------------------------------
@item @strong{CasidaKohnShamStates}@*
@vindex @code{CasidaKohnShamStates}@*
@emph{Section}: Linear Response::Casida@*
@emph{Type}: string@*
@emph{Default}: all states@*
@* The calculation of the excitation spectrum of a system in the Casida frequency-domain
 formulation of linear-response time-dependent density functional theory (TDDFT)
 implies the use of a basis set of occupied/unoccupied Kohn-Sham orbitals. This
 basis set should, in principle, include all pairs formed by all occupied states,
 and an infinite number of unoccupied states. In practice, one has to truncate this
 basis set, selecting a number of occupied and unoccupied states that will form the
 pairs. These states are specified with this variable. If there are, say, 15 occupied
 states, and one sets this variable to the value "10-18", this means that occupied
 states from 10 to 15, and unoccupied states from 16 to 18 will be considered.

 This variable is a string in list form, @emph{i.e.} expressions such as "1,2-5,8-15" are
 valid. You should include a non-zero number of unoccupied states and a non-zero number
 of occupied states.



@c ----------------------------------
@item @strong{CasidaMomentumTransfer}@*
@vindex @code{CasidaMomentumTransfer}@*
@emph{Section}: Linear Response::Casida@*
@emph{Type}: block@*
@* Momentum-transfer vector for the calculation of the dynamic structure
 factor. When this variable is set, the transition rates are determined
 using an exponential operator instead of the normal dipole one.



@c ----------------------------------
@item @strong{CasidaParallelEigensolver}@*
@vindex @code{CasidaParallelEigensolver}@*
@emph{Section}: Linear Response::Casida@*
@emph{Type}: integer@*
@* Choose library to use for solving the parallel eigenproblem
 of the Casida problem. This options is only relevant if a
 distributed matrix is used (CasidaDistributedMatrix=true).
 By default, elpa is chosen if available.


@emph{Options}:
@itemize @minus
@item @strong{casida_elpa}:  Use ELPA library as parallel eigensolver
@item @strong{casida_scalapack}:  Use Scalapack as parallel eigensolver
@end itemize

@c ----------------------------------
@item @strong{CasidaPrintExcitations}@*
@vindex @code{CasidaPrintExcitations}@*
@emph{Section}: Linear Response::Casida@*
@emph{Type}: string@*
@emph{Default}: write all@*
@* Specifies which excitations are written at the end of the calculation.

 This variable is a string in list form, @emph{i.e.} expressions such as "1,2-5,8-15" are
 valid.



@c ----------------------------------
@item @strong{CasidaQuadratureOrder}@*
@vindex @code{CasidaQuadratureOrder}@*
@emph{Section}: Linear Response::Casida@*
@emph{Type}: integer@*
@emph{Default}: 5@*
@* Only applies if @t{CasidaMomentumTransfer} is nonzero.
 Directionally averaged dynamic structure factor is calculated by
 averaging over the results from a set of \(\vec{q}\)-vectors. The vectors
 are generated using Gauss-Legendre quadrature scheme [see @emph{e.g.}
 K. Atkinson, @emph{J. Austral. Math. Soc.} @strong{23}, 332 (1982)], and this
 variable determines the order of the scheme.



@c ----------------------------------
@item @strong{CasidaTheoryLevel}@*
@vindex @code{CasidaTheoryLevel}@*
@emph{Section}: Linear Response::Casida@*
@emph{Type}: flag@*
@emph{Default}: @t{eps_diff + petersilka + lrtddft_casida}@*
@* Choose which electron-hole matrix-based theory levels to use in calculating excitation energies.
 More than one may be used to take advantage of the significant commonality between the calculations.
 @t{variational} and @t{lrttdft_casida} are not usable with complex wavefunctions.
 Note the restart data saved by each theory level is compatible with all the others.


@emph{Options}:
@itemize @minus
@item @strong{lrtddft_casida}:  The full Casida method. Only applies to real wavefunctions.
 Ref: C Jamorski, ME Casida, and DR Salahub, @emph{J. Chem. Phys.} @strong{104}, 5134 (1996)
 and ME Casida, "Time-dependent density functional response theory for molecules,"
 in @emph{Recent Advances in Density Functional Methods}, edited by DE Chong, vol. 1
 of @emph{Recent Advances in Computational Chemistry}, pp. 155-192 (World Scientific,
 Singapore, 1995).
@item @strong{eps_diff}:  Difference of eigenvalues, @emph{i.e.} independent-particle approximation.
@item @strong{petersilka}:  The Petersilka approximation uses only elements of the Tamm-Dancoff matrix between degenerate
 transitions (if no degeneracy, this is just the diagonal elements). Also called the "single-pole" approximation.
 This is acceptable if there is little mixing between single-particle transitions.
 Ref: M Petersilka, UJ Gossmann, and EKU Gross, @emph{Phys. Rev. Lett.} @strong{76}, 1212 (1996);
 T Grabo, M Petersilka,and EKU Gross, @emph{Theochem} @strong{501-502} 353 (2000).
@item @strong{tamm_dancoff}:  The Tamm-Dancoff approximation uses only occupied-unoccupied transitions and not
 unoccupied-occupied transitions.
 Ref: S Hirata and M Head-Gordon, @emph{Chem. Phys. Lett.} @strong{314}, 291 (1999).
@item @strong{variational}:  Second-order constrained variational theory CV(2)-DFT. Only applies to real wavefunctions.
 Ref: T Ziegler, M Seth, M Krykunov, J Autschbach, and F Wang,
 @emph{J. Chem. Phys.} @strong{130}, 154102 (2009).
@end itemize

@c ----------------------------------
@item @strong{CasidaTransitionDensities}@*
@vindex @code{CasidaTransitionDensities}@*
@emph{Section}: Linear Response::Casida@*
@emph{Type}: string@*
@emph{Default}: write none@*
@* Specifies which transition densities are to be calculated and written down. The
 transition density for the many-body state @emph{n} will be written to a file called
 @t{rho_0n} prefixed by the theory level. Format is set by @t{OutputFormat}.

 This variable is a string in list form, @emph{i.e.} expressions such as "1,2-5,8-15" are
 valid.



@c ----------------------------------
@item @strong{CasidaWeightThreshold}@*
@vindex @code{CasidaWeightThreshold}@*
@emph{Section}: Linear Response::Casida@*
@emph{Type}: float@*
@emph{Default}: -1.@*
@* Specifies the threshold value for which the individual excitations are printed.
 i.e. juste-h pairs with weight larger than this threshold will be printed.

 If a negative value (default) is set, all coefficients will be printed.
 For many case, a 0.01 value is a valid option.



@c ----------------------------------
@item @strong{CasidaWriteDistributedMatrix}@*
@vindex @code{CasidaWriteDistributedMatrix}@*
@emph{Section}: Linear Response::Casida@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* Set to true to write out the full distributed Casida matrix to a file
 using MPI-IO.



@c ----------------------------------
@item @strong{PhotonmodesFilename}@*
@vindex @code{PhotonmodesFilename}@*
@emph{Section}: Linear Response::Casida@*
@emph{Type}: string@*
@emph{Default}: "photonmodes"@*
@* Filename for photon modes in text format
  - first line contains 2 integers: number of photon modes and number of
    columns
  - each further line contains the given number of floats for one photon
    mode



@c ----------------------------------
@end itemize
@node KdotP,,,
@subsection KdotP
@c ----------------------------------

@itemize
@item @strong{KdotPCalcSecondOrder}@*
@vindex @code{KdotPCalcSecondOrder}@*
@emph{Section}: Linear Response::KdotP@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* If true, calculates second-order response of wavefunctions as well as first-order response.
 Note that the second derivative of the Hamiltonian is NOT included in this calculation.
 This is needed for a subsequent run in @t{CalculationMode = em_resp} with @t{EMHyperpol}.



@c ----------------------------------
@item @strong{KdotPCalculateEffectiveMasses}@*
@vindex @code{KdotPCalculateEffectiveMasses}@*
@emph{Section}: Linear Response::KdotP@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* If true, uses @t{kdotp} perturbations of ground-state wavefunctions
 to calculate effective masses. It is not correct for degenerate states.



@c ----------------------------------
@item @strong{KdotPEta}@*
@vindex @code{KdotPEta}@*
@emph{Section}: Linear Response::KdotP@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* Imaginary frequency added to Sternheimer equation which may improve convergence.
 Not recommended.



@c ----------------------------------
@item @strong{KdotPOccupiedSolutionMethod}@*
@vindex @code{KdotPOccupiedSolutionMethod}@*
@emph{Section}: Linear Response::KdotP@*
@emph{Type}: integer@*
@emph{Default}: sternheimer_eqn@*
@* Method of calculating the contribution of the projection of the
 linear-response wavefunctions in the occupied subspace.


@emph{Options}:
@itemize @minus
@item @strong{sternheimer_eqn}:  The Sternheimer equation is solved including the occupied subspace,
 to get the full linear-response wavefunctions.
@item @strong{sum_over_states}:  The Sternheimer equation is solved only in the unoccupied subspace,
 and a sum-over-states perturbation-theory expression is used to
 evaluate the contributions in the occupied subspace.
@end itemize

@c ----------------------------------
@item @strong{KdotPUseNonLocalPseudopotential}@*
@vindex @code{KdotPUseNonLocalPseudopotential}@*
@emph{Section}: Linear Response::KdotP@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* For testing purposes, set to false to ignore the term \(-i \left[\vec{r}, V\right]\) in
 the \(\vec{k} \cdot \vec{p}\) perturbation, which is due to non-local pseudopotentials.



@c ----------------------------------
@item @strong{KdotPVelMethod}@*
@vindex @code{KdotPVelMethod}@*
@emph{Section}: Linear Response::KdotP@*
@emph{Type}: integer@*
@emph{Default}: grad_vel@*
@* Method of velocity calculation.


@emph{Options}:
@itemize @minus
@item @strong{grad_vel}:  \(-i \left(\nabla + \left[r, V_{\rm nl} \right] \right)\)
 \(-i \left(\nabla + \left[r, V_{\rm nl} \right] \right)\)
@item @strong{hcom_vel}:  As a commutator of the position operator and Hamiltonian, \(-i \left[ r, H \right]\).
 As a commutator of the position operator and Hamiltonian, \(-i \left[ r, H \right]\).
@end itemize

@c ----------------------------------
@end itemize
@node Polarizabilities,,,
@subsection Polarizabilities
@c ----------------------------------

@itemize
@item @strong{BornChargeSumRuleCorrection}@*
@vindex @code{BornChargeSumRuleCorrection}@*
@emph{Section}: Linear Response::Polarizabilities@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* Enforce the acoustic sum rule by distributing the excess sum of Born charges equally among the atoms.
 Sum rule: \(\sum_{\alpha} Z^{*}_{\alpha, i, j} = Z_{\rm tot} \delta_{ij}\).
 Violation of the sum rule may be caused by inadequate spacing, box size (in finite directions),
 or @emph{k}-point sampling (in periodic directions).



@c ----------------------------------
@item @strong{EMCalcBornCharges}@*
@vindex @code{EMCalcBornCharges}@*
@emph{Section}: Linear Response::Polarizabilities@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* Calculate linear-response Born effective charges from electric perturbation (experimental).



@c ----------------------------------
@item @strong{EMCalcMagnetooptics}@*
@vindex @code{EMCalcMagnetooptics}@*
@emph{Section}: Linear Response::Polarizabilities@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* Calculate magneto-optical response.



@c ----------------------------------
@item @strong{EMCalcRotatoryResponse}@*
@vindex @code{EMCalcRotatoryResponse}@*
@emph{Section}: Linear Response::Polarizabilities@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* Calculate circular-dichroism spectrum from electric perturbation,
 and write to file @t{rotatory_strength}.



@c ----------------------------------
@item @strong{EMEta}@*
@vindex @code{EMEta}@*
@emph{Section}: Linear Response::Polarizabilities@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* The imaginary part of the frequency, effectively a Lorentzian broadening
 for peaks in the spectrum. It can help convergence of the SCF cycle for the
 Sternheimer equation when on a resonance, and it can be used as a positive
 infinitesimal to get the imaginary parts of response functions at poles.
 In units of energy. Cannot be negative.



@c ----------------------------------
@item @strong{EMForceNoKdotP}@*
@vindex @code{EMForceNoKdotP}@*
@emph{Section}: Linear Response::Polarizabilities@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* If the system is periodic, by default wavefunctions from a previous @t{kdotp} run will
 be read, to be used in the formulas for the polarizability and
 hyperpolarizability in the quantum theory of polarization. For testing purposes,
 you can set this variable to true to disregard the @t{kdotp} run, and use the formulas
 for the finite system. This variable has no effect for a finite system.



@c ----------------------------------
@item @strong{EMFreqs}@*
@vindex @code{EMFreqs}@*
@emph{Section}: Linear Response::Polarizabilities@*
@emph{Type}: block@*
@* This block defines for which frequencies the polarizabilities
 will be calculated. If it is not present, the static (\(\omega = 0\)) response
 is calculated.

 Each row of the block indicates a sequence of frequency values, the
 first column is an integer that indicates the number of steps, the
 second number is the initial frequency, and the third number the final
 frequency. If the first number is one, then only the initial value is
 considered. The block can have any number of rows. Consider the next example:

 @t{%EMFreqs
 @*31 | 0.0 | 1.0
 @* 1 | 0.32
 @*%}




@c ----------------------------------
@item @strong{EMFreqsSort}@*
@vindex @code{EMFreqsSort}@*
@emph{Section}: Linear Response::Polarizabilities@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* If true, the frequencies specified by the @t{EMFreqs} block are sorted, so that
 they are calculated in increasing order. Can be set to false to use the order as stated,
 in case this makes better use of available restart information.



@c ----------------------------------
@item @strong{EMHyperpol}@*
@vindex @code{EMHyperpol}@*
@emph{Section}: Linear Response::Polarizabilities@*
@emph{Type}: block@*
@* This block describes the multiples of the frequency used for
 the dynamic hyperpolarizability. The results are written to the
 file @t{beta} in the directory for the first multiple.
 There must be three factors, summing to zero: \(\omega_1 + \omega_2 + \omega_3 = 0\).
 For example, for second-harmonic generation, you could use
 @t{1 | 1 | -2}.



@c ----------------------------------
@item @strong{EMKPointOutput}@*
@vindex @code{EMKPointOutput}@*
@emph{Section}: Linear Response::Polarizabilities@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* Give in the output contributions of different k-points to the dielectric constant.
 Can be also used for magneto-optical effects.



@c ----------------------------------
@item @strong{EMMagnetoopticsNoHVar}@*
@vindex @code{EMMagnetoopticsNoHVar}@*
@emph{Section}: Linear Response::Polarizabilities@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* Exclude corrections to the exchange-correlation and Hartree terms
 from consideration of perturbations induced by a magnetic field



@c ----------------------------------
@item @strong{EMOccupiedResponse}@*
@vindex @code{EMOccupiedResponse}@*
@emph{Section}: Linear Response::Polarizabilities@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* Solve for full response without projector into unoccupied subspace.
 Not possible if there are partial occupations.
 When @t{EMHyperpol} is set for a periodic system, this variable is ignored and
 the full response is always calculated.



@c ----------------------------------
@item @strong{EMPerturbationType}@*
@vindex @code{EMPerturbationType}@*
@emph{Section}: Linear Response::Polarizabilities@*
@emph{Type}: integer@*
@emph{Default}: electric@*
@* Which perturbation to consider for electromagnetic linear response.


@emph{Options}:
@itemize @minus
@item @strong{none}:  Zero perturbation, for use in testing.
@item @strong{electric}:  Electric perturbation used to calculate electric polarizabilities
 and hyperpolarizabilities.
@item @strong{magnetic}:  Magnetic perturbation used to calculate magnetic susceptibilities.
@end itemize

@c ----------------------------------
@item @strong{EMWavefunctionsFromScratch}@*
@vindex @code{EMWavefunctionsFromScratch}@*
@emph{Section}: Linear Response::Polarizabilities@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* Do not use saved linear-response wavefunctions from a previous run as starting guess.
 Instead initialize to zero as in @t{FromScratch}, but restart densities will still
 be used. Restart wavefunctions from a very different frequency can hinder convergence.



@c ----------------------------------
@item @strong{vdWNPoints}@*
@vindex @code{vdWNPoints}@*
@emph{Section}: Linear Response::Polarizabilities@*
@emph{Type}: integer@*
@emph{Default}: 6@*
@* How many points to use in the Gauss-Legendre integration to obtain the
 van der Waals coefficients.



@c ----------------------------------
@end itemize
@node SCF in LR calculations,,,
@subsection SCF in LR calculations
@c ----------------------------------

@itemize
@item @strong{LRConvAbsDens}@*
@vindex @code{LRConvAbsDens}@*
@emph{Section}: Linear Response::SCF in LR calculations@*
@emph{Type}: float@*
@emph{Default}: 1e-5@*
@* The tolerance in the absolute variation of the density response, to determine if
 the SCF for linear response is converged.
 \(\varepsilon = \int {\rm d}^3r \left| \rho^{out}(\bf r) -\rho^{inp}(\bf r) \right|\).
 A zero value means do not use this criterion.



@c ----------------------------------
@item @strong{LRConvRelDens}@*
@vindex @code{LRConvRelDens}@*
@emph{Section}: Linear Response::SCF in LR calculations@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* The tolerance in the relative variation of the density response, to determine if
 the SCF for linear response is converged.
 \(\varepsilon = \frac{1}{N_{\rm elec}}\) @t{LRConvAbsDens}.
 A zero value means do not use this criterion.



@c ----------------------------------
@item @strong{LRMaximumIter}@*
@vindex @code{LRMaximumIter}@*
@emph{Section}: Linear Response::SCF in LR calculations@*
@emph{Type}: integer@*
@emph{Default}: 200@*
@* The maximum number of SCF iterations to calculate response.



@c ----------------------------------
@item @strong{LRTolAdaptiveFactor}@*
@vindex @code{LRTolAdaptiveFactor}@*
@emph{Section}: Linear Response::SCF in LR calculations@*
@emph{Type}: float@*
@emph{Default}: 0.1@*
@* This factor controls how much the tolerance is decreased
 during the self-consistency process. Smaller values mean that
 tolerance is decreased faster.



@c ----------------------------------
@item @strong{LRTolIterWindow}@*
@vindex @code{LRTolIterWindow}@*
@emph{Section}: Linear Response::SCF in LR calculations@*
@emph{Type}: float@*
@emph{Default}: 10@*
@* Number of iterations necessary to reach the final tolerance.



@c ----------------------------------
@item @strong{LRTolScheme}@*
@vindex @code{LRTolScheme}@*
@emph{Section}: Linear Response::SCF in LR calculations@*
@emph{Type}: integer@*
@emph{Default}: tol_adaptive@*
@* The scheme used to adjust the tolerance of the solver during
 the SCF iteration. For @t{kdotp} and magnetic @t{em_resp} modes, or
 whenever @t{HamiltonianVariation = V_ext_only}, the
 scheme is set to @t{tol_fixed}, and this variable is ignored.


@emph{Options}:
@itemize @minus
@item @strong{tol_fixed}:  The solver tolerance is fixed for all the iterations; this
 improves convergence but increases the computational cost
@item @strong{tol_adaptive}:  The tolerance is increased according to the level of
 convergence of the SCF.
@item @strong{tol_linear}:  The tolerance decreases linearly for the first @t{LRTolIterWindow} iterations.
@item @strong{tol_exp}:  The tolerance decreases exponentially for the first @t{LRTolIterWindow} iterations.
@end itemize

@c ----------------------------------
@end itemize
@node Solver,,,
@subsection Solver
@c ----------------------------------

@itemize
@item @strong{LRTolFinalTol}@*
@vindex @code{LRTolFinalTol}@*
@emph{Section}: Linear Response::Solver@*
@emph{Type}: float@*
@emph{Default}: 1e-6@*
@* This is the tolerance to determine that the linear solver has converged.



@c ----------------------------------
@item @strong{LRTolInitTol}@*
@vindex @code{LRTolInitTol}@*
@emph{Section}: Linear Response::Solver@*
@emph{Type}: float@*
@emph{Default}: 1e-2@*
@* This is the tolerance to determine that the linear solver has converged,
 for the first SCF iteration. Ignored if @t{LRTolScheme = fixed}.



@c ----------------------------------
@item @strong{LinearSolver}@*
@vindex @code{LinearSolver}@*
@emph{Section}: Linear Response::Solver@*
@emph{Type}: integer@*
@emph{Default}: qmr_symmetric@*
@* Method for solving linear equations, which occur for Sternheimer linear
 response and OEP. The solvers vary in speed, reliability (ability to
 converge), and domain of applicability. QMR solvers are most reliable.


@emph{Options}:
@itemize @minus
@item @strong{idrs}:  This is the "Induced Dimension Reduction", IDR(s) (for s=4). IDR(s) is a robust and efficient short recurrence
 Krylov subspace method for solving large nonsymmetric systems of linear equations. It is described in
 [Peter Sonneveld and Martin B. van Gijzen, SIAM J. Sci. Comput. 31, 1035 (2008)]. We have adapted the code
 released by M. B. van Gizjen [http://ta.twi.tudelft.nl/nw/users/gijzen/IDR.html].
@item @strong{bicgstab}:  Biconjugate gradients stabilized. Slower than @t{cg}, but more reliable.
 General matrices.
@item @strong{cg}:  Conjugate gradients. Fast but unreliable. Hermitian matrices only
 (no eta in Sternheimer).
@item @strong{multigrid}:  Multigrid solver, currently only Gauss-Jacobi (experimental).
 Slow, but fairly reliable. General matrices.
@item @strong{qmr_symmetric}:  Quasi-minimal residual solver, for (complex) symmetric matrices. [Real symmetric
 is equivalent to Hermitian.] Slightly slower than @t{bicgstab} but more reliable.
 For Sternheimer, must be real wavefunctions, but can have eta.
@item @strong{qmr_symmetrized}:  Quasi-minimal residual solver, using the symmetrized form \(A^\dagger A x = A^\dagger y\) instead of
 \(A x = y\). Reliable but very slow. General matrices.
@item @strong{qmr_dotp}:  Quasi-minimal residual solver, for Hermitian matrices, using the
 symmetric algorithm with conjugated dot product (experimental). Slightly slower than @t{bicgstab}
 but more reliable. Can always be used in Sternheimer.
@item @strong{qmr_general}:  Quasi-minimal residual solver, for general matrices, using the
 most general form of the algorithm. Slow and unreliable.
@item @strong{sos}:  Sum over states: the Sternheimer equation is solved by using
 the explicit solution in terms of the ground-state
 wavefunctions. You need unoccupied states to use this method.
 Unlike the other methods, may not give the correct answer.
@end itemize

@c ----------------------------------
@item @strong{LinearSolverMaxIter}@*
@vindex @code{LinearSolverMaxIter}@*
@emph{Section}: Linear Response::Solver@*
@emph{Type}: integer@*
@emph{Default}: 1000@*
@* Maximum number of iterations the linear solver does, even if
 convergence is not achieved.



@c ----------------------------------
@end itemize
@node Static Polarization,,,
@subsection Static Polarization
@c ----------------------------------

@itemize
@item @strong{EMCalcDiagonalField}@*
@vindex @code{EMCalcDiagonalField}@*
@emph{Section}: Linear Response::Static Polarization@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* Calculate @emph{yz}-field for \(\beta_{xyz}\) hyperpolarizability, which is sometimes harder to converge.
 Only applies if @t{ResponseMethod = finite_differences}.



@c ----------------------------------
@item @strong{EMStartDensityIsZeroField}@*
@vindex @code{EMStartDensityIsZeroField}@*
@emph{Section}: Linear Response::Static Polarization@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* Use the charge density from the zero-field calculation as the starting density for
 SCF calculations with applied fields. For small fields, this will be fastest.
 If there is trouble converging with larger fields, set to false,
 to initialize the calculation for each field from scratch, as specified by the LCAO variables.
 Only applies if @t{ResponseMethod = finite_differences}.



@c ----------------------------------
@item @strong{EMStaticElectricField}@*
@vindex @code{EMStaticElectricField}@*
@emph{Section}: Linear Response::Static Polarization@*
@emph{Type}: float@*
@emph{Default}: 0.01 a.u.@*
@* Magnitude of the static electric field used to calculate the static polarizability,
 if @t{ResponseMethod = finite_differences}.



@c ----------------------------------
@item @strong{EMVerbose}@*
@vindex @code{EMVerbose}@*
@emph{Section}: Linear Response::Static Polarization@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* Write full SCF output.
 Only applies if @t{ResponseMethod = finite_differences}.



@c ----------------------------------
@item @strong{EMWriteRestartDensities}@*
@vindex @code{EMWriteRestartDensities}@*
@emph{Section}: Linear Response::Static Polarization@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* Write density after each calculation for restart, rather than just the resulting electronic dipole moment.
 Only applies if @t{ResponseMethod = finite_differences}. Restarting from calculations at smaller
 fields can be helpful if there are convergence problems.



@c ----------------------------------
@end itemize
@node Sternheimer,,,
@subsection Sternheimer
@c ----------------------------------

@itemize
@item @strong{HamiltonianVariation}@*
@vindex @code{HamiltonianVariation}@*
@emph{Section}: Linear Response::Sternheimer@*
@emph{Type}: integer@*
@emph{Default}: hartree+fxc@*
@* The terms to be considered in the variation of the
 Hamiltonian. The external potential (V_ext) is always considered. The default is to include
 also the exchange-correlation and Hartree terms, which fully
 takes into account local fields.
 Just @t{hartree} gives you the random-phase approximation (RPA).
 If you want to choose the exchange-correlation kernel, use the variable
 @t{XCKernel}. For @t{kdotp} and magnetic @t{em_resp} modes,
 or if @t{TheoryLevel = independent_particles},
 the value @t{V_ext_only} is used and this variable is ignored.


@emph{Options}:
@itemize @minus
@item @strong{V_ext_only}:  Neither Hartree nor XC potentials included.
@item @strong{hartree}:  The variation of the Hartree potential only.
@item @strong{fxc}:  The exchange-correlation kernel (the variation of the
 exchange-correlation potential) only.
@end itemize

@c ----------------------------------
@item @strong{PhotonEta}@*
@vindex @code{PhotonEta}@*
@emph{Section}: Linear Response::Sternheimer@*
@emph{Type}: float@*
@emph{Default}: 0.0000367@*
@* This variable provides the value for the broadening of the photonic spectra
 when the coupling of electrons to photons is enabled in the frequency-dependent Sternheimer equation



@c ----------------------------------
@item @strong{Preorthogonalization}@*
@vindex @code{Preorthogonalization}@*
@emph{Section}: Linear Response::Sternheimer@*
@emph{Type}: logical@*
@* Whether initial linear-response wavefunctions should be orthogonalized
 or not against the occupied states, at the start of each SCF cycle.
 Default is true only if @t{SmearingFunction = semiconducting},
 or if the @t{Occupations} block specifies all full or empty states,
 and we are not solving for linear response in the occupied subspace too.



@c ----------------------------------
@end itemize
@node Vibrational Modes,,,
@subsection Vibrational Modes
@c ----------------------------------

@itemize
@item @strong{CalcInfrared}@*
@vindex @code{CalcInfrared}@*
@emph{Section}: Linear Response::Vibrational Modes@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* If set to true, infrared intensities (and born charges) will be calculated
 and written in @t{vib_modes/infrared}.



@c ----------------------------------
@item @strong{CalcNormalModeWfs}@*
@vindex @code{CalcNormalModeWfs}@*
@emph{Section}: Linear Response::Vibrational Modes@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* If set to true, the response wavefunctions for each normal mode will be calculated
 and written in directory @t{restart/vib_modes/phn_nm_wfs_XXXXX}.
 This part is time-consuming and not parallel, but not needed for most purposes.



@c ----------------------------------
@item @strong{Displacement}@*
@vindex @code{Displacement}@*
@emph{Section}: Linear Response::Vibrational Modes@*
@emph{Type}: float@*
@emph{Default}: 0.01 a.u.@*
@* When calculating phonon properties by finite differences (@t{CalculationMode = vib_modes,
 ResponseMethod = finite_differences}),
 @t{Displacement} controls how much the atoms are to be moved in order to calculate the
 dynamical matrix.



@c ----------------------------------
@item @strong{SymmetrizeDynamicalMatrix}@*
@vindex @code{SymmetrizeDynamicalMatrix}@*
@emph{Section}: Linear Response::Vibrational Modes@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* If set to true, all entries of the dynamical matrix will be calculated and then
 the matrix will be symmetrized to enforce \(D_{ij} = D_{ji}\). If set to false,
 only the upper half of the matrix will be calculated.



@c ----------------------------------
@end itemize
@node RootSolver,,,
@subsection RootSolver
@c ----------------------------------

@itemize
@item @strong{RootSolver}@*
@vindex @code{RootSolver}@*
@emph{Section}: Math::RootSolver@*
@emph{Type}: integer@*
@emph{Default}: root_newton@*
@* Specifies what kind of root solver will be used.


@emph{Options}:
@itemize @minus
@item @strong{root_newton}:  Newton method.
@end itemize

@c ----------------------------------
@item @strong{RootSolverAbsTolerance}@*
@vindex @code{RootSolverAbsTolerance}@*
@emph{Section}: Math::RootSolver@*
@emph{Type}: float@*
@emph{Default}: 1e-8@*
@* Relative tolerance for the root-finding process.



@c ----------------------------------
@item @strong{RootSolverMaxIter}@*
@vindex @code{RootSolverMaxIter}@*
@emph{Section}: Math::RootSolver@*
@emph{Type}: integer@*
@emph{Default}: 100@*
@* In case of an iterative root solver, this variable determines the maximum number
 of iteration steps.



@c ----------------------------------
@item @strong{RootSolverRelTolerance}@*
@vindex @code{RootSolverRelTolerance}@*
@emph{Section}: Math::RootSolver@*
@emph{Type}: float@*
@emph{Default}: 1e-8@*
@* Relative tolerance for the root-finding process.



@c ----------------------------------
@end itemize
@node SPARSKIT,,,
@subsection SPARSKIT
@c ----------------------------------

@itemize
@item @strong{SPARSKITAbsTolerance}@*
@vindex @code{SPARSKITAbsTolerance}@*
@emph{Section}: Math::SPARSKIT@*
@emph{Type}: float@*
@emph{Default}: 1e-10@*
@* Some SPARSKIT solvers use an absolute tolerance as a stopping criterion
 for the iterative solution process. This variable can be used to
 specify the tolerance.



@c ----------------------------------
@item @strong{SPARSKITIterOut}@*
@vindex @code{SPARSKITIterOut}@*
@emph{Section}: Math::SPARSKIT@*
@emph{Type}: integer@*
@emph{Default}: -1@*
@* Determines how often status info of the solver is printed.
 If <= 0, will never be printed.



@c ----------------------------------
@item @strong{SPARSKITKrylovSubspaceSize}@*
@vindex @code{SPARSKITKrylovSubspaceSize}@*
@emph{Section}: Math::SPARSKIT@*
@emph{Type}: integer@*
@emph{Default}: 15@*
@* Some of the SPARSKIT solvers are Krylov subspace methods.
 This variable determines what size the solver will use
 for the subspace.



@c ----------------------------------
@item @strong{SPARSKITMaxIter}@*
@vindex @code{SPARSKITMaxIter}@*
@emph{Section}: Math::SPARSKIT@*
@emph{Type}: integer@*
@emph{Default}: 50000@*
@* This variable controls the maximum number of iteration steps that
 will be performed by the (iterative) linear solver.



@c ----------------------------------
@item @strong{SPARSKITRelTolerance}@*
@vindex @code{SPARSKITRelTolerance}@*
@emph{Section}: Math::SPARSKIT@*
@emph{Type}: float@*
@emph{Default}: 1e-8@*
@* Some SPARSKIT solvers use a relative tolerance as a stopping criterion
 for the iterative solution process. This variable can be used to
 specify the tolerance.



@c ----------------------------------
@item @strong{SPARSKITSolver}@*
@vindex @code{SPARSKITSolver}@*
@emph{Section}: Math::SPARSKIT@*
@emph{Type}: integer@*
@emph{Default}: sk_bcg@*
@* Specifies what kind of linear solver will be used.


@emph{Options}:
@itemize @minus
@item @strong{sk_dqgmres}:  Direct versions of the Quasi-Generalized Minimum Residual method
@item @strong{sk_cg}:  Conjugate Gradient Method
@item @strong{sk_cgnr}:  Conjugate Gradient Method (Normal Residual equation)
@item @strong{sk_bcg}:  Bi-Conjugate Gradient Method
@item @strong{sk_dbcg}:  BCG with partial pivoting
@item @strong{sk_bcgstab}:  BCG stabilized
@item @strong{sk_tfqmr}:  Transpose-Free Quasi-Minimum Residual method
@item @strong{sk_fom}:  Full Orthogonalization Method
@item @strong{sk_gmres}:  Generalized Minimum Residual method
@item @strong{sk_fgmres}:  Flexible version of Generalized Minimum Residual method
@end itemize

@c ----------------------------------
@item @strong{SPARSKITVerboseSolver}@*
@vindex @code{SPARSKITVerboseSolver}@*
@emph{Section}: Math::SPARSKIT@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* When set to yes, the SPARSKIT solver will write more detailed output.



@c ----------------------------------
@end itemize
@node Maxwell,,,
@section Maxwell
@c ----------------------------------

@itemize
@item @strong{CheckPointsMediumFromFile}@*
@vindex @code{CheckPointsMediumFromFile}@*
@emph{Section}: Maxwell@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* Whether to re-calculate the points map by artificially shrinking the coordinate system by a factor of
 0.99 to check if the points inside the medium surface are properly detected. This works for only one
 medium surface which is centered in the origin of the coordinate system.



@c ----------------------------------
@item @strong{LinearMediumBoxFile}@*
@vindex @code{LinearMediumBoxFile}@*
@emph{Section}: Maxwell@*
@emph{Type}: string@*
@* File in OFF format with the shape of the linear medium.



@c ----------------------------------
@item @strong{LinearMediumBoxShape}@*
@vindex @code{LinearMediumBoxShape}@*
@emph{Section}: Maxwell@*
@emph{Type}: integer@*
@* This variable defines the shape of the linear medium box.
 The default is @t{medium_parallelepiped}.


@emph{Options}:
@itemize @minus
@item @strong{medium_parallelepiped}:  The medium box will be a parallelepiped whose center and dimensions are taken from
 the variable @t{LinearMediumBoxSize}.
@item @strong{medium_box_file}:  The simulation box will be read from an external file in OFF format, defined by the variable @t{LinearMediumBoxFile}.
@end itemize

@c ----------------------------------
@item @strong{LinearMediumBoxSize}@*
@vindex @code{LinearMediumBoxSize}@*
@emph{Section}: Maxwell@*
@emph{Type}: block@*
@* Defines center and size of a parallelepiped linear medium box.

 Example:

 @t{%LinearMediumBoxSize
 @*@ @    center_x | center_y | center_z | x_length | y_length | z_length
 @*%}



@c ----------------------------------
@item @strong{LinearMediumEdgeProfile}@*
@vindex @code{LinearMediumEdgeProfile}@*
@emph{Section}: Maxwell@*
@emph{Type}: integer@*
@* Defines the type of numerical approximation used for the derivatives at the edges of the medium box.
 Default is edged. When the box shape is read from file, only the edged profile is supported.



@emph{Options}:
@itemize @minus
@item @strong{edged}:  Medium box edges are considered steep for derivatives.
@item @strong{smooth}:  Medium box edged and softened for derivatives.
@end itemize

@c ----------------------------------
@item @strong{LinearMediumProperties}@*
@vindex @code{LinearMediumProperties}@*
@emph{Section}: Maxwell@*
@emph{Type}: block@*
@* Defines electromagnetic parameters for a linear medium box.

 Example:

 @t{%LinearMediumProperties
 @*@ @    epsilon_factor | mu_factor | sigma_e | sigma_m
 @*%}

 Permittivity factor, permeability factor, electric conductivity and magnetic conductivity of the medium box.



@c ----------------------------------
@item @strong{MediumCurrentCoordinates}@*
@vindex @code{MediumCurrentCoordinates}@*
@emph{Section}: Maxwell@*
@emph{Type}: block@*
@*  This allows to output phasor current vectors at particular points in space.

 @t{%MediumCurrentCoordinates
 @*@ @     -1.0 | 2.0 |  4.0
 @*@ @      0.0 | 1.0 | -2.0
 @*%}




@c ----------------------------------
@item @strong{MediumDispersionType}@*
@vindex @code{MediumDispersionType}@*
@emph{Section}: Maxwell@*
@emph{Type}: integer@*
@emph{Default}: drude_medium@*
@* Dispersion model used for the medium (only Drude model available for the moment).


@emph{Options}:
@itemize @minus
@item @strong{drude_medium}:  Drude type of dispersion.
@end itemize

@c ----------------------------------
@item @strong{MediumPoleDamping}@*
@vindex @code{MediumPoleDamping}@*
@emph{Section}: Maxwell@*
@emph{Type}: float@*
@* Damping factor (inverse relaxation time) of the medium.



@c ----------------------------------
@item @strong{MediumPoleEnergy}@*
@vindex @code{MediumPoleEnergy}@*
@emph{Section}: Maxwell@*
@emph{Type}: float@*
@* Energy of the pole.



@c ----------------------------------
@item @strong{MediumPoleStrength}@*
@vindex @code{MediumPoleStrength}@*
@emph{Section}: Maxwell@*
@emph{Type}: float@*
@emph{Default}: 1.0@*
@* Strength of the pole (unitless).



@c ----------------------------------
@item @strong{PlaneWavesOnOneSide}@*
@vindex @code{PlaneWavesOnOneSide}@*
@emph{Section}: Maxwell@*
@emph{Type}: logical@*
@emph{Default}: No@*
@* If PlaneWaves should be fed to the box only from one side.



@c ----------------------------------
@item @strong{PlaneWavesSide}@*
@vindex @code{PlaneWavesSide}@*
@emph{Section}: Maxwell@*
@emph{Type}: string@*
@* Side of the box in which plane waves are evaluated on the boundaries: negative would mean
 on boundaries which are towards negative values in the selected directions (e.g. -x).


@emph{Options}:
@itemize @minus
@item @strong{negative}:  Negative side.
@item @strong{positive}:  Positive side.
@end itemize

@c ----------------------------------
@item @strong{RegularizationFunction}@*
@vindex @code{RegularizationFunction}@*
@emph{Section}: Maxwell@*
@emph{Type}: integer@*
@emph{Default}: COS2@*
@* The current arising from charged point particles must be mapped onto the Maxwell
 propagation grid. This requires a smearing or regularization function $\phi(\mathbf{r})$ attached to
 each particle position $\mathbf{r}_i$ with user defined cutoff width, $\sigma$


@emph{Options}:
@itemize @minus
@item @strong{COS2}:  $\phi(r)=\text{cos}^2(\frac{\pi}{2}\frac{|\mathbf{r}-\mathbf{r}_i|}{\sigma})$
 if $|\mahtbf{r}-\mathbf{r}_i|<\sigma$, and 0 otherwise.
@end itemize

@c ----------------------------------
@item @strong{RegularizationFunctionWidth}@*
@vindex @code{RegularizationFunctionWidth}@*
@emph{Section}: Maxwell@*
@emph{Type}: float@*
@emph{Default}: 2@*
@* The current arising from charged point particles must be mapped onto the Maxwell
 propagation grid. This requires a smearing or regularization function $\phi(\mathbf{r})$ attached to
 each particle position $\mathbf{r}_i$ with user defined cutoff width, $\sigma$.
 Default 2 bohrradii



@c ----------------------------------
@end itemize
@node Coordinates,,,
@subsection Coordinates
@c ----------------------------------

@itemize
@item @strong{MaxwellFieldsCoordinate}@*
@vindex @code{MaxwellFieldsCoordinate}@*
@emph{Section}: Maxwell::Coordinates@*
@emph{Type}: block@*
@*  The Maxwell MaxwellFieldsCoordinate block allows to output Maxwell fields at particular
  points in space. For each point a new line with three columns has to be added to the block,
  where the columns denote the x, y, and z coordinate of the point.

 @t{%MaxwellFieldsCoordinate
 @*@ @     -1.0 | 2.0 |  4.0
 @*@ @      0.0 | 1.0 | -2.0
 @*%}




@c ----------------------------------
@end itemize
@node MaxwellStates,,,
@section MaxwellStates
@c ----------------------------------

@itemize
@item @strong{MaxwellIncidentWaves}@*
@vindex @code{MaxwellIncidentWaves}@*
@emph{Section}: MaxwellStates@*
@emph{Type}: block@*
@* The initial electromagnetic fields can be set by the user
 with the @t{MaxwellIncidentWaves} block variable.
 The electromagnetic fields have to fulfill the
 Maxwells equations in vacuum.

 Example:

 @t{%MaxwellIncidentWaves
 @*@ @    plane_wave_parser      | "k1x" | "k1y" | "k1z" | "E1x" | "E1z" | "E1x"
 @*@ @    plane_wave_parser      | "k2x" | "k2y" | "k2z" | "E2x" | "E2y" | "E2z"
 @*@ @    plane_wave_gauss       | "k3x" | "k3y" | "k3z" | "E3x" | "E3y" | "E3z" | "width" | "shift"
 @*@ @    plane_wave_mx_function | "E4x" | "E4y" | "E4z" | mx_envelope_name
 @*%}

 Description about MaxwellIncidentWaves follows



@emph{Options}:
@itemize @minus
@item @strong{plane_wave_parser}:  Parser input modus
@item @strong{plane_wave_mx_function}:  The incident wave envelope is defined by an mx_function
@end itemize

@c ----------------------------------
@item @strong{PropagateSpatialMaxwellField}@*
@vindex @code{PropagateSpatialMaxwellField}@*
@emph{Section}: MaxwellStates@*
@emph{Type}: logical@*
@emph{Default}: yes@*
@* Allow for numerical propagation of Maxwells equations of spatially constant field.
 If set to no, do only analytic evaluation of the field inside the box.



@c ----------------------------------
@item @strong{UserDefinedConstantSpatialMaxwellField}@*
@vindex @code{UserDefinedConstantSpatialMaxwellField}@*
@emph{Section}: MaxwellStates@*
@emph{Type}: block@*
@* Define parameters of spatially constant field.

 Example:

 @t{%UserDefinedConstantSpatialMaxwellFields
 @*@ @    plane_wave_parser      | E_x | E_y | E_z | B_x | B_y | B_z | "tdf_function"
 @*%}

 This block defines three components of E field, three components of B field, and reference to
 the TD function.




@c ----------------------------------
@item @strong{UserDefinedInitialMaxwellStates}@*
@vindex @code{UserDefinedInitialMaxwellStates}@*
@emph{Section}: MaxwellStates@*
@emph{Type}: block@*
@* The initial electromagnetic fields can be set by the user
 with the @t{UserDefinedMaxwellStates} block variable.
 The electromagnetic fields have to fulfill the
 Maxwells equations in vacuum.

 Example:

 @t{%UserDefinedMaxwellStates
 @*@ @  formula | 2 | "magnetic_field" | "-1/P_c * sin(x)"
 @*@ @  formula | 3 | "electric_field" | "   sin(x)      "
 @*%}

 The second column specifies the component of the dimension of
 the electric field and magnetic field. The first column
 indicates that column four should be interpreted
 as a formula for the corresponding state. P_c is the
 speed of light constant.

 Alternatively, if column one states @t{file} the
 electric field and magnetic field will be read from
 the files given in column four.

 @t{%UserDefinedMaxwellStates
 @*@ @  file | 3 | electric_field | "/path/to/file_electric_field_of_dimension_3"
 @*@ @  file | 2 | magnetic_field | "/path/to/file_magnetic_field_of_dimension_2"
 @*%}

 The third option to define the initial state inside the box is to extend
 the plane waves used as incident waves in the @t{MaxwellIncidentWaves} block,
 as follows:

 @t{%UserDefinedMaxwellStates
 @*@ @  use_incident_waves
 @*%}



@emph{Options}:
@itemize @minus
@item @strong{file}:  Read initial orbital from file.
 Accepted file formats: obf, ncdf and csv.
@item @strong{electric_field}:  This row defines the electric field component of the corresponding dimension
@item @strong{formula}:  Calculate initial orbital by given analytic expression.
@item @strong{magnetic_field}:  This row defines the magnetic field component of the corresponding dimension
@item @strong{use_incident_waves}:  Extend the plane waves given in the @t{MaxwellIncidentWaves} block inside the box.
@end itemize

@c ----------------------------------
@item @strong{UserDefinedMaxwellExternalCurrent}@*
@vindex @code{UserDefinedMaxwellExternalCurrent}@*
@emph{Section}: MaxwellStates@*
@emph{Type}: block@*
@*
 Example:

 @t{%UserDefinedMaxwellExternalCurrent
 @*@ @  current_parser      | "expression_x_dir1" | "expression_y_dir1" | "expression_z_dir1"
 @*@ @  current_parser      | "expression_x_dir2" | "expression_y_dir2" | "expression_z_dir2"
 @*@ @  current_td_function | "amplitude_j0_x"    | "amplitude_j0_y"    | "amplitude_j0_z"    | omega   | envelope_td_function_name | phase
 @*%}

 Description about UserDefinedMaxwellExternalCurrent follows



@emph{Options}:
@itemize @minus
@item @strong{current_parser}:  description follows
@item @strong{current_td_function}:  description follows
@end itemize

@c ----------------------------------
@end itemize
@node Mesh,,,
@section Mesh
@c ----------------------------------

@itemize
@item @strong{MeshIndexType}@*
@vindex @code{MeshIndexType}@*
@emph{Section}: Mesh@*
@emph{Type}: integer@*
@emph{Default}: idx_cubic@*
@* Determine index type. Must be the same for restarting a calculation.


@emph{Options}:
@itemize @minus
@item @strong{idx_cubic}:  Cubic indices are used to map the spatial information to the grid points.
@item @strong{idx_hilbert}:  A Hilbert space-filling curve is used to map the spatial information to
 the grid points.
@end itemize

@c ----------------------------------
@item @strong{MultigridLevels}@*
@vindex @code{MultigridLevels}@*
@emph{Section}: Mesh@*
@emph{Type}: integer@*
@emph{Default}: max_levels@*
@* Number of levels in the grid hierarchy used for multigrid. Positive
 numbers indicate an absolute number of levels, negative
 numbers are subtracted from the maximum number of levels possible.


@emph{Options}:
@itemize @minus
@item @strong{max_levels}:  Calculate the optimal number of levels for the grid.
@end itemize

@c ----------------------------------
@item @strong{PeriodicBoundaryMask}@*
@vindex @code{PeriodicBoundaryMask}@*
@emph{Section}: Mesh@*
@emph{Type}: block@*
@* (Experimental) Defines a mask for which periodic boundaries are replaced by zero boundary conditions.



@c ----------------------------------
@item @strong{Spacing}@*
@vindex @code{Spacing}@*
@emph{Section}: Mesh@*
@emph{Type}: float@*
@* The spacing between the points in the mesh. This controls the
 quality of the discretization: smaller spacing gives more
 precise results but increased computational cost.

 When using curvilinear coordinates, this is a canonical spacing
 that will be changed locally by the transformation. In periodic
 directions, your spacing may be slightly different than what
 you request here, since the box size must be an integer
 multiple of the spacing.

 The default value is defined by the species if only default pseudopotentials are used
 or by the image resolution if @t{BoxShape = box_image}. Otherwise, there is
 no default.

 It is possible to have a different spacing in each one of the Cartesian directions
 if we define @t{Spacing} as block of the form

 @t{%Spacing
 @*@ @ spacing_x | spacing_y | spacing_z
 @*%}



@c ----------------------------------
@item @strong{SpiralBoundaryCondition}@*
@vindex @code{SpiralBoundaryCondition}@*
@emph{Section}: Mesh@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* (Experimental) If set to yes, Octopus will apply spin-spiral boundary conditions.
 The momentum of the spin spiral is defined by the variable
 @t{TDMomentumTransfer}



@c ----------------------------------
@end itemize
@node Curvilinear,,,
@subsection Curvilinear
@c ----------------------------------

@itemize
@item @strong{CurvMethod}@*
@vindex @code{CurvMethod}@*
@emph{Section}: Mesh::Curvilinear@*
@emph{Type}: integer@*
@emph{Default}: curv_uniform@*
@* The relevant functions in octopus are represented on a mesh in real space.
 This mesh may be an evenly spaced regular rectangular grid (standard mode),
 or else an adaptive or curvilinear grid. We have implemented
 three kinds of adaptive meshes, although only one is currently working,
 the one invented by F. Gygi (@t{curv_gygi}). The code will stop if any of
 the other two is invoked. All are experimental with domain parallelization.


@emph{Options}:
@itemize @minus
@item @strong{curv_affine}:  Regular, uniform rectangular grid.
@item @strong{curv_gygi}:  The deformation of the grid is done according to the scheme described by
 F. Gygi [F. Gygi and G. Galli, @emph{Phys. Rev. B} @strong{52}, R2229 (1995)].
@item @strong{curv_briggs}:  The deformation of the grid is done according to the scheme described by
 Briggs [E.L. Briggs, D.J. Sullivan, and J. Bernholc, @emph{Phys. Rev. B} @strong{54} 14362 (1996)]
 (NOT WORKING).
@item @strong{curv_modine}:  The deformation of the grid is done according to the scheme described by
 Modine [N.A. Modine, G. Zumbach and E. Kaxiras, @emph{Phys. Rev. B} @strong{55}, 10289 (1997)]
 (NOT WORKING).
@end itemize

@c ----------------------------------
@end itemize
@node Gygi,,,
@subsubsection Gygi
@c ----------------------------------

@itemize
@item @strong{CurvGygiA}@*
@vindex @code{CurvGygiA}@*
@emph{Section}: Mesh::Curvilinear::Gygi@*
@emph{Type}: float@*
@emph{Default}: 0.5@*
@* The grid spacing is reduced locally around each atom, and the reduction is
 given by 1/(1+@emph{A}), where @emph{A} is specified by this variable. So, if
 @emph{A}=1/2 (the default), the grid spacing is reduced to two thirds = 1/(1+1/2).
 [This is the \(A_{\alpha}\) variable in Eq. 2 of F. Gygi and G. Galli, @emph{Phys.
 Rev. B} @strong{52}, R2229 (1995)]. It must be larger than zero.



@c ----------------------------------
@item @strong{CurvGygiAlpha}@*
@vindex @code{CurvGygiAlpha}@*
@emph{Section}: Mesh::Curvilinear::Gygi@*
@emph{Type}: float@*
@emph{Default}: 2.0 a.u.@*
@* This number determines the region over which the grid is enhanced (range of
 enhancement of the resolution). That is, the grid is enhanced on a sphere
 around each atom, whose radius is given by this variable. [This is the \(a_{\alpha}\)
 variable in Eq. 2 of F. Gygi and G. Galli, @emph{Phys. Rev. B} @strong{52}, R2229 (1995)].
 It must be larger than zero.



@c ----------------------------------
@item @strong{CurvGygiBeta}@*
@vindex @code{CurvGygiBeta}@*
@emph{Section}: Mesh::Curvilinear::Gygi@*
@emph{Type}: float@*
@emph{Default}: 4.0 a.u.@*
@* This number determines the distance over which Euclidean coordinates are
 recovered. [This is the \(b_{\alpha}\) variable in Eq. 2 of F. Gygi and G. Galli,
 @emph{Phys. Rev. B} @strong{52}, R2229 (1995)]. It must be larger than zero.



@c ----------------------------------
@end itemize
@node Modine,,,
@subsubsection Modine
@c ----------------------------------

@itemize
@item @strong{CurvModineJBar}@*
@vindex @code{CurvModineJBar}@*
@emph{Section}: Mesh::Curvilinear::Modine@*
@emph{Type}: float@*
@emph{Default}: 1/2@*
@* Increase in density of points is inverse of this parameter.
 See N. A. Modine, G. Zumbach, and E. Kaxiras, @emph{Phys. Rev. B} @strong{55}, 10289-10301 (1997).



@c ----------------------------------
@item @strong{CurvModineJlocal}@*
@vindex @code{CurvModineJlocal}@*
@emph{Section}: Mesh::Curvilinear::Modine@*
@emph{Type}: float@*
@emph{Default}: 0.25@*
@* Local refinement around the atoms. Must be between 0 and 1.
 See N. A. Modine, G. Zumbach, and E. Kaxiras, @emph{Phys. Rev. B} @strong{55}, 10289-10301 (1997).



@c ----------------------------------
@item @strong{CurvModineJrange}@*
@vindex @code{CurvModineJrange}@*
@emph{Section}: Mesh::Curvilinear::Modine@*
@emph{Type}: float@*
@emph{Default}: 2 b@*
@* Local refinement range (a length).
 See N. A. Modine, G. Zumbach, and E. Kaxiras, @emph{Phys. Rev. B} @strong{55}, 10289-10301 (1997).



@c ----------------------------------
@item @strong{CurvModineXBar}@*
@vindex @code{CurvModineXBar}@*
@emph{Section}: Mesh::Curvilinear::Modine@*
@emph{Type}: float@*
@emph{Default}: 1/3@*
@* Size of central flat region (in units of @t{Lsize}). Must be between 0 and 1.
 See N. A. Modine, G. Zumbach, and E. Kaxiras, @emph{Phys. Rev. B} @strong{55}, 10289-10301 (1997).



@c ----------------------------------
@end itemize
@node Derivatives,,,
@subsection Derivatives
@c ----------------------------------

@itemize
@item @strong{DerivativesOrder}@*
@vindex @code{DerivativesOrder}@*
@emph{Section}: Mesh::Derivatives@*
@emph{Type}: integer@*
@emph{Default}: 4@*
@* This variable gives the discretization order for the approximation of
 the differential operators. This means, basically, that
 @t{DerivativesOrder} points are used in each positive/negative
 spatial direction, @emph{e.g.} @t{DerivativesOrder = 1} would give
 the well-known three-point formula in 1D.
 The number of points actually used for the Laplacian
 depends on the stencil used. Let \(O\) = @t{DerivativesOrder}, and \(d\) = @t{Dimensions}.
 @itemize

 @item
 @t{stencil_star}: \(2 O d + 1\)
 @item
 @t{stencil_cube}: \((2 O + 1)^d\)
 @item
 @t{stencil_starplus}: \(2 O d + 1 + n\) with @emph{n} being 8
 in 2D and 24 in 3D.
 @end itemize




@c ----------------------------------
@item @strong{DerivativesStencil}@*
@vindex @code{DerivativesStencil}@*
@emph{Section}: Mesh::Derivatives@*
@emph{Type}: integer@*
@emph{Default}: stencil_star@*
@* Decides what kind of stencil is used, @emph{i.e.} which points, around
 each point in the mesh, are the neighboring points used in the
 expression of the differential operator.

 If curvilinear coordinates are to be used, then only the @t{stencil_starplus}
 or the @t{stencil_cube} may be used. We only recommend the @t{stencil_starplus},
 since the cube typically needs far too much memory.


@emph{Options}:
@itemize @minus
@item @strong{stencil_star}:  A star around each point (@emph{i.e.}, only points on the axis).
@item @strong{stencil_variational}:  Same as the star, but with coefficients built in a different way.
@item @strong{stencil_cube}:  A cube of points around each point.
@item @strong{stencil_starplus}:  The star, plus a number of off-axis points.
@item @strong{stencil_stargeneral}:  The general star. Default for non-orthogonal grids.
@end itemize

@c ----------------------------------
@item @strong{MultigridDerivativesOrder}@*
@vindex @code{MultigridDerivativesOrder}@*
@emph{Section}: Mesh::Derivatives@*
@emph{Type}: integer@*
@emph{Default}: 1@*
@* This variable gives the discretization order for the approximation of
 the differential operators on the different levels of the multigrid.
 For more details, see the variable DerivativesOrder.



@c ----------------------------------
@end itemize
@node FFTs,,,
@subsection FFTs
@c ----------------------------------

@itemize
@item @strong{DoubleFFTParameter}@*
@vindex @code{DoubleFFTParameter}@*
@emph{Section}: Mesh::FFTs@*
@emph{Type}: float@*
@emph{Default}: 2.0@*
@* For solving the Poisson equation in Fourier space, and for applying the local potential
 in Fourier space, an auxiliary cubic mesh is built. This mesh will be larger than
 the circumscribed cube of the usual mesh by a factor @t{DoubleFFTParameter}. See
 the section that refers to Poisson equation, and to the local potential for details
 [the default value of two is typically good].



@c ----------------------------------
@item @strong{FFTLibrary}@*
@vindex @code{FFTLibrary}@*
@emph{Section}: Mesh::FFTs@*
@emph{Type}: integer@*
@emph{Default}: fftw@*
@* (experimental) You can select the FFT library to use.


@emph{Options}:
@itemize @minus
@item @strong{fftw}:  Uses FFTW3 library.
@item @strong{pfft}:  (experimental) Uses PFFT library, which has to be linked.
@item @strong{accel}:  (experimental) Uses a GPU accelerated library. This only
 works if Octopus was compiled with Cuda or OpenCL support.
@end itemize

@c ----------------------------------
@item @strong{FFTOptimize}@*
@vindex @code{FFTOptimize}@*
@emph{Section}: Mesh::FFTs@*
@emph{Type}: logical@*
@emph{Default}: yes@*
@* Should @t{octopus} optimize the FFT dimensions?
 This means that the mesh to which FFTs are applied is not taken to be as small
 as possible: some points may be added to each direction in order to get a "good number"
 for the performance of the FFT algorithm.
 The best FFT grid dimensions are given by \(2^a 3^b 5^c 7^d 11^e 13^f\)
 where \(a,b,c,d\) are arbitrary and \(e,f\) are 0 or 1.
 (<a href=http://www.fftw.org/doc/Complex-DFTs.html>ref</a>).
 In some cases, namely when using
 the split-operator, or Suzuki-Trotter propagators, this option should be turned off.
 For spatial FFTs in periodic directions, the grid is never optimized, but a warning will
 be written if the number is not good, with a suggestion of a better one to use, so you
 can try a different spacing if you want to get a good number.



@c ----------------------------------
@item @strong{FFTPreparePlan}@*
@vindex @code{FFTPreparePlan}@*
@emph{Section}: Mesh::FFTs@*
@emph{Type}: integer@*
@emph{Default}: fftw_measure@*
@* The FFTs are performed in octopus with the help of <a href=http://www.fftw.org>FFTW</a> and similar packages.
 Before doing the actual computations, this package prepares a "plan", which means that
 the precise numerical strategy to be followed to compute the FFT is machine/compiler-dependent,
 and therefore the software attempts to figure out which is this precise strategy (see the
 FFTW documentation for details). This plan preparation, which has to be done for each particular
 FFT shape, can be done exhaustively and carefully (slow), or merely estimated. Since this is
 a rather critical numerical step, by default it is done carefully, which implies a longer initial
 initialization, but faster subsequent computations. You can change this behaviour by changing
 this @t{FFTPreparePlan} variable, and in this way you can force FFTW to do a fast guess or
 estimation of which is the best way to perform the FFT.


@emph{Options}:
@itemize @minus
@item @strong{fftw_measure}:  This is the default, and implies a longer initialization, but involves a more careful analysis
 of the strategy to follow, and therefore more efficient FFTs.
@item @strong{fftw_patient}:  It is like fftw_measure, but considers a wider range of algorithms and often produces a
 "more optimal" plan (especially for large transforms), but at the expense of several times
 longer planning time (especially for large transforms).
@item @strong{fftw_estimate}:  This is the "fast initialization" scheme, in which the plan is merely guessed from "reasonable"
 assumptions.
@item @strong{fftw_exhaustive}:  It is like fftw_patient, but considers an even wider range of algorithms,
 including many that we think are unlikely to be fast, to produce the most optimal
  plan but with a substantially increased planning time.
@end itemize

@c ----------------------------------
@item @strong{NFFTCutoff}@*
@vindex @code{NFFTCutoff}@*
@emph{Section}: Mesh::FFTs@*
@emph{Type}: integer@*
@emph{Default}: 6@*
@* Cut-off parameter of the window function.
 See NFFT manual for details.



@c ----------------------------------
@item @strong{NFFTGuruInterface}@*
@vindex @code{NFFTGuruInterface}@*
@emph{Section}: Mesh::FFTs@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* Perform NFFT with guru interface. This permits the fine tuning of several critical parameters.



@c ----------------------------------
@item @strong{NFFTOversampling}@*
@vindex @code{NFFTOversampling}@*
@emph{Section}: Mesh::FFTs@*
@emph{Type}: float@*
@emph{Default}: 2@*
@* NFFT oversampling factor (sigma). This will rule the size of the FFT under the hood.



@c ----------------------------------
@item @strong{NFFTPrecompute}@*
@vindex @code{NFFTPrecompute}@*
@emph{Section}: Mesh::FFTs@*
@emph{Type}: integer@*
@emph{Default}: NFFT_PRE_PSI@*
@* NFFT precomputation strategy.


@emph{Options}:
@itemize @minus
@item @strong{NFFT_PRE_PSI}:  This method uses a medium amount of memory to store d*(2*m+1)*M real numbers and requires at most
 2(2m + 1)d extra multiplications for each node.
 This is the default option.
@item @strong{NFFT_PRE_FULL_PSI}:  Is the fastest method but requires a large amount of memory as it requires to store (2*m+1)^d*M
 real numbers. No extra operations are needed during matrix vector multiplication.
@item @strong{NFFT_PRE_LIN_PSI}:  This method implements a linear interpolation from a lookup table.
@end itemize

@c ----------------------------------
@item @strong{PNFFTCutoff}@*
@vindex @code{PNFFTCutoff}@*
@emph{Section}: Mesh::FFTs@*
@emph{Type}: integer@*
@emph{Default}: 6@*
@* Cut-off parameter of the window function.



@c ----------------------------------
@item @strong{PNFFTOversampling}@*
@vindex @code{PNFFTOversampling}@*
@emph{Section}: Mesh::FFTs@*
@emph{Type}: float@*
@emph{Default}: 2.0@*
@* PNFFT oversampling factor (sigma). This will rule the size of the FFT under the hood.



@c ----------------------------------
@end itemize
@node KPoints,,,
@subsection KPoints
@c ----------------------------------

@itemize
@item @strong{KPoints}@*
@vindex @code{KPoints}@*
@emph{Section}: Mesh::KPoints@*
@emph{Type}: block@*
@* This block defines an explicit set of @emph{k}-points and their weights for
 a periodic-system calculation. The first column is the weight
 of each @emph{k}-point and the following are the components of the @emph{k}-point
 vector. You only need to specify the components for the
 periodic directions. Note that the @emph{k}-points should be given in
 Cartesian coordinates (not in reduced coordinates), in the units of inverse length.
 The weights will be renormalized so they sum to 1 (and must be rational numbers).

 For example, if you want to include only the Gamma point, you can
 use:

 @t{%KPoints
 @*@ @ 1.0 | 0 | 0 | 0
 @*%}




@c ----------------------------------
@item @strong{KPointsGrid}@*
@vindex @code{KPointsGrid}@*
@emph{Section}: Mesh::KPoints@*
@emph{Type}: block@*
@emph{Default}: \(\Gamma\)-point only@*
@* When this block is given (and the @t{KPoints} block is not present),
 @emph{k}-points are distributed in a uniform grid, according to a modified
 version of the Monkhorst-Pack scheme. For the original MP scheme, see
 James D. Pack and Hendrik J. Monkhorst,
 @emph{Phys. Rev. B} @strong{13}, 5188 (1976) and @emph{Phys. Rev. B} @strong{16}, 1748 (1977).

 The first row of the block is a set of integers defining
 the number of @emph{k}-points to be used along each direction
 in reciprocal space. The numbers refer to the whole Brillouin
 zone, and the actual number of @emph{k}-points is usually
 reduced exploiting the symmetries of the system.  By default
 the grid will always include the \(\Gamma\)-point. Optional
 rows can be added to specify multiple shifts in the @emph{k}-points (between 0.0 and 1.0),
 in units of the Brillouin zone divided by the number in the first row.
 The number of columns should be equal to @t{Dimensions},
 but the grid and shift numbers should be 1 and zero in finite directions.

 For example, the following input samples the BZ with 100 points in the
 @emph{xy}-plane of reciprocal space:

 @t{%KPointsGrid
 @*@ @ 10 | 10 | 1
 @*%}




@c ----------------------------------
@item @strong{KPointsPath}@*
@vindex @code{KPointsPath}@*
@emph{Section}: Mesh::KPoints@*
@emph{Type}: block@*
@* When this block is given, @emph{k}-points are generated along a path
 defined by the points of the list.
 The points must be given in reduced coordinates.

 The first row of the block is a set of integers defining
 the number of @emph{k}-points for each segments of the path.
 The number of columns should be equal to @t{Dimensions},
 and the k-points coordinate should be zero in finite directions.

 For example, the following input samples the BZ with 15 points:

 @t{%KPointsPath
 @*@ @ 10 | 5
 @*@ @  0 | 0 | 0
 @*@ @  0.5 | 0 | 0
 @*@ @  0.5 | 0.5 | 0.5
 @*%}




@c ----------------------------------
@item @strong{KPointsReduced}@*
@vindex @code{KPointsReduced}@*
@emph{Section}: Mesh::KPoints@*
@emph{Type}: block@*
@* Same as the block @t{KPoints} but this time the input is given in reduced
 coordinates, @emph{i.e.}
 what @t{Octopus} writes in a line in the ground-state standard output as

 @t{#k =   1, k = (    0.154000,    0.154000,    0.154000)}.



@c ----------------------------------
@item @strong{KPointsUseSymmetries}@*
@vindex @code{KPointsUseSymmetries}@*
@emph{Section}: Mesh::KPoints@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* This variable defines whether symmetries are taken into account
 or not for the choice of @emph{k}-points. If it is set to no, the @emph{k}-point
 sampling will range over the full Brillouin zone.

 When a perturbation is applied to the system, the full
 symmetries of the system cannot be used. In this case you must
 not use symmetries or use the @t{SymmetryBreakDir} to tell
 Octopus the direction of the perturbation (for the moment this
 has to be done by hand by the user, in the future it will be
 automatic).




@c ----------------------------------
@item @strong{KPointsUseTimeReversal}@*
@vindex @code{KPointsUseTimeReversal}@*
@emph{Section}: Mesh::KPoints@*
@emph{Type}: logical@*
@* If symmetries are used to reduce the number of @emph{k}-points,
 this variable defines whether time-reversal symmetry is taken
 into account or not. If it is set to no, the @emph{k}-point
 sampling will not be reduced according to time-reversal
 symmetry.

 The default is yes, unless symmetries are broken in one
 direction by the @t{SymmetryBreakDir} block.

 Warning: For time propagation runs with an external field,
 time-reversal symmetry should not be used.




@c ----------------------------------
@item @strong{QPointsGrid}@*
@vindex @code{QPointsGrid}@*
@emph{Section}: Mesh::KPoints@*
@emph{Type}: block@*
@emph{Default}: KPointsGrid@*
@* This block allows to define a q-point grid used for the calculation of the Fock operator
 with k-points. The @emph{q}-points are distributed in a uniform grid, as done for the
 @t{KPointsGrid} variable.
 See J. Chem Phys. 124, 154709 (2006) for details

 For each dimension, the number of q point must be a divider of the number of  k point

 @t{%QPointsGrid
 @*@ @ 2 | 2 | 1
 @*%}

 At the moment, this is not compatible with k-point symmetries.




@c ----------------------------------
@end itemize
@node Simulation Box,,,
@subsection Simulation Box
@c ----------------------------------

@itemize
@item @strong{BoxCgalFile}@*
@vindex @code{BoxCgalFile}@*
@emph{Section}: Mesh::Simulation Box@*
@emph{Type}: string@*
@* Filename to be read in by the cgal library. It should describe a shape that
 is used for the simulation box



@c ----------------------------------
@item @strong{BoxShape}@*
@vindex @code{BoxShape}@*
@emph{Section}: Mesh::Simulation Box@*
@emph{Type}: integer@*
@* This variable decides the shape of the simulation box.
 The default is @t{minimum} for finite systems and @t{parallelepiped} for periodic systems.
 Note that some incompatibilities apply:
 @itemize
@item
Spherical or minimum mesh is not allowed for periodic systems.
 @item
Cylindrical mesh is not allowed for systems that are periodic in more than one dimension.
 @item
@t{box_image} is only allowed in 2D.@end itemize



@emph{Options}:
@itemize @minus
@item @strong{sphere}:  The simulation box will be a sphere of radius @t{Radius}. (In 2D, this is a circle.)
@item @strong{cylinder}:  The simulation box will be a cylinder with radius @t{Radius} and height (in the @emph{x}-direction)
 of 2 @t{Xlength}.
@item @strong{minimum}:  The simulation box will be constructed by adding spheres created around each
 atom (or user-defined potential), of radius @t{Radius}.
@item @strong{parallelepiped}:  The simulation box will be a parallelepiped whose dimensions are taken from
 the variable @t{Lsize}.
@item @strong{box_image}:  The simulation box will be defined through an image, specified with @t{BoxShapeImage}.
 White (RGB = 255,255,255) means that the point
 is contained in the simulation box, while any other color means that the point is out.
 The image will be scaled to fit @t{Lsize}, while its resolution will define the default @t{Spacing}.
 The actual box may be slightly larger than @t{Lsize} to ensure one grid point = one pixel for
 default @t{Spacing}.
@item @strong{box_cgal}:  The simulation box will be defined by a file read using the CGAL library.
 The file name needs to be specified with @t{BoxCgalFile}.
 @t{Lsize} needs to be large enough to contain the shape defined in the file.
@item @strong{user_defined}:  The shape of the simulation box will be read from the variable @t{BoxShapeUsDef}.
@end itemize

@c ----------------------------------
@item @strong{BoxShapeImage}@*
@vindex @code{BoxShapeImage}@*
@emph{Section}: Mesh::Simulation Box@*
@emph{Type}: string@*
@* Name of the file that contains the image that defines the simulation box
 when @t{BoxShape = box_image}. No default. Will search in current
 directory and @t{OCTOPUS-HOME/share/}.



@c ----------------------------------
@item @strong{BoxShapeUsDef}@*
@vindex @code{BoxShapeUsDef}@*
@emph{Section}: Mesh::Simulation Box@*
@emph{Type}: string@*
@* Boolean expression that defines the interior of the simulation box. For example,
 @t{BoxShapeUsDef = "(sqrt(x^2+y^2) <= 4) && z>-2 && z<2"} defines a cylinder
 with axis parallel to the @emph{z}-axis.



@c ----------------------------------
@item @strong{LatticeParameters}@*
@vindex @code{LatticeParameters}@*
@emph{Section}: Mesh::Simulation Box@*
@emph{Type}: block@*
@* The lattice parameters (a, b, c).
 This variable is mandatory for periodic systems and is ignored otherwise.
 When PeriodicDimensions = 3, a second optional line can be used to
 define the angles between the lattice vectors. If the angles are not
 provided, then the variable LatticeVectors must be set.
 The number of parameters specified in the block must be at least equal
 to the number of periodic dimensions, but it is not mandatory to
 specify parameters for the non-periodic dimensions (in that case they
 are set to 1).



@c ----------------------------------
@item @strong{LatticeVectors}@*
@vindex @code{LatticeVectors}@*
@emph{Section}: Mesh::Simulation Box@*
@emph{Type}: block@*
@emph{Default}: simple cubic@*
@* Primitive lattice vectors. Vectors are stored in rows.
 Default:
 @t{%LatticeVectors
 @*@ @ 1.0 | 0.0 | 0.0
 @*@ @ 0.0 | 1.0 | 0.0
 @*@ @ 0.0 | 0.0 | 1.0
 @*%@*}



@c ----------------------------------
@item @strong{Lsize}@*
@vindex @code{Lsize}@*
@emph{Section}: Mesh::Simulation Box@*
@emph{Type}: block@*
@* If @t{BoxShape} is @t{parallelepiped}, @t{box_image},
 or @t{user_defined}, this is a block of the form:

 @t{%Lsize
 @*@ @ sizex | sizey | sizez | ...
 @*%}

 where the @t{size*} are half the lengths of the box in each direction.

 The number of columns must match the dimensionality of the
 calculation. If you want a cube you can also set @t{Lsize} as a
 single variable.



@c ----------------------------------
@item @strong{Radius}@*
@vindex @code{Radius}@*
@emph{Section}: Mesh::Simulation Box@*
@emph{Type}: float@*
@* Defines the radius for @t{BoxShape} = @t{sphere},
 @t{cylinder}, or @t{minimum}. Must be a positive
 number.



@c ----------------------------------
@item @strong{SymmetryBreakDir}@*
@vindex @code{SymmetryBreakDir}@*
@emph{Section}: Mesh::Simulation Box@*
@emph{Type}: block@*
@* This variable specifies a direction in which the symmetry of
 the system will be broken. This is useful for generating @emph{k}-point
 grids when an external perturbation is applied.



@c ----------------------------------
@item @strong{Xlength}@*
@vindex @code{Xlength}@*
@emph{Section}: Mesh::Simulation Box@*
@emph{Type}: float@*
@emph{Default}: @t{Radius}@*
@* If @t{BoxShape} is @t{cylinder}, the total length of the cylinder is twice @t{Xlength}.
 Note that when PeriodicDimensions = 1, then the length of the cylinder is determined from the lattice vectors.



@c ----------------------------------
@end itemize
@node Output,,,
@section Output
@c ----------------------------------

@itemize
@item @strong{BandStructureComputeProjections}@*
@vindex @code{BandStructureComputeProjections}@*
@emph{Section}: Output@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* Determines if projections of wavefunctions on the atomic orbitals
 are computed or not for obtaining the orbital resolved band-structure.



@c ----------------------------------
@item @strong{CurrentThroughPlane}@*
@vindex @code{CurrentThroughPlane}@*
@emph{Section}: Output@*
@emph{Type}: block@*
@* The code can calculate current
 traversing a user-defined portion of a plane, as specified by this block.
 A small plain-text file @t{current-flow} will be written containing this information.
 Only available for 1D, 2D, or 3D.
 In the format below, @t{origin} is a point in the plane.
 @t{u} and @t{v} are the (dimensionless) vectors defining the plane;
 they will be normalized. @t{spacing} is the fineness of the mesh
 on the plane. Integers @t{nu} and @t{mu} are the length and
 width of the portion of the plane, in units of @t{spacing}.
 Thus, the grid points included in the plane are
 @t{x_ij = origin + i*spacing*u + j*spacing*v},
 for @t{nu <= i <= mu} and @t{nv <= j <= mv}.
 Analogously, in the 2D case, the current flow is calculated through a line;
 in the 1D case, the current flow is calculated through a point. Note that the spacing
 can differ from the one used in the main calculation; an interpolation will be performed.

 Example (3D):

 @t{%CurrentThroughPlane
 @*@ @  0.0 | 0.0 | 0.0  # origin
 @*@ @  0.0 | 1.0 | 0.0  # u
 @*@ @  0.0 | 0.0 | 1.0  # v
 @*@ @  0.2              # spacing
 @*@ @  0 | 50           # nu | mu
 @*@ @  -50 | 50         # nv | mv
 @*%}

 Example (2D):

 @t{%CurrentThroughPlane
 @*@ @  0.0 | 0.0        # origin
 @*@ @  1.0 | 0.0        # u
 @*@ @  0.2              # spacing
 @*@ @  0 | 50           # nu | mu
 @*%}

 Example (1D):

 @t{%CurrentThroughPlane
 @*@ @  0.0              # origin
 @*%}




@c ----------------------------------
@item @strong{DOSComputePDOS}@*
@vindex @code{DOSComputePDOS}@*
@emph{Section}: Output@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* Determines if projected dos are computed or not.
 At the moment, the PDOS is computed from the bare pseudo-atomic orbitals, directly taken from
 the pseudopotentials. The orbitals are not orthonormalized, in order to preserve their
 atomic orbitals character. As a consequence, the sum of the different PDOS does not integrate
 to the total DOS.

 The radii of the orbitals are controled by the threshold defined by @t{AOThreshold<\tt>,
 and the fact that they are normalized or not by @t{AONormalize<\tt>.



@c ----------------------------------
@item @strong{DOSEnergyMax}@*
@vindex @code{DOSEnergyMax}@*
@emph{Section}: Output@*
@emph{Type}: float@*
@* Upper bound for the energy mesh of the DOS.
 The default is the highest eigenvalue, plus a quarter of the total range of eigenvalues.



@c ----------------------------------
@item @strong{DOSEnergyMin}@*
@vindex @code{DOSEnergyMin}@*
@emph{Section}: Output@*
@emph{Type}: float@*
@* Lower bound for the energy mesh of the DOS.
 The default is the lowest eigenvalue, minus a quarter of the total range of eigenvalues.



@c ----------------------------------
@item @strong{DOSEnergyPoints}@*
@vindex @code{DOSEnergyPoints}@*
@emph{Section}: Output@*
@emph{Type}: integer@*
@emph{Default}: 500@*
@* Determines how many energy points @t{Octopus} should use for
 the DOS energy grid.



@c ----------------------------------
@item @strong{DOSGamma}@*
@vindex @code{DOSGamma}@*
@emph{Section}: Output@*
@emph{Type}: float@*
@emph{Default}: 0.008 Ha@*
@* Determines the width of the Lorentzian which is used for the DOS sum.



@c ----------------------------------
@item @strong{ELFWithCurrentTerm}@*
@vindex @code{ELFWithCurrentTerm}@*
@emph{Section}: Output@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* The ELF, when calculated for complex wavefunctions, should contain
 a term dependent on the current. This term is properly calculated by
 default; however, for research purposes it may be useful not to add it.
 If this feature proves to be useless, this option should go away.



@c ----------------------------------
@item @strong{LinearMediumOutput}@*
@vindex @code{LinearMediumOutput}@*
@emph{Section}: Output@*
@emph{Type}: block@*
@emph{Default}: none@*
@* Specifies what to print. The output files are written at the beginning of the run into the output directory for the
 linear medium.
 Each option must be in a separate row. Optionally individual output formats can be defined
 for each row (VTK format is supported) or they can be read separately from @t{OutputFormat} in the input file.

 Example:
 @t{%LinearMediumOutput
 @*@ @ permittivity
 @*@ @ permeability
 @*%@*}
 This block supports all the formats of the @t{Output} block. See @t{Output}.


@emph{Options}:
@itemize @minus
@item @strong{points}:  Outputs 1 if the a given point is inside the medium, and 0 otherwise. This can be used to check the grid points of the medium region.
@item @strong{permittivity}:  Output of the (static) space-dependent relative permittivity
@item @strong{permeability}:  Output of the (static) space-dependent relative permeability
@item @strong{speed_of_light}:  Output of the speed of light in atomic units
@end itemize

@c ----------------------------------
@item @strong{LinearMediumOutputDir}@*
@vindex @code{LinearMediumOutputDir}@*
@emph{Section}: Output@*
@emph{Type}: string@*
@emph{Default}: "output_iter"@*
@* The name of the directory where @t{Octopus} stores the information
 about the linear medium system, as required by the @t{LinearMediumOutput} variable.



@c ----------------------------------
@item @strong{LocalMagneticMomentsSphereRadius}@*
@vindex @code{LocalMagneticMomentsSphereRadius}@*
@emph{Section}: Output@*
@emph{Type}: float@*
@* The local magnetic moments are calculated by integrating the
 magnetization density in spheres centered around each atom.
 This variable controls the radius of the spheres.
 The default is half the minimum distance between two atoms
 in the input coordinates, or 100 a.u. if there is only one atom (for isolated systems).



@c ----------------------------------
@item @strong{MaxwellOutput}@*
@vindex @code{MaxwellOutput}@*
@emph{Section}: Output@*
@emph{Type}: block@*
@emph{Default}: none@*
@* Specifies what to print. The output files are written at the end of the run into the output directory for the
 Maxwell run.
 Time-dependent simulations print only per iteration, including always the last. The frequency of output per iteration
 is set by @t{OutputInterval} and the directory is set by @t{OutputIterDir}.
 Each option must be in a separate row. Optionally individual output formats and output intervals can be defined
 for each row or they can be read separately from @t{OutputFormat} and @t{MaxwellOutputInterval} variables
 in the input file.

 Example:
 @t{%MaxwellOutput
 @*@ @ electric_field
 @*@ @ magnetic_field
 @*%@*}
 This block supports all the formats of the @t{Output} block.
 See @t{Output}.


@emph{Options}:
@itemize @minus
@item @strong{maxwell_energy_density}:  Output of the electromagnetic density
@item @strong{external_current}:  Output of the external Maxwell current
@item @strong{charge_density}:  Output of the charge density calculated by the divergence of the electric field.
@item @strong{orbital_angular_momentum}:  Output of the orbital angular momentum
@item @strong{vector_potential_mag}:  Output of the vector potential from magnetic field
@item @strong{magnetic_field_diff}:  Output of the magnetic field difference
@item @strong{electric_field}:  Output of the electric field
@item @strong{magnetic_field}:  Output of the magnetic field
@item @strong{trans_electric_field}:  Output of the transversal electric field
@item @strong{trans_magnetic_field}:  Output of the transversal magnetic field
@item @strong{long_electric_field}:  Output of the longitudinal electric field
@item @strong{long_magnetic_field}:  Output of the longitudinal magnetic field
@item @strong{div_electric_field}:  Output of the divergence of the electric field
@item @strong{div_magnetic_field}:  Output of the divergence of the magnetic field
@item @strong{poynting_vector}:  Output of the Maxwell Poynting vector
@end itemize

@c ----------------------------------
@item @strong{MaxwellOutputInterval}@*
@vindex @code{MaxwellOutputInterval}@*
@emph{Section}: Output@*
@emph{Type}: integer@*
@emph{Default}: 50@*
@* The output requested by variable @t{MaxwellOutput} is written
 to the directory @t{MaxwellOutputIterDir}
 when the iteration number is a multiple of the @t{MaxwellOutputInterval} variable.
 Subdirectories are named Y.X, where Y is @t{td}, @t{scf}, or @t{unocc}, and
 X is the iteration number. To use the working directory, specify @t{"."}
 (Output of restart files is instead controlled by @t{MaxwellRestartWriteInterval}.)
 Must be >= 0. If it is 0, then no output is written.
 This variable can also be defined inside the @t{MaxwellOutput} block.
 See @t{MaxwellOutput}.



@c ----------------------------------
@item @strong{MaxwellOutputIterDir}@*
@vindex @code{MaxwellOutputIterDir}@*
@emph{Section}: Output@*
@emph{Type}: string@*
@emph{Default}: "output_iter"@*
@* The name of the directory where @t{Octopus} stores information
 such as the density, forces, etc. requested by variable @t{MaxwellOutput}
 in the format specified by @t{OutputHow}.
 This information is written while iterating @t{CalculationMode = maxwell}
 according to @t{OutputInterval}, and has nothing to do with the restart information.



@c ----------------------------------
@item @strong{MomentumTransfer}@*
@vindex @code{MomentumTransfer}@*
@emph{Section}: Output@*
@emph{Type}: block@*
@* Momentum-transfer vector \(\vec{q}\) to be used when calculating matrix elements
 \(\left< f \left| e^{i \vec{q} \cdot \vec{r}} \right| i \right>\).
 This enables the calculation of the dynamical structure factor,
 which is closely related to generalized oscillator strengths.
 If the vector is not given, but TPA output is requested (@t{Output = TPA}),
 only the oscillator strengths are written in the output file.
 For example, to use \(\vec{q}\) = (0.1, 0.2, 0.3), set

 @t{%MomentumTransfer
 @*@ @  0.1 | 0.2 | 0.3
 @*%}



@c ----------------------------------
@item @strong{Output}@*
@vindex @code{Output}@*
@emph{Section}: Output@*
@emph{Type}: block@*
@emph{Default}: none@*
@* Specifies what to print.
 Each output must be in a separate row. Optionally individual output formats and output intervals can be defined
 for each row or they can be read separately from @t{OutputFormat} and @t{OutputInterval} variables
 in the input file.
 The output files are written at the end of the run into the output directory for the
 relevant kind of run (@emph{e.g.} @t{static} for @t{CalculationMode = gs}).
 Time-dependent simulations print only per iteration, including always the last. The frequency of output per iteration
 (available for @t{CalculationMode} = @t{gs}, @t{unocc},  @t{td}, and @t{opt_control})
 is set by @t{OutputInterval} and the directory is set by @t{OutputIterDir}.
 For linear-response run modes, the derivatives of many quantities can be printed, as listed in
 the options below. Indices in the filename are labelled as follows:
 @t{sp} = spin (or spinor component), @t{k} = @emph{k}-point, @t{st} = state/band.
 There is no tag for directions, given as a letter. The perturbation direction is always
 the last direction for linear-response quantities, and a following +/- indicates the sign of the frequency.

 Example (minimal):
 @t{%Output
 @*@ @ density
 @*@ @ potential
 @*%@*}

 Example (with OutputFormat):
 @t{%Output
 @*@ @ density   | cube + axis_z
 @*@ @ potential | cube
 @*%@*}

 Example (with OutputFormat, incomplete):
 @t{%Output
 @*@ @ density   | cube + axis_z
 @*@ @ potential
 @*%@*}

 Example (tagged):
 @t{%Output
 @*@ @ density   | "output_format" | cube + axis_z | "output_interval" | 50
 @*@ @ potential | "output_format" | cube          | "output_interval" | 20
 @*%@*}

 Example (tagged, incomplete):
 @t{%Output
 @*@ @ density   | "output_format"   | cube + axis_z
 @*@ @ potential | "output_interval" | 20
 @*%@*}
 Missing information for the incomplete blocks will be parsed form the out-of-block
 definitions. It is also possible to mix the order of columns in the tagged format.
 See @t{OutputFormat}, and @t{OutputInterval}.


@emph{Options}:
@itemize @minus
@item @strong{el_pressure}:  Outputs electronic pressure. See Tao, Vignale, and Tokatly, @emph{Phys Rev Lett} @strong{100}, 206405 (2008).
@item @strong{matrix_elements}:  Outputs a series of matrix elements of the Kohn-Sham states. What is output can
 be controlled by the @t{OutputMatrixElements} variable.
@item @strong{pol_density}:  Outputs dipole-moment density @t{dipole_density-}, or polarizability density @t{alpha_density-}
 in linear response. If @t{ResponseMethod = finite_differences}, the hyperpolarizability density
 @t{beta_density-} is also printed.
@item @strong{mesh_r}:  Outputs values of the coordinates over the grid. Files
 will be called @t{mesh_r-} followed by the direction.
@item @strong{kinetic_energy_density}:  Outputs kinetic-energy density, defined as:

 \(\tau_\sigma(\vec{r}) = \sum_{i=1}^{N_\sigma}
  \left| \vec{\nabla} \phi_{i\sigma}(\vec{r}) \right|^2\,. \)

 The index \(\sigma\) is the spin index for the spin-polarized case,
 or if you are using spinors. For spin-unpolarized calculations, you
 get the total kinetic-energy density. The previous expression assumes full
 or null occupations. If fractional occupation numbers, each term in the sum
 is weighted by the occupation. Also, if we are working with an infinite
 system, all @emph{k}-points are summed up, with their corresponding weights. The
 files will be called @t{tau-sp1} and @t{tau-sp2}, if the spin-resolved kinetic
 energy density is produced (runs in spin-polarized and spinors mode), or
 only @t{tau} if the run is in spin-unpolarized mode.
@item @strong{dos}:  Outputs density of states. See @t{DOSEnergyMax}, @t{DOSEnergyMin}, @t{DOSEnergyPoints},
 and @t{DOSGamma}.
@item @strong{tpa}:  Outputs transition-potential approximation (TPA) matrix elements, using \(\vec{q}\)-vector specified
 by @t{MomentumTransfer}.
@item @strong{forces}:  Outputs file @t{forces.xsf} containing structure and forces on the atoms as
 a vector associated with each atom, which can be visualized with XCrySDen.
@item @strong{wfs_fourier}:  (Experimental) Outputs wavefunctions in Fourier space. This is
 only implemented for the ETSF file format output. The file will
 be called @t{wfs-pw-etsf.nc}.
@item @strong{xc_density}:  Outputs the XC density, which is the charge density that
 generates the XC potential. (This is \(-1/4\pi\) times
 the Laplacian of the XC potential). The files are called @t{nxc}.
@item @strong{potential}:  Outputs Kohn-Sham potential, separated by parts. File names are @t{v0} for
 the local part of the ionic potential, @t{vc} for the classical potential (if it exists),
 @t{vh} for the Hartree potential, @t{vks} for the local part of the Kohn-Sham potential, and
 @t{vxc-} for the exchange-correlation potentials. For @t{vks} and @t{vxc},
 a suffix for spin is added in the spin-polarized case.
@item @strong{PES_wfs}:  Outputs the photoelectron wavefunctions. The file name is @t{pes_wfs-}
 plus the orbital number.
@item @strong{PES_density}:  Outputs the photolectron density. Output file is @t{pes_dens-} plus spin species if
 spin-polarized calculation is performed.
@item @strong{PES}:  Outputs the time-dependent photoelectron spectrum.
@item @strong{BerkeleyGW}:  Output for a run with <a href=http://www.berkeleygw.org>BerkeleyGW</a>.
 See @t{Output::BerkeleyGW} for further specification.
@item @strong{delta_perturbation}:  Outputs the "kick", or time-delta perturbation applied to compute optical response in real time.
@item @strong{external_td_potential}:  Outputs the (scalar) time-dependent potential.
@item @strong{mmb_wfs}:  Triggers the ModelMB wavefunctions to be output for each state.
@item @strong{mmb_den}:  Triggers the ModelMB density matrix to be output for each state, and the particles
 specified by the @t{DensitytoCalc} block. Calculates, and outputs, the reduced density
 matrix. For the moment the trace is made over the second dimension, and
 the code is limited to 2D. The idea is to model @emph{N} particles in 1D as an
 @emph{N}-dimensional non-interacting problem, then to trace out @emph{N}-1 coordinates.
@item @strong{potential_gradient}:  Prints the gradient of the potential.
@item @strong{energy_density}:  Outputs the total energy density to a file called
 @t{energy_density}.
@item @strong{density}:  Outputs density. The output file is called @t{density-}, or @t{lr_density-} in linear response.
@item @strong{heat_current}:  Outputs the total heat current density. The output file is
 called @t{heat_current-}.
@item @strong{photon_correlator}:  Outputs the electron-photon correlation function. The output file is
 called @t{photon_correlator}.
@item @strong{J_flow}:  todo: document J_flow option!
@item @strong{current_kpt}:  Outputs the current density resolved in momentum space. The output file is called @t{current_kpt-}.
@item @strong{density_kpt}:  Outputs the electronic density resolved in momentum space.
@item @strong{occ_matrices}:  Only for DFT+U calculations.
 Outputs the occupation matrices of LDA+U
@item @strong{effectiveU}:  Only for DFT+U calculations.
 Outputs the value of the effectiveU for each atoms
@item @strong{magnetization}:  Only for DFT+U calculations.
 Outputs file containing structure and magnetization of the localized subspace
 on the atoms as a vector associated with each atom, which can be visualized.
 For the moment, it only works if a +U is added on one type of orbital per atom.
@item @strong{local_orbitals}:  Only for DFT+U calculations.
 Outputs the localized orbitals that form the correlated subspace
@item @strong{kanamoriU}:  Only for DFT+U calculations.
 Outputs the Kanamori interaction parameters U, U`, and J.
 These parameters are not determined self-consistently, but are taken from the
 occupation matrices and Coulomb integrals comming from a standard +U calculation.
@item @strong{wfs}:  Outputs wavefunctions. Which wavefunctions are to be printed is specified
 by the variable @t{OutputWfsNumber} -- see below. The output file is called
 @t{wf-}, or @t{lr_wf-} in linear response.
@item @strong{xc_torque}:  Outputs the exchange-correlation torque. Only for the spinor case and in the 3D case.
@item @strong{eigenval_kpt}:  Outputs the eigenvalues resolved in momentum space, with one file for each band.
@item @strong{wfs_sqmod}:  Outputs modulus squared of the wavefunctions.
 The output file is called @t{sqm-wf-}. For linear response, the filename is @t{sqm_lr_wf-}.
@item @strong{geometry}:  Outputs file containing the coordinates of the atoms treated within quantum mechanics.
 If @t{OutputFormat = xyz}, the file is called @t{geometry.xyz}; a
 file @t{crystal.xyz} is written with a supercell geometry if the system is periodic;
 if point charges were defined in the PDB file (see @t{PDBCoordinates}), they will be output
 in the file @t{geometry_classical.xyz}.
 If @t{OutputFormat = xcrysden}, a file called @t{geometry.xsf} is written.
@item @strong{current}:  Outputs the total current density. The output file is called @t{current-}.
 For linear response, the filename is @t{lr_current-}.
@item @strong{ELF}:  Outputs electron localization function (ELF). The output file is called @t{elf-},
 or @t{lr_elf-} in linear response, in which case the associated function D is also written,
 as @t{lr_elf_D-}. Only in 2D and 3D.
@item @strong{ELF_basins}:  Outputs basins of attraction of the ELF. The output file is called
 @t{elf_rs_basins.info}. Only in 2D and 3D.
@item @strong{Bader}:  Outputs Laplacian of the density which shows lone pairs, bonded charge concentrations
 and regions subject to electrophilic or nucleophilic attack.
 See RF Bader, @emph{Atoms in Molecules: A Quantum Theory} (Oxford Univ. Press, Oxford, 1990).
@end itemize

@c ----------------------------------
@item @strong{OutputDuringSCF}@*
@vindex @code{OutputDuringSCF}@*
@emph{Section}: Output@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* During @t{gs} and @t{unocc} runs, if this variable is set to yes,
 output will be written after every @t{OutputInterval} iterations.



@c ----------------------------------
@item @strong{OutputFormat}@*
@vindex @code{OutputFormat}@*
@emph{Section}: Output@*
@emph{Type}: flag@*
@* Describes the format of the output files.
 This variable can also be defined inside the @t{Output} block.
 See @t{Output}.
 Example: @t{axis_x + plane_x + dx}


@emph{Options}:
@itemize @minus
@item @strong{axis_x}:  The values of the function on the @emph{x} axis are printed. The string @t{.y=0,z=0} is appended
 to previous file names.
@item @strong{axis_y}:  The values of the function on the @emph{y} axis are printed. The string @t{.x=0,z=0} is appended
 to previous file names.
@item @strong{matlab}:  In combination with @t{plane_x}, @t{plane_y} and
 @t{plane_z}, this option produces output files which are
 suitable for 2D Matlab functions like @t{mesh()},
 @t{surf()}, or @t{waterfall()}. To load these files
 into Matlab you can use, @emph{e.g.}
@t{
   >> density = load('static/density-1.x=0.matlab.abs');
   >> mesh(density);
}
@item @strong{meshgrid}:  Outputs in Matlab mode the internal mesh in a format similar to
@t{
   >> [x,y] = meshgrid(-2:.2:2,-1:.15:1)
}
 The @emph{x} meshgrid is contained in a file @t{*.meshgrid.x} and the @emph{y}-grid can be found in
 @t{*.meshgrid.y}.
@item @strong{boundary_points}:  This option includes the output of the mesh enlargement. Default is without.
 Supported only by @t{binary}, @t{axis}, @t{plane}, @t{mesh_index},
 and @t{matlab} formats.
 Not all types of @t{Output} will have this information available. Not supported when parallel in domains.
@item @strong{binary}:  Plain binary, new format.
@item @strong{etsf}:  <a href=http://www.etsf.eu/resources/software/standardization_project>ETSF file format</a>.
 Requires the ETSF_IO library. Applies only to @t{Output = density}, @t{geometry},
 @t{wfs}, and/or @t{wfs_fourier}.
@item @strong{xyz}:  Geometry will be output in XYZ format. Does not affect other outputs.
@item @strong{cube}:  Generates output in the <a href=http://paulbourke.net/dataformats/cube>cube file format</a>.
 Available only in 3D. Only writes the real part of complex functions.
 This output format always uses atomic units.
@item @strong{bild}:  Generates output in <a href=http://plato.cgl.ucsf.edu/chimera/docs/UsersGuide/bild.html>BILD format</a>.
@item @strong{axis_z}:  The values of the function on the @emph{z} axis are printed. The string @t{.x=0,y=0} is appended
 to previous file names.
@item @strong{vtk}:  Generates output in <a href=http://www.vtk.org/VTK/img/file-formats.pdf>VTK legacy format</a>.
@item @strong{integrate_xy}:  Integrates the function in the x-y plane and the result on the @emph{z} axis is printed.
@item @strong{integrate_xz}:  Integrates the function in the x-z plane and the result on the @emph{y} axis is printed
@item @strong{integrate_yz}:  Integrates the function in the y-z plane and the result on the @emph{x} axis is printed
@item @strong{ascii}:  Plain text format regardless of dimensionality. For the moment only employed by the oct-phototoelectron_spectrum
 post-processing utility.
@item @strong{plane_x}:  A plane slice at @emph{x} = 0 is printed. The string @t{.x=0} is appended
 to previous file names.
@item @strong{plane_y}:  A plane slice at @emph{y} = 0 is printed. The string @t{.y=0} is appended
 to previous file names.
@item @strong{plane_z}:  A plane slice at @emph{z} = 0 is printed. The string @t{.z=0} is appended to
 previous file names.
@item @strong{dx}:  For printing three-dimensional information, the open-source program
 visualization tool <a href=http://www.opendx.org>OpenDX</a> can be used. The string
 @t{.dx} is appended to previous file names. Available only in 3D.
@item @strong{netcdf}:  Outputs in <a href=http://www.unidata.ucar.edu/packages/netcdf>NetCDF</a> format. This file
 can then be read, for example, by OpenDX. The string @t{.ncdf} is appended to previous file names.
 Requires the NetCDF library. Only writes the real part of complex functions.
@item @strong{mesh_index}:  Generates output files of a given quantity (density, wavefunctions, ...) which include
 the internal numbering of mesh points. Since this mode produces large datafiles this is only
 useful for small meshes and debugging purposes.
 The output can also be used to display the mesh directly. A Gnuplot script for mesh visualization
 can be found under @t{PREFIX/share/octopus/util/display_mesh_index.gp}.
@item @strong{xcrysden}:  A format for printing structures and three-dimensional information, which can be visualized by
 the free open-source program <a href=http://www.xcrysden.org>XCrySDen</a> and others. The string
 @t{.xsf} is appended to previous file names. Note that lattice vectors and coordinates are as
 specified by @t{UnitsOutput}. Available in 2D and 3D.
@end itemize

@c ----------------------------------
@item @strong{OutputInterval}@*
@vindex @code{OutputInterval}@*
@emph{Section}: Output@*
@emph{Type}: integer@*
@emph{Default}: 50@*
@* The output requested by variable @t{Output} is written
 to the directory @t{OutputIterDir}
 when the iteration number is a multiple of the @t{OutputInterval} variable.
 Subdirectories are named Y.X, where Y is @t{td}, @t{scf}, or @t{unocc}, and
 X is the iteration number. To use the working directory, specify @t{"."}
 (Output of restart files is instead controlled by @t{RestartWriteInterval}.)
 Must be >= 0. If it is 0, then no output is written. For @t{gs} and @t{unocc}
 calculations, @t{OutputDuringSCF} must be set too for this output to be produced.
 This variable can also be defined inside the @t{Output} block.
 See @t{Output}.



@c ----------------------------------
@item @strong{OutputIterDir}@*
@vindex @code{OutputIterDir}@*
@emph{Section}: Output@*
@emph{Type}: string@*
@emph{Default}: "output_iter"@*
@* The name of the directory where @t{Octopus} stores information
 such as the density, forces, etc. requested by variable @t{Output}
 in the format specified by @t{OutputFormat}.
 This information is written while iterating @t{CalculationMode = gs}, @t{unocc}, or @t{td},
 according to @t{OutputInterval}, and has nothing to do with the restart information.



@c ----------------------------------
@item @strong{OutputMEEnd}@*
@vindex @code{OutputMEEnd}@*
@emph{Section}: Output@*
@emph{Type}: integer@*
@emph{Default}: 1@*
@* Specifies the highest state/band index used to compute the matrix element.
 So far, this is only used for dipole matrix elements.



@c ----------------------------------
@item @strong{OutputMEMultipoles}@*
@vindex @code{OutputMEMultipoles}@*
@emph{Section}: Output@*
@emph{Type}: integer@*
@emph{Default}: 1@*
@* This variable decides which multipole moments are printed out for
 @t{OutputMatrixElements = ks_multipoles}:

 In 3D, if, for example, @t{OutputMEMultipoles = 1}, then the program will print three
 files, @t{ks_me_multipoles.x} (@t{x}=1,2,3), containing
 respectively the (1,-1), (1,0) and (1,1) multipole matrix elements
 between Kohn-Sham states.

 In 2D, this variable is ignored: it will always print two files,
 @t{ks_me_multipoles.i} (@t{i}=1,2), containing the \(x\) and
 \(y\) dipole matrix elements.

 In 1D, if, for example, @t{OutputMEMultipoles = 2}, the program will print two files, containing the
 \(x\) and \(x^2\) matrix elements between Kohn-Sham states.



@c ----------------------------------
@item @strong{OutputMEStart}@*
@vindex @code{OutputMEStart}@*
@emph{Section}: Output@*
@emph{Type}: integer@*
@emph{Default}: 1@*
@* Specifies the state/band index for starting to compute the matrix element.
 So far, this is only used for dipole matrix elements.



@c ----------------------------------
@item @strong{OutputMatrixElements}@*
@vindex @code{OutputMatrixElements}@*
@emph{Section}: Output@*
@emph{Type}: block@*
@emph{Default}: none@*
@* Specifies what matrix elements to print.
 Enabled only if @t{Output} block includes @t{matrix_elements}.
 The output files go into the @t{static} directory, except when
 running a time-dependent simulation, when the directory @t{td.XXXXXXX} is used.

 Example:
 @t{%OutputMatrixElements
 @*@ @ momentum
 @*@ @ ks_multipoles
 @*%@*}

 It is possible to specify only compute the matrix elements for some of the states
 using the variables @t{OutptMEStart} and @t{OutputMEEnd}.


@emph{Options}:
@itemize @minus
@item @strong{momentum}:  Momentum. Filename: @t{ks_me_momentum}.
@item @strong{ang_momentum}:  Dimensionless angular momentum \(\vec{r} \times \vec{k}\). Filename: @t{ks_me_angular_momentum}.
@item @strong{one_body}:  \(\left< i \left| \hat{T} + V_{ext} \right| j \right>\). Not available with states parallelization.
@item @strong{two_body}:  \(\left< ij \left| \frac{1}{\left|\vec{r}_1-\vec{r}_2\right|} \right| kl \right>\).
 Not available with states parallelization.
 Not available with states parallelization. For periodic system, this is not available for k-point parallelization neither.
@item @strong{two_body_exc_k}:  \(\left< n1-k1, n2-k2 \left| \frac{1}{\left|\vec{r}_1-\vec{r}_2\right|} \right| n2-k1 n1-k2 \right>\).
 Not available with states parallelization. For periodic system, this is not available for k-point parallelization neither.
@item @strong{ks_multipoles}:  See @t{OutputMEMultipoles}. Not available with states parallelization.
@item @strong{dipole}:  Prints the dipole matrix elements. Not available with states parallelization.
 For periodic systems, the intraband terms (dipole matrix elements between degenerated states)
 are set to zero, and only the absolute value of the dipole matrix element is printed.
 Not yet supported for spinors.
@end itemize

@c ----------------------------------
@item @strong{OutputWfsNumber}@*
@vindex @code{OutputWfsNumber}@*
@emph{Section}: Output@*
@emph{Type}: string@*
@emph{Default}: all states@*
@* Which wavefunctions to print, in list form: @emph{i.e.}, "1-5" to print the first
 five states, "2,3" to print the second and the third state, etc.
 If more states are specified than available, extra ones will be ignored.



@c ----------------------------------
@end itemize
@node BerkeleyGW,,,
@subsection BerkeleyGW
@c ----------------------------------

@itemize
@item @strong{BerkeleyGW_CalcDipoleMtxels}@*
@vindex @code{BerkeleyGW_CalcDipoleMtxels}@*
@emph{Section}: Output::BerkeleyGW@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* Whether to calculate dipole matrix elements, to be written in @t{vmtxel}.
 This should be done when calculating @t{WFN_fi} for Bethe-Salpeter calculations
 with light polarization in a finite direction. In that case, a shifted grid
 @t{WFNq_fi} cannot be calculated, but we can instead use matrix elements of
 \(r\) in a more exact scheme. In @t{absorption.inp}, set @t{read_vmtxel}
 and @t{use_momentum}. Specify the number of conduction and valence bands you will
 use in BSE here with @t{BerkeleyGW_VmtxelNumCondBands} and @t{BerkeleyGW_VmtxelNumValBands}.



@c ----------------------------------
@item @strong{BerkeleyGW_CalcExchange}@*
@vindex @code{BerkeleyGW_CalcExchange}@*
@emph{Section}: Output::BerkeleyGW@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* Whether to calculate exchange matrix elements, to be written in @t{x.dat}.
 These will be calculated anyway by BerkeleyGW @t{Sigma}, so this is useful
 mainly for comparison and testing.



@c ----------------------------------
@item @strong{BerkeleyGW_NumberBands}@*
@vindex @code{BerkeleyGW_NumberBands}@*
@emph{Section}: Output::BerkeleyGW@*
@emph{Type}: integer@*
@emph{Default}: all states@*
@* Wavefunctions for bands up to this number will be output. Must be between <= number of states.
 If < 1, no wavefunction file will be output.



@c ----------------------------------
@item @strong{BerkeleyGW_VmtxelNumCondBands}@*
@vindex @code{BerkeleyGW_VmtxelNumCondBands}@*
@emph{Section}: Output::BerkeleyGW@*
@emph{Type}: integer@*
@* Number of conduction bands for which to calculate @t{vmtxel}, if you have set
 @t{BerkeleyGW_CalcDipoleMtxels = yes}. This should be equal to the number to be
 used in BSE.



@c ----------------------------------
@item @strong{BerkeleyGW_VmtxelNumValBands}@*
@vindex @code{BerkeleyGW_VmtxelNumValBands}@*
@emph{Section}: Output::BerkeleyGW@*
@emph{Type}: integer@*
@* Number of valence bands for which to calculate @t{vmtxel}, if you have set
 @t{BerkeleyGW_CalcDipoleMtxels = yes}. This should be equal to the number to be
 used in BSE.



@c ----------------------------------
@item @strong{BerkeleyGW_VmtxelPolarization}@*
@vindex @code{BerkeleyGW_VmtxelPolarization}@*
@emph{Section}: Output::BerkeleyGW@*
@emph{Type}: block@*
@emph{Default}: (1, 0, 0)@*
@* Polarization, @emph{i.e.} direction vector, for which to calculate @t{vmtxel}, if you have set
 @t{BerkeleyGW_CalcDipoleMtxels = yes}. May not have any component in a periodic direction.
 The vector will be normalized.



@c ----------------------------------
@item @strong{BerkeleyGW_Vxc_diag_nmax}@*
@vindex @code{BerkeleyGW_Vxc_diag_nmax}@*
@emph{Section}: Output::BerkeleyGW@*
@emph{Type}: integer@*
@emph{Default}: nst@*
@* Highest band for which to write diagonal exchange-correlation matrix elements. Must be between <= number of states.
 If < 1, diagonals will be skipped.



@c ----------------------------------
@item @strong{BerkeleyGW_Vxc_diag_nmin}@*
@vindex @code{BerkeleyGW_Vxc_diag_nmin}@*
@emph{Section}: Output::BerkeleyGW@*
@emph{Type}: integer@*
@emph{Default}: 1@*
@* Lowest band for which to write diagonal exchange-correlation matrix elements. Must be <= number of states.
 If < 1, diagonals will be skipped.



@c ----------------------------------
@item @strong{BerkeleyGW_Vxc_offdiag_nmax}@*
@vindex @code{BerkeleyGW_Vxc_offdiag_nmax}@*
@emph{Section}: Output::BerkeleyGW@*
@emph{Type}: integer@*
@emph{Default}: nst@*
@* Highest band for which to write off-diagonal exchange-correlation matrix elements. Must be <= number of states.
 If < 1, off-diagonals will be skipped.



@c ----------------------------------
@item @strong{BerkeleyGW_Vxc_offdiag_nmin}@*
@vindex @code{BerkeleyGW_Vxc_offdiag_nmin}@*
@emph{Section}: Output::BerkeleyGW@*
@emph{Type}: integer@*
@emph{Default}: 1@*
@* Lowest band for which to write off-diagonal exchange-correlation matrix elements. Must be <= number of states.
 If < 1, off-diagonals will be skipped.



@c ----------------------------------
@item @strong{BerkeleyGW_WFN_filename}@*
@vindex @code{BerkeleyGW_WFN_filename}@*
@emph{Section}: Output::BerkeleyGW@*
@emph{Type}: string@*
@emph{Default}: WFN@*
@* Filename for the wavefunctions.



@c ----------------------------------
@end itemize
@node SCF,,,
@section SCF
@c ----------------------------------

@itemize
@item @strong{SCFCalculateDipole}@*
@vindex @code{SCFCalculateDipole}@*
@emph{Section}: SCF@*
@emph{Type}: logical@*
@* This variable controls whether the dipole is calculated at the
 end of a self-consistent iteration. For finite systems the
 default is yes. For periodic systems the default is no, unless
 an electric field is being applied in a periodic direction.
 The single-point Berry`s phase approximation is used for
 periodic directions. Ref:
 E Yaschenko, L Fu, L Resca, and R Resta, @emph{Phys. Rev. B} @strong{58}, 1222-1229 (1998).



@c ----------------------------------
@item @strong{SCFCalculateForces}@*
@vindex @code{SCFCalculateForces}@*
@emph{Section}: SCF@*
@emph{Type}: logical@*
@* This variable controls whether the forces on the ions are
 calculated at the end of a self-consistent iteration. The
 default is yes, unless the system only has user-defined
 species.



@c ----------------------------------
@item @strong{SCFCalculatePartialCharges}@*
@vindex @code{SCFCalculatePartialCharges}@*
@emph{Section}: SCF@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* (Experimental) This variable controls whether partial charges
 are calculated at the end of a self-consistent iteration.



@c ----------------------------------
@item @strong{SCFCalculateStress}@*
@vindex @code{SCFCalculateStress}@*
@emph{Section}: SCF@*
@emph{Type}: logical@*
@* This variable controls whether the stress on the lattice is
 calculated at the end of a self-consistent iteration. The
 default is no.



@c ----------------------------------
@item @strong{SCFinLCAO}@*
@vindex @code{SCFinLCAO}@*
@emph{Section}: SCF@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* Performs the SCF cycle with the calculation restricted to the LCAO subspace.
 This may be useful for systems with convergence problems (first do a
 calculation within the LCAO subspace, then restart from that point for
 an unrestricted calculation).



@c ----------------------------------
@end itemize
@node Convergence,,,
@subsection Convergence
@c ----------------------------------

@itemize
@item @strong{ConvAbsDens}@*
@vindex @code{ConvAbsDens}@*
@emph{Section}: SCF::Convergence@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* Absolute convergence of the density:

 \(\varepsilon = \int {\rm d}^3r \left| \rho^{out}(\bf r) -\rho^{inp}(\bf r) \right|\).

 A zero value (the default) means do not use this criterion.

 If this criterion is used, the SCF loop will only stop once it is
 fulfilled for two consecutive iterations.



@c ----------------------------------
@item @strong{ConvAbsEv}@*
@vindex @code{ConvAbsEv}@*
@emph{Section}: SCF::Convergence@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* Absolute convergence of the sum of the eigenvalues:

 \( \varepsilon = \left| \sum_{j=1}^{N_{occ}} \varepsilon_j^{out} -
 \sum_{j=1}^{N_{occ}} \varepsilon_j^{inp} \right| \)

 A zero value (the default) means do not use this criterion.

 If this criterion is used, the SCF loop will only stop once it is
 fulfilled for two consecutive iterations.



@c ----------------------------------
@item @strong{ConvEigenError}@*
@vindex @code{ConvEigenError}@*
@emph{Section}: SCF::Convergence@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* If true, the calculation will not be considered converged unless all states have
 individual errors less than @t{EigensolverTolerance}.

 If this criterion is used, the SCF loop will only stop once it is
 fulfilled for two consecutive iterations.



@c ----------------------------------
@item @strong{ConvEnergy}@*
@vindex @code{ConvEnergy}@*
@emph{Section}: SCF::Convergence@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* Stop the SCF when the magnitude of change in energy during at
 one SCF iteration is smaller than this value.




@c ----------------------------------
@item @strong{ConvRelDens}@*
@vindex @code{ConvRelDens}@*
@emph{Section}: SCF::Convergence@*
@emph{Type}: float@*
@emph{Default}: 1e-6@*
@* Relative convergence of the density:

 \(\varepsilon = \frac{1}{N} \mathrm{ConvAbsDens}\).

 @emph{N} is the total number of electrons in the problem.  A
 zero value means do not use this criterion.

 If you reduce this value, you should also reduce
 @t{EigensolverTolerance} to a value of roughly 1/10 of
 @t{ConvRelDens} to avoid convergence problems.

 If this criterion is used, the SCF loop will only stop once it is
 fulfilled for two consecutive iterations.



@c ----------------------------------
@item @strong{ConvRelEv}@*
@vindex @code{ConvRelEv}@*
@emph{Section}: SCF::Convergence@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* Relative convergence of the sum of the eigenvalues:

 \(\varepsilon = \frac{ \left| \sum_{j=1}^{N_{occ}} ( \varepsilon_j^{out} -  \varepsilon_j^{inp} ) \right|}
 {\left| \sum_{j=1}^{N_{occ}} \varepsilon_j^{out} \right|} \)




@c ----------------------------------
@item @strong{MaximumIter}@*
@vindex @code{MaximumIter}@*
@emph{Section}: SCF::Convergence@*
@emph{Type}: integer@*
@emph{Default}: 200@*
@* Maximum number of SCF iterations. The code will stop even if convergence
 has not been achieved. -1 means unlimited.
 0 means just do LCAO (or read from restart), compute the eigenvalues and energy,
 and stop, without updating the wavefunctions or density.

 If convergence criteria are set, the SCF loop will only stop once the criteria
 are fulfilled for two consecutive iterations.

 Note that this variable is also used in the section Calculation Modes::Unoccupied States,
 where it denotes the maximum number of calls of the eigensolver. In this context, the
 default value is 50.



@c ----------------------------------
@item @strong{MaximumIterBerry}@*
@vindex @code{MaximumIterBerry}@*
@emph{Section}: SCF::Convergence@*
@emph{Type}: integer@*
@emph{Default}: 10@*
@* Maximum number of iterations for the Berry potential, within each SCF iteration.
 Only applies if a @t{StaticElectricField} is applied in a periodic direction.
 The code will move on to the next SCF iteration even if convergence
 has not been achieved. -1 means unlimited.



@c ----------------------------------
@end itemize
@node Eigensolver,,,
@subsection Eigensolver
@c ----------------------------------

@itemize
@item @strong{CGAdditionalTerms}@*
@vindex @code{CGAdditionalTerms}@*
@emph{Section}: SCF::Eigensolver@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* Used by the cg solver only.
 Add additional terms during the line minimization, see PTA92, eq. 5.31ff.
 These terms can improve convergence for some systems, but they are quite costly.
 If you experience convergence problems, you might try out this option.
 This feature is still experimental.



@c ----------------------------------
@item @strong{CGDirection}@*
@vindex @code{CGDirection}@*
@emph{Section}: SCF::Eigensolver@*
@emph{Type}: integer@*
@* Used by the cg solver only.
 The conjugate direction is updated using a certain coefficient to the previous
 direction. This coeffiction can be computed in different ways. The default is
 to use Fletcher-Reeves (FR), an alternative is Polak-Ribiere (PR).


@emph{Options}:
@itemize @minus
@item @strong{fletcher}:  The coefficient for Fletcher-Reeves consists of the current norm of the
 steepest descent vector divided by that of the previous iteration.
@item @strong{polak}:  For the Polak-Ribiere scheme, a product of the current with the previous
 steepest descent vector is subtracted in the nominator.
@end itemize

@c ----------------------------------
@item @strong{CGEnergyChangeThreshold}@*
@vindex @code{CGEnergyChangeThreshold}@*
@emph{Section}: SCF::Eigensolver@*
@emph{Type}: float@*
@emph{Default}: 0.1@*
@* Used by the cg solver only.
 For each band, the CG iterations are stopped when the change in energy is smaller than the
 change in the first iteration multiplied by this factor. This limits the number of CG
 iterations for each band, while still showing good convergence for the SCF cycle. The criterion
 is discussed in Sec. V.B.6 of Payne et al. (1992), Rev. Mod. Phys. 64, 4.
 The default value is 0.1, which is usually a good choice for LDA and GGA potentials. If you
 are solving the OEP equation, you might want to set this value to 1e-3 or smaller. In general,
 smaller values might help if you experience convergence problems.
 For very small convergence tolerances, choose 0 to disable this criterion.



@c ----------------------------------
@item @strong{CGOrthogonalizeAll}@*
@vindex @code{CGOrthogonalizeAll}@*
@emph{Section}: SCF::Eigensolver@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* Used by the cg solver only.
 During the cg iterations, the current band can be orthogonalized
 against all other bands or only against the lower bands. Orthogonalizing
 against all other bands can improve convergence properties, whereas
 orthogonalizing against lower bands needs less operations.
 Moreover, orthogonalizing against all bands can make converging
 the highest band or unoccupied bands more difficult.



@c ----------------------------------
@item @strong{Eigensolver}@*
@vindex @code{Eigensolver}@*
@emph{Section}: SCF::Eigensolver@*
@emph{Type}: integer@*
@* Which eigensolver to use to obtain the lowest eigenvalues and
 eigenfunctions of the Kohn-Sham Hamiltonian. The default is
 conjugate gradients (@t{cg}), except that when parallelization in states is
 enabled, the default is @t{rmmdiis}.


@emph{Options}:
@itemize @minus
@item @strong{rmmdiis}:  Residual minimization scheme, direct inversion in the
 iterative subspace eigensolver, based on the implementation of
 Kresse and Furthm&uuml;ller [@emph{Phys. Rev. B} @strong{54}, 11169
 (1996)]. This eigensolver requires almost no orthogonalization
 so it can be considerably faster than the other options for
 large systems. To improve its performance a large number of @t{ExtraStates}
 are required (around 10-20% of the number of occupied states).
 Note: with @t{unocc}, you will need to stop the calculation
 by hand, since the highest states will probably never converge.
 Usage with more than one block of states per node is experimental, unfortunately.
@item @strong{plan}:  Preconditioned Lanczos scheme. Ref: Y. Saad, A. Stathopoulos, J. Chelikowsky, K. Wu and S. Ogut,
 "Solution of Large Eigenvalue Problems in Electronic Structure Calculations", @emph{BIT} @strong{36}, 1 (1996).
@item @strong{cg}:  Conjugate-gradients algorithm.
@item @strong{cg_new}:  An alternative conjugate-gradients eigensolver, faster for
 larger systems but less mature.
 Ref: Jiang et al., @emph{Phys. Rev. B} @strong{68}, 165337 (2003)
@item @strong{evolution}:  (Experimental) Propagation in imaginary time.
@end itemize

@c ----------------------------------
@item @strong{EigensolverImaginaryTime}@*
@vindex @code{EigensolverImaginaryTime}@*
@emph{Section}: SCF::Eigensolver@*
@emph{Type}: float@*
@emph{Default}: 0.1@*
@* The imaginary-time step that is used in the imaginary-time evolution
 method (@t{Eigensolver = evolution}) to obtain the lowest eigenvalues/eigenvectors.
 It must satisfy @t{EigensolverImaginaryTime > 0}.
 Increasing this value can make the propagation faster, but could lead to unstable propagations.



@c ----------------------------------
@item @strong{EigensolverMaxIter}@*
@vindex @code{EigensolverMaxIter}@*
@emph{Section}: SCF::Eigensolver@*
@emph{Type}: integer@*
@* Determines the maximum number of iterations that the
 eigensolver will perform if the desired tolerance is not
 achieved. The default is 25 iterations for all eigensolvers
 except for @t{rmdiis}, which performs only 5 iterations.
 Increasing this value for @t{rmdiis} increases the convergence speed,
 at the cost of an increased memory footprint.

 In the case of imaginary time propatation, this variable controls the number of iterations
 for which the Hxc potential is frozen. Default is 1 for the imaginary time evolution.



@c ----------------------------------
@item @strong{EigensolverMinimizationIter}@*
@vindex @code{EigensolverMinimizationIter}@*
@emph{Section}: SCF::Eigensolver@*
@emph{Type}: integer@*
@* During the first iterations, the RMMDIIS eigensolver requires
 some steepest-descent minimizations to improve
 convergence. This variable determines the number of those
 minimizations.



@c ----------------------------------
@item @strong{EigensolverTolerance}@*
@vindex @code{EigensolverTolerance}@*
@emph{Section}: SCF::Eigensolver@*
@emph{Type}: float@*
@* This is the tolerance for the eigenvectors. The default is 1e-7.



@c ----------------------------------
@item @strong{Preconditioner}@*
@vindex @code{Preconditioner}@*
@emph{Section}: SCF::Eigensolver@*
@emph{Type}: integer@*
@* Which preconditioner to use in order to solve the Kohn-Sham
 equations or the linear-response equations. The default is
 pre_filter, except for curvilinear coordinates, where no
 preconditioner is applied by default.


@emph{Options}:
@itemize @minus
@item @strong{no}:  Do not apply preconditioner.
@item @strong{pre_filter}:  Filter preconditioner.
@item @strong{pre_jacobi}:  Jacobi preconditioner. Only the local part of the pseudopotential is used.
 Not very helpful.
@item @strong{pre_poisson}:  Uses the full Laplacian as preconditioner. The inverse is calculated through
 the solution of the Poisson equation. This is, of course, very slow.
@item @strong{pre_multigrid}:  Multigrid preconditioner.
@end itemize

@c ----------------------------------
@item @strong{PreconditionerFilterFactor}@*
@vindex @code{PreconditionerFilterFactor}@*
@emph{Section}: SCF::Eigensolver@*
@emph{Type}: float@*
@* This variable controls how much filter preconditioner is
 applied. A value of 1.0 means no preconditioning, 0.5 is the
 standard.

 The default is 0.5, except for periodic systems where the
 default is 0.6.

 If you observe that the first eigenvectors are not converging
 properly, especially for periodic systems, you should
 increment this value.

 The allowed range for this parameter is between 0.5 and 1.0.
 For other values, the SCF may converge to wrong results.



@c ----------------------------------
@item @strong{PreconditionerIterationsMiddle}@*
@vindex @code{PreconditionerIterationsMiddle}@*
@emph{Section}: SCF::Eigensolver@*
@emph{Type}: integer@*
@* This variable is the number of smoothing iterations on the coarsest grid for the multigrid
 preconditioner. The default is 1.



@c ----------------------------------
@item @strong{PreconditionerIterationsPost}@*
@vindex @code{PreconditionerIterationsPost}@*
@emph{Section}: SCF::Eigensolver@*
@emph{Type}: integer@*
@* This variable is the number of post-smoothing iterations for the multigrid
 preconditioner. The default is 2.



@c ----------------------------------
@item @strong{PreconditionerIterationsPre}@*
@vindex @code{PreconditionerIterationsPre}@*
@emph{Section}: SCF::Eigensolver@*
@emph{Type}: integer@*
@* This variable is the number of pre-smoothing iterations for the multigrid
 preconditioner. The default is 1.



@c ----------------------------------
@item @strong{StatesOrthogonalization}@*
@vindex @code{StatesOrthogonalization}@*
@emph{Section}: SCF::Eigensolver@*
@emph{Type}: integer@*
@* The full orthogonalization method used by some
 eigensolvers. The default is @t{cholesky_serial}, except with state
 parallelization, the default is @t{cholesky_parallel}.


@emph{Options}:
@itemize @minus
@item @strong{cholesky_serial}:  Cholesky decomposition implemented using
 BLAS/LAPACK. Can be used with domain parallelization but not
 state parallelization.
@item @strong{cholesky_parallel}:  Cholesky decomposition implemented using
 ScaLAPACK. Compatible with states parallelization.
@item @strong{cgs}:  Classical Gram-Schmidt (CGS) orthogonalization.
 Can be used with domain parallelization but not state parallelization.
 The algorithm is defined in Giraud et al., Computers and Mathematics with Applications 50, 1069 (2005).
@item @strong{mgs}:  Modified Gram-Schmidt (MGS) orthogonalization.
 Can be used with domain parallelization but not state parallelization.
 The algorithm is defined in Giraud et al., Computers and Mathematics with Applications 50, 1069 (2005).
@item @strong{drcgs}:  Classical Gram-Schmidt orthogonalization with double-step reorthogonalization.
 Can be used with domain parallelization but not state parallelization.
 The algorithm is taken from Giraud et al., Computers and Mathematics with Applications 50, 1069 (2005).
 According to this reference, this is much more precise than CGS or MGS algorithms. The MGS version seems not to improve much the stability and would require more communications over the domains.
@end itemize

@c ----------------------------------
@item @strong{SubspaceDiagonalization}@*
@vindex @code{SubspaceDiagonalization}@*
@emph{Section}: SCF::Eigensolver@*
@emph{Type}: integer@*
@emph{Default}: standard@*
@* Selects the method to perform subspace diagonalization. The
 default is @t{standard}, unless states parallelization is used,
 when the default is @t{scalapack}.
 Note that this variable is not parsed in the case of the evolution eigensolver.


@emph{Options}:
@itemize @minus
@item @strong{none}:  No subspace diagonalization. WARNING: this will generally give incorrect results.
@item @strong{standard}:  The standard routine. Can be used with domain parallelization but not
 state parallelization.
@item @strong{scalapack}:  State-parallelized version using ScaLAPACK. (Requires that
 Octopus was compiled with ScaLAPACK support.)
@end itemize

@c ----------------------------------
@end itemize
@node LCAO,,,
@subsection LCAO
@c ----------------------------------

@itemize
@item @strong{AtomsMagnetDirection}@*
@vindex @code{AtomsMagnetDirection}@*
@emph{Section}: SCF::LCAO@*
@emph{Type}: block@*
@* This option is only used when @t{GuessMagnetDensity} is
 set to @t{user_defined}. It provides a direction for the
 magnetization vector of each atom when building the guess
 density. In order to do that, the user should specify the
 coordinates of a vector that has the desired direction and
 norm.  Note that it is necessary to maintain the ordering in
 which the species were defined in the coordinates
 specifications.

 For spin-polarized calculations, the vectors should have only
 one component; for non-collinear-spin calculations, they
 should have three components. If the norm of the vector is greater
 than the number of valence electrons in the atom, it will be rescaled
 to this number, which is the maximum possible magnetization.



@c ----------------------------------
@item @strong{GuessMagnetDensity}@*
@vindex @code{GuessMagnetDensity}@*
@emph{Section}: SCF::LCAO@*
@emph{Type}: integer@*
@emph{Default}: ferromagnetic@*
@* The guess density for the SCF cycle is just the sum of all the atomic densities.
 When performing spin-polarized or non-collinear-spin calculations this option sets
 the guess magnetization density.

 For anti-ferromagnetic configurations, the @t{user_defined} option should be used.

 Note that if the @t{paramagnetic} option is used, the final ground state will also be
 paramagnetic, but the same is not true for the other options.


@emph{Options}:
@itemize @minus
@item @strong{paramagnetic}:  Magnetization density is zero.
@item @strong{ferromagnetic}:  Magnetization density is the sum of the atomic magnetization densities.
@item @strong{random}:  Each atomic magnetization density is randomly rotated.
@item @strong{user_defined}:  The atomic magnetization densities are rotated so that the magnetization
 vector has the same direction as a vector provided by the user. In this case,
 the @t{AtomsMagnetDirection} block has to be set.
@end itemize

@c ----------------------------------
@item @strong{LCAOAlternative}@*
@vindex @code{LCAOAlternative}@*
@emph{Section}: SCF::LCAO@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* If this variable is set, the LCAO procedure will use an
 alternative (and experimental) implementation. It is faster for
 large systems and parallel in states. It is not working for spinors, however.



@c ----------------------------------
@item @strong{LCAOComplexYlms}@*
@vindex @code{LCAOComplexYlms}@*
@emph{Section}: SCF::LCAO@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* If set to true, and using complex states, complex spherical harmonics will be used, @emph{i.e.}
 with \(e^{\pm i m \phi}\).
 If false, real spherical harmonics with \(\sin(m \phi)\) or \(\cos(m \phi)\) are used.
 This variable will make it more likely to get states that are eigenvectors of the \(L_z\)
 operator, with a definite angular momentum.



@c ----------------------------------
@item @strong{LCAODiagTol}@*
@vindex @code{LCAODiagTol}@*
@emph{Section}: SCF::LCAO@*
@emph{Type}: float@*
@emph{Default}: 1e-10@*
@* Only applies if @t{LCAOAlternative = true}.
 The tolerance for the diagonalization of the LCAO Hamiltonian.



@c ----------------------------------
@item @strong{LCAODimension}@*
@vindex @code{LCAODimension}@*
@emph{Section}: SCF::LCAO@*
@emph{Type}: integer@*
@* (Only applies if @t{LCAOAlternative = no}.)
 Before starting the SCF cycle, an initial LCAO calculation can be performed
 in order to obtain reasonable initial guesses for spin-orbitals and densities.
 For this purpose, the code calculates a number of atomic orbitals.
 The number available for a species described by a pseudopotential is all the
 orbitals up the maximum angular momentum in the pseudopotential, minus any orbitals that
 are found to be unbound. For non-pseudopotential species, the number is equal to
 twice the valence charge.
 The default dimension for the LCAO basis
 set will be the sum of all these numbers, or twice the number of required orbitals
 for the full calculation, whichever is less.

 This dimension however can be changed by making use of this
 variable. Note that @t{LCAODimension} cannot be smaller than the
 number of orbitals needed in the full calculation -- if
 @t{LCAODimension} is smaller, it will be silently increased to meet
 this requirement. In the same way, if @t{LCAODimension} is larger
 than the available number of atomic orbitals, it will be
 reduced. If you want to use the largest possible number, set
 @t{LCAODimension} to a negative number.



@c ----------------------------------
@item @strong{LCAOExtraOrbitals}@*
@vindex @code{LCAOExtraOrbitals}@*
@emph{Section}: SCF::LCAO@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* Only applies if @t{LCAOAlternative = true}, and all species are pseudopotentials.
 (experimental) If this variable is set to yes, the LCAO
 procedure will add an extra set of numerical orbitals (by
 using the derivative of the radial part of the original
 orbitals). Note that this corresponds roughly to adding orbitals
 with higher principal quantum numbers, but the same angular momentum.
 This option may cause problems for unoccupied states since you may miss
 some lower-lying states which correspond to higher angular momenta instead
 of higher principal quantum number.



@c ----------------------------------
@item @strong{LCAOKeepOrbitals}@*
@vindex @code{LCAOKeepOrbitals}@*
@emph{Section}: SCF::LCAO@*
@emph{Type}: logical@*
@emph{Default}: yes@*
@* Only applies if @t{LCAOAlternative = true}.
 If set to yes (the default) Octopus keeps atomic orbitals in
 memory during the LCAO procedure. If set to no, the orbitals
 are generated each time that they are needed, increasing
 computational time but saving memory.

 When set to yes, Octopus prints the amount of memory per node
 that is required to store the orbitals.




@c ----------------------------------
@item @strong{LCAOMaximumOrbitalRadius}@*
@vindex @code{LCAOMaximumOrbitalRadius}@*
@emph{Section}: SCF::LCAO@*
@emph{Type}: float@*
@emph{Default}: 20.0 a.u.@*
@* The LCAO procedure will ignore orbitals that have an
 extent greater that this value.



@c ----------------------------------
@item @strong{LCAOScaleFactor}@*
@vindex @code{LCAOScaleFactor}@*
@emph{Section}: SCF::LCAO@*
@emph{Type}: float@*
@emph{Default}: 1.0@*
@* The coordinates of the atomic orbitals used by the LCAO
 procedure will be rescaled by the value of this variable. 1.0 means no rescaling.



@c ----------------------------------
@item @strong{LCAOStart}@*
@vindex @code{LCAOStart}@*
@emph{Section}: SCF::LCAO@*
@emph{Type}: integer@*
@* Before starting a SCF calculation, @t{Octopus} can perform
 a linear combination of atomic orbitals (LCAO) calculation.
 These can provide @t{Octopus} with a good set
 of initial wavefunctions and with a new guess for the density.
 (Up to the current version, only a minimal basis set is used.)
 The default is @t{lcao_states} if at least one species representing an atom is present.
 The default is @t{lcao_none} if all species are @t{species_user_defined},
 @t{species_charge_density}, @t{species_from_file}, or @t{species_jellium_slab}.

 The initial guess densities for LCAO are taken from the atomic orbitals for pseudopotential species;
 from the natural charge density for @t{species_charge_density}, @t{species_point},
 @t{species_jellium}, and @t{species_jellium_slab};
 or uniform for @t{species_full_delta}, @t{species_full_gaussian},
 @t{species_user_defined}, or @t{species_from_file}.
 Pseudopotential species use the pseudo-wavefunctions as orbitals, full-potential atomic species
 (@t{species_full_delta} and @t{species_full_gaussian}) use hydrogenic wavefunctions, and
 others use harmonic-oscillator wavefunctions.

 Note: Some pseudopotential files (CPI, FHI for example) do not
 contain full information about the orbitals. In this case,
 Octopus generates the starting density from the normalized
 square root of the local potential. If no orbitals are
 available at all from the pseudopotential files, Octopus will
 not be able to perform an LCAO and the initial states will be
 randomized.



@emph{Options}:
@itemize @minus
@item @strong{lcao_none}:  Do not perform a LCAO calculation before the SCF cycle. Instead use random wavefunctions.
@item @strong{lcao_states}:  Do a LCAO calculation before the SCF cycle and use the resulting wavefunctions as
 initial wavefunctions without changing the guess density.
 This will speed up the convergence of the eigensolver during the first SCF iterations.
@item @strong{lcao_full}:  Do a LCAO calculation before the SCF cycle and use the LCAO wavefunctions to build a new
 guess density and a new KS potential.
 Using the LCAO density as a new guess density may improve the convergence, but can
 also slow it down or yield wrong results (especially for spin-polarized calculations).
@end itemize

@c ----------------------------------
@end itemize
@node Mixing,,,
@subsection Mixing
@c ----------------------------------

@itemize
@item @strong{MixField}@*
@vindex @code{MixField}@*
@emph{Section}: SCF::Mixing@*
@emph{Type}: integer@*
@* Selects what should be mixed during the SCF cycle.  Note that
 currently the exact-exchange part of hybrid functionals is not
 mixed at all, which would require wavefunction-mixing, not yet
 implemented. This may lead to instabilities in the SCF cycle,
 so starting from a converged LDA/GGA calculation is recommended
 for hybrid functionals. The default depends on the @t{TheoryLevel}
 and the exchange-correlation potential used.


@emph{Options}:
@itemize @minus
@item @strong{none}:  No mixing is done. This is the default for independent
 particles.
@item @strong{potential}:  The Kohn-Sham potential is mixed. This is the default for other cases.
@item @strong{density}:  Mix the density.
@item @strong{states}:  (Experimental) Mix the states. In this case, the mixing is always linear.
@end itemize

@c ----------------------------------
@item @strong{MixInterval}@*
@vindex @code{MixInterval}@*
@emph{Section}: SCF::Mixing@*
@emph{Type}: integer@*
@emph{Default}: 1@*
@* When this variable is set to a value different than 1 (the
 default) a combined mixing scheme will be used, with MixInterval
 - 1 steps of linear mixing followed by 1 step of the selected
 mixing. For the moment this variable only works with DIIS mixing.



@c ----------------------------------
@item @strong{MixNumberSteps}@*
@vindex @code{MixNumberSteps}@*
@emph{Section}: SCF::Mixing@*
@emph{Type}: integer@*
@emph{Default}: 4@*
@* In the Broyden and Bowler_Gillan schemes, the new input density or potential is constructed
 from the values of the densities/potentials of a given number of previous iterations.
 This number is set by this variable. Must be greater than 1.



@c ----------------------------------
@item @strong{Mixing}@*
@vindex @code{Mixing}@*
@emph{Section}: SCF::Mixing@*
@emph{Type}: float@*
@emph{Default}: 0.3@*
@* The linear, Broyden and DIIS scheme depend on a "mixing parameter", set by this variable.
 Must be 0 < @t{Mixing} <= 1.



@c ----------------------------------
@item @strong{MixingPreconditioner}@*
@vindex @code{MixingPreconditioner}@*
@emph{Section}: SCF::Mixing@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* (Experimental) If set to yes, Octopus will use a preconditioner
 for the mixing operator.
 This preconditioner is disabled for systems with dimension other than 3.



@c ----------------------------------
@item @strong{MixingResidual}@*
@vindex @code{MixingResidual}@*
@emph{Section}: SCF::Mixing@*
@emph{Type}: float@*
@emph{Default}: 0.05@*
@* In the DIIS mixing it is benefitial to include a bit of
 residual into the mixing. This parameter controls this amount.



@c ----------------------------------
@item @strong{MixingRestart}@*
@vindex @code{MixingRestart}@*
@emph{Section}: SCF::Mixing@*
@emph{Type}: integer@*
@emph{Default}: 20@*
@* In the Broyden and Bowler_Gillan schemes, the mixing is restarted after
 the number of iterations given by this variable.
 Set this to zero to disable restarting the mixing.



@c ----------------------------------
@item @strong{MixingScheme}@*
@vindex @code{MixingScheme}@*
@emph{Section}: SCF::Mixing@*
@emph{Type}: integer@*
@emph{Default}: broyden@*
@* The scheme used to produce, at each iteration in the self-consistent cycle
 that attempts to solve the Kohn-Sham equations, the input density from the value
 of the input and output densities of previous iterations.


@emph{Options}:
@itemize @minus
@item @strong{linear}:  Simple linear mixing.
@item @strong{bowler_gillan}:  The Guaranteed-reduction modification of the Pulay scheme by
 Bowler and Gillan [D. R. Bowler and M. J. Gillan,
 @emph{Chem. Phys.  Lett.} @strong{325}, 473 (2000)].
@item @strong{broyden}:  Broyden scheme [C. G Broyden, @emph{Math. Comp.} @strong{19}, 577 (1965);
 D. D. Johnson, @emph{Phys. Rev. B} @strong{38}, 12807 (1988)].
 The scheme is slightly adapted, see the comments in the code.
 For complex functions (e.g. Sternheimer with @t{EMEta} > 0), we use the generalization
 with a complex dot product.
@item @strong{diis}:  Direct inversion in the iterative subspace (diis)
 scheme [P. Pulay, @emph{Chem. Phys. Lett.}, @strong{73}, 393
 (1980)] as described in [G. Kresse, and J. Hurthmueller,
 @emph{Phys. Rev. B} @strong{54}, 11169 (1996)].
@end itemize

@c ----------------------------------
@end itemize
@node RDMFT,,,
@subsection RDMFT
@c ----------------------------------

@itemize
@item @strong{RDMBasis}@*
@vindex @code{RDMBasis}@*
@emph{Section}: SCF::RDMFT@*
@emph{Type}: logical@*
@emph{Default}: yes@*
@* If true, all the energy terms and corresponding derivatives involved in RDMFT will
 not be calculated on the grid but on the basis of the initial orbitals



@c ----------------------------------
@item @strong{RDMConvEner}@*
@vindex @code{RDMConvEner}@*
@emph{Section}: SCF::RDMFT@*
@emph{Type}: float@*
@emph{Default}: 1e-6 Ha@*
@* Convergence criterion for stopping the overall minimization of the energy with
 respect to occupation numbers and the orbitals. The minimization of the
 energy stops when the total energy difference between two subsequent
 minimizations of the energy with respect to the occupation numbers and the
 orbitals is smaller than this criterion. It is also used to exit the orbital minimization.



@c ----------------------------------
@item @strong{RDMHartreeFock}@*
@vindex @code{RDMHartreeFock}@*
@emph{Section}: SCF::RDMFT@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* If true, the code simulates a HF calculation, by omitting the occ.num. optimization
 can be used for test reasons



@c ----------------------------------
@item @strong{RDMTolerance}@*
@vindex @code{RDMTolerance}@*
@emph{Section}: SCF::RDMFT@*
@emph{Type}: float@*
@emph{Default}: 1e-7 Ha@*
@* Convergence criterion for stopping the occupation numbers minimization. Minimization is
 stopped when all derivatives of the energy wrt. each occupation number
 are smaller than this criterion. The bisection for finding the correct mu that is needed
 for the occupation number minimization also stops according to this criterion.



@c ----------------------------------
@item @strong{RDMToleranceFO}@*
@vindex @code{RDMToleranceFO}@*
@emph{Section}: SCF::RDMFT@*
@emph{Type}: float@*
@emph{Default}: 1e-4 Ha@*
@* Convergence criterion for stopping the diagonalization of the Fock matrix in the Piris method.
 Orbital minimization is stopped when all off-diagonal ellements of the Fock matrix
 are smaller than this criterion.



@c ----------------------------------
@end itemize
@node States,,,
@section States
@c ----------------------------------

@itemize
@item @strong{DegeneracyThreshold}@*
@vindex @code{DegeneracyThreshold}@*
@emph{Section}: States@*
@emph{Type}: float@*
@emph{Default}: 1e-5@*
@* States with energy \(E_i\) and \(E_j\) will be considered degenerate
 if \( \left| E_i - E_j \right| < \)@t{DegeneracyThreshold}.



@c ----------------------------------
@item @strong{ExcessCharge}@*
@vindex @code{ExcessCharge}@*
@emph{Section}: States@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* The net charge of the system. A negative value means that we are adding
 electrons, while a positive value means we are taking electrons
 from the system.



@c ----------------------------------
@item @strong{ExtraStates}@*
@vindex @code{ExtraStates}@*
@emph{Section}: States@*
@emph{Type}: integer@*
@* The number of states is in principle calculated considering the minimum
 numbers of states necessary to hold the electrons present in the system.
 The number of electrons is
 in turn calculated considering the nature of the species supplied in the
 @t{Species} block, and the value of the @t{ExcessCharge} variable.
 However, one may command @t{Octopus} to use more states, which is necessary if one wants to
 use fractional occupational numbers, either fixed from the beginning through
 the @t{Occupations} block or by prescribing
 an electronic temperature with @t{Smearing}, or in order to calculate
 excited states (including with @t{CalculationMode = unocc}).



@c ----------------------------------
@item @strong{ExtraStatesToConverge}@*
@vindex @code{ExtraStatesToConverge}@*
@emph{Section}: States@*
@emph{Type}: integer@*
@* Only for unocc calculations.
 Specifies the number of extra states that will be considered for reaching the convergence.
 Together with @t{ExtraStates}, one can have some more states which will not be
 considered for the convergence criteria, thus making the convergence of the
 unocc calculation faster.
 By default, all extra states need to be converged.



@c ----------------------------------
@item @strong{InitialSpins}@*
@vindex @code{InitialSpins}@*
@emph{Section}: States@*
@emph{Type}: block@*
@* The spin character of the initial random guesses for the spinors can
 be fixed by making use of this block. Note that this will not "fix" the
 the spins during the calculation (this cannot be done in spinors mode, in
 being able to change the spins is why the spinors mode exists in the first
 place).

 This block is meaningless and ignored if the run is not in spinors mode
 (@t{SpinComponents = spinors}).

 The structure of the block is very simple: each column contains the desired
 \(\left< S_x \right>, \left< S_y \right>, \left< S_z \right> \) for each spinor.
 If the calculation is for a periodic system
 and there is more than one @emph{k}-point, the spins of all the @emph{k}-points are
 the same.

 For example, if we have two spinors, and we want one in the \(S_x\) "down" state,
 and another one in the \(S_x\) "up" state:

 @t{%InitialSpins
 @*@ @ @  0.5 | 0.0 | 0.0
 @*@ @  -0.5 | 0.0 | 0.0
 @*%}

 WARNING: if the calculation is for a system described by pseudopotentials (as
 opposed to user-defined potentials or model systems), this option is
 meaningless since the random spinors are overwritten by the atomic orbitals.

 This constraint must be fulfilled:
 @*\( \left< S_x \right>^2 + \left< S_y \right>^2 + \left< S_z \right>^2 = \frac{1}{4} \)



@c ----------------------------------
@item @strong{MaxwellPlaneWavesInBox}@*
@vindex @code{MaxwellPlaneWavesInBox}@*
@emph{Section}: States@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* Analytic evaluation of the incoming waves inside the box,
 not doing any numerical propagation of Maxwells equations.



@c ----------------------------------
@item @strong{Occupations}@*
@vindex @code{Occupations}@*
@emph{Section}: States@*
@emph{Type}: block@*
@* The occupation numbers of the orbitals can be fixed through the use of this
 variable. For example:

 @t{%Occupations
 @*@ @ 2 | 2 | 2 | 2 | 2
 @*%}

 would fix the occupations of the five states to 2. There can be
 at most as many columns as states in the calculation. If there are fewer columns
 than states, then the code will assume that the user is indicating the occupations
 of the uppermost states where all lower states have full occupation (i.e. 2 for spin-unpolarized
 calculations, 1 otherwise) and all higher states have zero occupation. The first column
 will be taken to refer to the lowest state such that the occupations would be consistent
 with the correct total charge. For example, if there are 8 electrons and 10 states (from
 @t{ExtraStates = 6}), then an abbreviated specification

 @t{%Occupations
 @*@ @ 1 | 0 | 1
 @*%}

 would be equivalent to a full specification

 @t{%Occupations
 @*@ @ 2 | 2 | 2 | 1 | 0 | 1 | 0 | 0 | 0 | 0
 @*%}

 This is an example of use for constrained density-functional theory,
 crudely emulating a HOMO->LUMO+1 optical excitation.
 The number of rows should be equal
 to the number of k-points times the number of spins. For example, for a finite system
 with @t{SpinComponents == spin_polarized},
 this block should contain two lines, one for each spin channel.
 All rows must have the same number of columns.

 The @t{Occupations} block is useful for the ground state of highly symmetric
 small systems (like an open-shell atom), to fix the occupation numbers
 of degenerate states in order to help @t{octopus} to converge. This is to
 be used in conjuction with @t{ExtraStates}. For example, to calculate the
 carbon atom, one would do:

 @t{ExtraStates = 2
 @*%Occupations
 @*@ @ 2 | 2/3 | 2/3 | 2/3
 @*%}

 If you want the calculation to be spin-polarized (which makes more sense), you could do:

 @t{ExtraStates = 2
 @*%Occupations
 @*@ @  2/3 | 2/3 | 2/3
 @*@ @  0   |   0 |   0
 @*%}

 Note that in this case the first state is absent, the code will calculate four states
 (two because there are four electrons, plus two because @t{ExtraStates} = 2), and since
 it finds only three columns, it will occupy the first state with one electron for each
 of the spin options.

 If the sum of occupations is not equal to the total charge set by @t{ExcessCharge},
 an error message is printed.
 If @t{FromScratch = no} and @t{RestartFixedOccupations = yes},
 this block will be ignored.



@c ----------------------------------
@item @strong{OnlyUserDefinedInitialStates}@*
@vindex @code{OnlyUserDefinedInitialStates}@*
@emph{Section}: States@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* If true, then only user-defined states from the block @t{UserDefinedStates}
 will be used as initial states for a time-propagation. No attempt is made
 to load ground-state orbitals from a previous ground-state run.



@c ----------------------------------
@item @strong{RestartFixedOccupations}@*
@vindex @code{RestartFixedOccupations}@*
@emph{Section}: States@*
@emph{Type}: logical@*
@emph{Default}: yes@*
@* Setting this variable will make the restart proceed as
 if the occupations from the previous calculation had been set via the @t{Occupations} block,
 @emph{i.e.} fixed. Otherwise, occupations will be determined by smearing.



@c ----------------------------------
@item @strong{RestartReorderOccs}@*
@vindex @code{RestartReorderOccs}@*
@emph{Section}: States@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* Consider doing a ground-state calculation, and then restarting with new occupations set
 with the @t{Occupations} block, in an attempt to populate the orbitals of the original
 calculation. However, the eigenvalues may reorder as the density changes, in which case the
 occupations will now be referring to different orbitals. Setting this variable to yes will
 try to solve this issue when the restart data is being read, by reordering the occupations
 according to the order of the expectation values of the restart wavefunctions.



@c ----------------------------------
@item @strong{Smearing}@*
@vindex @code{Smearing}@*
@emph{Section}: States@*
@emph{Type}: float@*
@emph{Default}: 0.1 eV@*
@* If @t{Occupations} is not set, @t{Smearing} is the
 smearing width used in the @t{SmearingFunction} to distribute the electrons
 among the existing states.



@c ----------------------------------
@item @strong{SmearingFunction}@*
@vindex @code{SmearingFunction}@*
@emph{Section}: States@*
@emph{Type}: integer@*
@emph{Default}: semiconducting@*
@* This is the function used to smear the electronic occupations.
 It is ignored if the @t{Occupations} block is set.


@emph{Options}:
@itemize @minus
@item @strong{semiconducting}:  Semiconducting occupations, @emph{i.e.} the lowest lying states are occupied
 until no more electrons are left.
@item @strong{fermi_dirac}:  Simple Fermi-Dirac distribution. In this case, @t{Smearing} has
 the meaning of an electronic temperature. DN Mermin, @emph{Phys. Rev.} @strong{137}, A1441 (1965).
@item @strong{cold_smearing}:  N Marzari, D Vanderbilt, A De Vita, and MC Payne, @emph{Phys. Rev. Lett.} @strong{82}, 3296 (1999).
@item @strong{methfessel_paxton}:  M Methfessel and AT Paxton, @emph{Phys. Rev. B} @strong{40}, 3616 (1989).
 In this case, the variable @t{SmearingMPOrder} sets the order of the smearing.
 Occupations may be negative.
@item @strong{spline_smearing}:  Nearly identical to Gaussian smearing.
 JM Holender, MJ Gillan, MC Payne, and AD Simpson, @emph{Phys. Rev. B} @strong{52}, 967 (1995).
@end itemize

@c ----------------------------------
@item @strong{SmearingMPOrder}@*
@vindex @code{SmearingMPOrder}@*
@emph{Section}: States@*
@emph{Type}: integer@*
@emph{Default}: 1@*
@* Sets the order of the Methfessel-Paxton smearing function.



@c ----------------------------------
@item @strong{SpinComponents}@*
@vindex @code{SpinComponents}@*
@emph{Section}: States@*
@emph{Type}: integer@*
@emph{Default}: unpolarized@*
@* The calculations may be done in three different ways: spin-restricted (TD)DFT (@emph{i.e.}, doubly
 occupied "closed shells"), spin-unrestricted or "spin-polarized" (TD)DFT (@emph{i.e.} we have two
 electronic systems, one with spin up and one with spin down), or making use of two-component
 spinors.


@emph{Options}:
@itemize @minus
@item @strong{unpolarized}:  Spin-restricted calculations.
@item @strong{spin_polarized}:  (Synonym @t{polarized}.) Spin-unrestricted, also known as spin-DFT, SDFT. This mode will double the number of
 wavefunctions necessary for a spin-unpolarized calculation.
@item @strong{spinors}:  (Synonym: @t{non_collinear}.) The spin-orbitals are two-component spinors. This effectively allows the spin-density to
 be oriented non-collinearly: @emph{i.e.} the magnetization vector is allowed to take different
 directions at different points. This vector is always in 3D regardless of @t{Dimensions}.
@end itemize

@c ----------------------------------
@item @strong{StatesRandomization}@*
@vindex @code{StatesRandomization}@*
@emph{Section}: States@*
@emph{Type}: integer@*
@emph{Default}: par_independent@*
@* The randomization of states can be done in two ways:
 i) a parallelisation independent way (default), where the random states are identical,
 irrespectively of the number of tasks and
 ii) a parallelisation dependent way, which can prevent linear dependency
  to occur for large systems.


@emph{Options}:
@itemize @minus
@item @strong{par_independent}:  Parallelisation-independent randomization of states.
@item @strong{par_dependent}:  The randomization depends on the number of taks used in the calculation.
@end itemize

@c ----------------------------------
@item @strong{SymmetrizeDensity}@*
@vindex @code{SymmetrizeDensity}@*
@emph{Section}: States@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* When enabled the density is symmetrized. Currently, this can
 only be done for periodic systems. (Experimental.)



@c ----------------------------------
@item @strong{TotalStates}@*
@vindex @code{TotalStates}@*
@emph{Section}: States@*
@emph{Type}: integer@*
@* This variable sets the total number of states that Octopus will
 use. This is normally not necessary since by default Octopus
 sets the number of states to the minimum necessary to hold the
 electrons present in the system. (This default behavior is
 obtained by setting @t{TotalStates} to 0).

 If you want to add some unoccupied states, probably it is more convenient to use the variable
 @t{ExtraStates}.



@c ----------------------------------
@item @strong{TransformStates}@*
@vindex @code{TransformStates}@*
@emph{Section}: States@*
@emph{Type}: block@*
@emph{Default}: no@*
@* Before starting the @t{td} calculation, the initial states (that are
 read from the @t{restart/gs} directory, which should have been
 generated in a previous ground-state calculation) can be "transformed"
 among themselves. The block @t{TransformStates} gives the transformation matrix
 to be used. The number of rows and columns of the matrix should equal the number
 of the states present in the time-dependent calculation (the independent
 spin and @emph{k}-point subspaces are all transformed equally); the number of
 columns should be equal to the number of states present in the
 @t{restart/gs} directory. This number may be different: for example,
 one could have run previously in @t{unocc} mode in order to obtain unoccupied
 Kohn-Sham states, and therefore @t{restart/gs} will contain more states.
 These states can be used in the transformation.

 Note that the code will not check the orthonormality of the new states!

 Each line provides the coefficients of the new states, in terms of
 the old ones. The coefficients are complex, but the imaginary part will be
 ignored for real wavefunctions.
 Note: This variable cannot be used when parallel in states.



@c ----------------------------------
@item @strong{UserDefinedStates}@*
@vindex @code{UserDefinedStates}@*
@emph{Section}: States@*
@emph{Type}: block@*
@* Instead of using the ground state as initial state for
 time-propagations it might be interesting in some cases
 to specify alternate states. Like with user-defined
 potentials, this block allows you to specify formulas for
 the orbitals at @emph{t}=0.

 Example:

 @t{%UserDefinedStates
 @*@ @  1 | 1 | 1 | formula | "exp(-r^2)*exp(-i*0.2*x)" | normalize_yes
 @*%}

 The first column specifies the component of the spinor,
 the second column the number of the state and the third
 contains @emph{k}-point and spin quantum numbers. Column four
 indicates that column five should be interpreted as a formula
 for the corresponding orbital.

 Alternatively, if column four states @t{file} the state will
 be read from the file given in column five.

 @t{%UserDefinedStates
 @*@ @  1 | 1 | 1 | file | "/path/to/file" | normalize_no
 @*%}

 Octopus reads first the ground-state orbitals from
 the @t{restart/gs} directory. Only the states that are
 specified in the above block will be overwritten with
 the given analytic expression for the orbital.

 The sixth (optional) column indicates whether @t{Octopus} should renormalize
 the orbital. The default (no sixth column given) is to renormalize.



@emph{Options}:
@itemize @minus
@item @strong{file}:  Read initial orbital from file.
 Accepted file formats, detected by extension: obf, ncdf and csv (real only).
@item @strong{normalize_no}:  Do not normalize orbitals.
@item @strong{formula}:  Calculate initial orbital by given analytic expression.
@item @strong{normalize_yes}:  Normalize orbitals (default).
@end itemize

@c ----------------------------------
@end itemize
@node ModelMB,,,
@subsection ModelMB
@c ----------------------------------

@itemize
@item @strong{DensitytoCalc}@*
@vindex @code{DensitytoCalc}@*
@emph{Section}: States::ModelMB@*
@emph{Type}: block@*
@* Choice of which particle density (event. matrices) will be calculated and output, in the
 modelmb particles scheme.

 @t{%DensitytoCalc
 @*@ @  "proton"   | 1 | 10
 @*@ @  "electron" | 2 | 15
 @*%}

 would ask octopus to calculate the density matrix corresponding to the 1st
 particle (whose coordinates correspond to dimensions 1 to ndim_modelmb),
 which is an proton, then that corresponding to the 2nd particle
 (electron with dimensions ndim_modelmb+1 to 2*ndim_modelmb), printing
 10 natural orbitals for the first and 15 for the second.

 @t{%DensitytoCalc
 @*@ @  "proton"   | 1 | -1
 @*@ @  "electron" | 2 | -1
 @*%}

 would ask octopus to print out just the densities for particles 1 and 2
 without any density matrix output.




@c ----------------------------------
@item @strong{DescribeParticlesModelmb}@*
@vindex @code{DescribeParticlesModelmb}@*
@emph{Section}: States::ModelMB@*
@emph{Type}: block@*
@* Characterization of different modelmb particles in space%dim dimensional space.

 @t{%DescribeParticlesModelmb
 @*@ @  "proton"   | 1 | 1800. | 1. | fermion
 @*@ @  "proton"   | 1 | 1800. | 1. | fermion
 @*@ @  "electron" | 2 | 1.    | 1. | fermion
 @*%}

 would tell @t{Octopus} that there are presently 3 particles, called proton, proton,
 and electron, with types 1, 1, and 2, and corresponding masses and charges.
 All particles should be fermions, and this can be later enforced on the spatial
 part of the wavefunctions.
 The label and charge are presently only for informational purposes and
 are not checked or used in @t{Octopus}. The interaction has to take the
 actual charge into account.



@emph{Options}:
@itemize @minus
@item @strong{fermion}:   Particle is a fermion.
@item @strong{boson}:   Particle is a boson.
@item @strong{anyon}:   Particle is neither fermion nor boson.
@end itemize

@c ----------------------------------
@item @strong{NDimModelmb}@*
@vindex @code{NDimModelmb}@*
@emph{Section}: States::ModelMB@*
@emph{Type}: integer@*
@emph{Default}: 1@*
@* Number of dimensions for modelmb space.
 Full Ndim = @t{NDimModelmb}*@t{NParticleModelmb}




@c ----------------------------------
@item @strong{NParticleModelmb}@*
@vindex @code{NParticleModelmb}@*
@emph{Section}: States::ModelMB@*
@emph{Type}: integer@*
@* Number of particles in modelmb space.
 Full Ndim = @t{NDimModelmb}*@t{NParticleModelmb}



@c ----------------------------------
@item @strong{NTypeParticleModelmb}@*
@vindex @code{NTypeParticleModelmb}@*
@emph{Section}: States::ModelMB@*
@emph{Type}: integer@*
@emph{Default}: 1@*
@* Number of different types of particles in modelmb space.



@c ----------------------------------
@end itemize
@node System,,,
@section System
@c ----------------------------------

@itemize
@item @strong{Dimensions}@*
@vindex @code{Dimensions}@*
@emph{Section}: System@*
@emph{Type}: integer@*
@emph{Default}: 3@*
@* @t{Octopus} can run in 1, 2 or 3 dimensions, depending on the value of this
 variable (or more, if configured with @t{--with-max-dim=4} or higher).
 Note that not all input variables may be available in all cases.



@c ----------------------------------
@item @strong{Interactions}@*
@vindex @code{Interactions}@*
@emph{Section}: System@*
@emph{Type}: block@*
@* This input option controls the interactions between systems. It basically
 allows to select which systems will interact with another system through
 a given interaction type. The format of the block is the following:

  @*%@t{Namespace.Interactions
   @*@ @ interaction_type | interaction_mode | ...
  @*%}

 Here is an example to better understand how this works:

  @*%@t{SystemA.Interactions
   @*@ @ gravity | all_except | "SystemB"
  @*%}

 This means that SystemA and all the systems that belong to the same
 namespace (i.e., all its subsystems) will interact through gravity with
 all interaction partners that are also able to interact through gravity,
 except with SystemB. Note that the opposite is not true so, although
 clearly unphysical, this will not prevent SystemB from feeling the
 gravity from SystemA (in @t{Octopus} the interactions are always
 one-sided).

 NB: Each interaction type should only appear once in the block. Any
 further instances beyond the first will be ignored.

 Available modes and interaction types:


@emph{Options}:
@itemize @minus
@item @strong{no_partners}:   (interaction mode)
 Do not interact with any partner.
@item @strong{all_partners}:   (interaction mode)
 Interact with all available partners.
@item @strong{only_partners}:   (interaction mode)
 Interact only with some specified partners. A list of partner names must
 be given.
@item @strong{all_except}:   (interaction mode)
 Interact with all available partners except with some specified
 partners. A list of partner names to exclude must be given.
@item @strong{gravity}:   (interaction type)
 Gravity interaction between two masses.
@item @strong{lorentz_force}:   (interaction type)
 Lorentz force resulting from an EM field acting on a moving charge.
@item @strong{coulomb_force}:   (interaction type)
 Coulomb force between two charged particles.
@item @strong{linear_medium_to_em_field}:   (interaction type)
 Linear medium for propagation of EM fields.
@item @strong{current_to_mxll_field}:   (interaction type)
 Drude dispersive linear medium for propagation of EM fields.
@item @strong{maxwell_field_to_medium}:   (interaction type)
 Electric field resulting from the Maxwell solver.
@end itemize

@c ----------------------------------
@item @strong{PeriodicDimensions}@*
@vindex @code{PeriodicDimensions}@*
@emph{Section}: System@*
@emph{Type}: integer@*
@* Define how many directions are to be considered periodic. It has to be a number
 between zero and @t{Dimensions}.


@emph{Options}:
@itemize @minus
@item @strong{0}:  No direction is periodic (molecule).
@item @strong{1}:  The @emph{x} direction is periodic.
@item @strong{2}:  The @emph{x} and @emph{y} directions are periodic.
@item @strong{3}:  The @emph{x}, @emph{y}, and @emph{z} directions are periodic.
@end itemize

@c ----------------------------------
@item @strong{StaticExternalPotentials}@*
@vindex @code{StaticExternalPotentials}@*
@emph{Section}: System@*
@emph{Type}: block@*
@* An static external potential is a model potential added to the local potential of the Hamiltonian

 The format of this block is the following:
 The first field defines the type of species (the valid options are detailed
 below).

 Then a list of parameters follows. The parameters are specified
 by a first field with the parameter name and the field that
 follows with the value of the parameter. Some parameters are
 specific to a certain species while others are accepted by all
 species. These are @t{mass}, @t{max_spacing}, and @t{min_radius}.

 These are examples of possible species:

 @t{%ExternalPotential
 @*@ @  potential_user_defined | potential_formula | "1/2*r^2"
 @*%}


@emph{Options}:
@itemize @minus
@item @strong{file}:  The path for the file that describes the species.
@item @strong{potential_formula}:  Mathematical expression that defines the potential for @t{species_user_defined}. You can use
 any of the @emph{x}, @emph{y}, @emph{z} or @emph{r} variables.
@item @strong{density_formula}:  Mathematical expression that defines the charge density for @t{species_charge_density}. You can use
 any of the @emph{x}, @emph{y}, @emph{z} or @emph{r} variables.
@item @strong{potential_user_defined}:  Species with user-defined potential. The potential for the
 species is defined by the formula given by the @t{potential_formula}
 parameter.
@item @strong{potential_from_file}:  The potential is read from a file. Accepted file formats, detected by extension: obf, ncdf and csv.
@item @strong{potential_charge_density}:  The potential for this species is created from the distribution
 of charge given by the @t{density_formula} parameter.
@end itemize

@c ----------------------------------
@item @strong{Systems}@*
@vindex @code{Systems}@*
@emph{Section}: System@*
@emph{Type}: block@*
@* List of systems that will be treated in the calculation.
 The first column should be a string containing the system name.
 The second column should be the system type. See below for a list of
 available system types.


@emph{Options}:
@itemize @minus
@item @strong{electronic}:  An electronic system. (not fully implemented yet)
@item @strong{maxwell}:  A maxwell system.
@item @strong{classical_particle}:  A classical particle. Used for testing purposes only.
@item @strong{charged_particle}:  A charged classical particle.
@item @strong{dftbplus}:  A DFTB+ system
@item @strong{linear_medium}:  A linear medium for classical electrodynamics.
@item @strong{matter}:  A matter system containing electrons and classical ions.
@item @strong{dispersive_medium}:  (Experimental) A dispersive medium for classical electrodynamics.
@item @strong{multisystem}:  A system containing other systems.
@end itemize

@c ----------------------------------
@end itemize
@node Coordinates,,,
@subsection Coordinates
@c ----------------------------------

@itemize
@item @strong{Coordinates}@*
@vindex @code{Coordinates}@*
@emph{Section}: System::Coordinates@*
@emph{Type}: block@*
@* If @t{XYZCoordinates}, @t{PDBCoordinates}, and @t{XSFCoordinates} were not found,
 @t{Octopus} tries to read the coordinates for the atoms from the block @t{Coordinates}. The
 format is quite straightforward:

 @t{%Coordinates
 @*@ @ 'C' |      -0.56415 | 0.0 | 0.0 | no
 @*@ @ 'O' | @ 0.56415 | 0.0 | 0.0 | no
 @*%}

 The first line defines a carbon atom at coordinates (-0.56415, 0.0, 0.0),
 that is @strong{not} allowed to move during dynamical simulations. The second line has
 a similar meaning. This block obviously defines a carbon monoxide molecule, if the
 input units are @t{eV_Angstrom}. The number of coordinates for each species
 must be equal to the dimension of your space (generally 3).
 Note that in this way it is possible to fix some of the atoms (this
 is not possible when specifying the coordinates through a @t{PDBCoordinates} or
 @t{XYZCoordinates} file). The last column is optional, and the default is yes.
 It is always possible to fix @strong{all} atoms using the @t{MoveIons} directive.



@c ----------------------------------
@item @strong{PDBClassical}@*
@vindex @code{PDBClassical}@*
@emph{Section}: System::Coordinates@*
@emph{Type}: string@*
@* If this variable is present, the program tries to read the atomic coordinates for classical atoms.
 from the file specified by its value. The same as @t{PDBCoordinates}, except that the
 classical charge colum must be present. The interaction from the
 classical atoms is specified by @t{ClassicalPotential}, for QM/MM calculations.
 Not available in periodic systems.



@c ----------------------------------
@item @strong{PDBCoordinates}@*
@vindex @code{PDBCoordinates}@*
@emph{Section}: System::Coordinates@*
@emph{Type}: string@*
@* If this variable is present, the program tries to read the atomic coordinates
 from the file specified by its value. The PDB (<a href=http://www.rcsb.org/pdb>Protein Data Bank</a>)
 format is quite complicated, and it goes
 well beyond the scope of this manual. You can find a comprehensive
 description <a href=http://www.wwpdb.org/docs.html>here</a>.
 From the plethora of instructions defined in the PDB standard, @t{Octopus}
 only reads two, @t{ATOM} and @t{HETATOM}. From these fields, it reads:
 @itemize

 @item
 columns 13-16: The species; in fact @t{Octopus} only cares about the
 first letter - @t{CA} and @t{CB} will both refer to carbon - so elements whose
 chemical symbol has more than one letter cannot be represented in this way.
 So, if you want to run mercury (Hg), please use one of the other methods
 to input the coordinates.
 @item
 columns 18-21: The residue. Ignored.
 @item
 columns 31-54: The Cartesian coordinates. The Fortran format is @t{(3f8.3)}.
 @item
 columns 61-65: Classical charge of the atom. Required if reading classical atoms, ignored otherwise.
 The Fortran format is @t{(f6.2)}.
 @end itemize

 NOTE: The coordinates are treated in the units specified by @t{Units} and/or @t{UnitsInput}.



@c ----------------------------------
@item @strong{ReducedCoordinates}@*
@vindex @code{ReducedCoordinates}@*
@emph{Section}: System::Coordinates@*
@emph{Type}: block@*
@* This block gives the atomic coordinates relative to the real
 space unit cell. The format is the same as the
 @t{Coordinates} block.

 Note that in Octopus the origin of coordinates is in the center
 of the cell, so the coordinates inside the cell are in the
 range [-0.5, 0.5).

 This block cannot be used with the @t{minimum} box shape.



@c ----------------------------------
@item @strong{XSFCoordinates}@*
@vindex @code{XSFCoordinates}@*
@emph{Section}: System::Coordinates@*
@emph{Type}: string@*
@* Another option besides PDB and XYZ coordinates formats is XSF, as <a href=http://www.xcrysden.org/doc/XSF.html>defined</a>
 by the XCrySDen visualization program. Specify the filename with this variable.
 The lattice vectors will also be read from this file and the value of
 @t{PeriodicDimensions} needs to be compatible with the first line
 (@t{CRYSTAL}, @t{SLAB}, @t{POLYMER}, or @t{MOLECULE}).
 The file should not contain @t{ATOMS}, @t{CONVVEC}, or @t{PRIMCOORD}.
 NOTE: The coordinates are treated in the units specified by @t{Units} and/or @t{UnitsInput}.



@c ----------------------------------
@item @strong{XSFCoordinatesAnimStep}@*
@vindex @code{XSFCoordinatesAnimStep}@*
@emph{Section}: System::Coordinates@*
@emph{Type}: integer@*
@emph{Default}: 1@*
@* If an animated file is given with @t{XSFCoordinates}, this variable selects which animation step
 will be used. The @t{PRIMVEC} block must be written for each step.



@c ----------------------------------
@item @strong{XYZCoordinates}@*
@vindex @code{XYZCoordinates}@*
@emph{Section}: System::Coordinates@*
@emph{Type}: string@*
@* If @t{PDBCoordinates} is not present, the program reads the atomic coordinates from
 the XYZ file specified by the variable @t{XYZCoordinates} -- in case this variable
 is present. The XYZ format is very simple: The first line of the file has an integer
 indicating the number of atoms. The second can contain comments that are simply ignored by
 @t{Octopus}. Then there follows one line per atom, containing the chemical species and
 the Cartesian coordinates of the atom.

 If you want to specify the unit of the XYZ file, you can use the variable @t{UnitsXYZFiles}.



@c ----------------------------------
@end itemize
@node Species,,,
@subsection Species
@c ----------------------------------

@itemize
@item @strong{PseudopotentialSet}@*
@vindex @code{PseudopotentialSet}@*
@emph{Section}: System::Species@*
@emph{Type}: integer@*
@emph{Default}: standard@*
@* Selects the set of pseudopotentials used by default for species
 not defined in the @t{Species} block.

 These sets of pseudopotentials come from different
 sources. Octopus developers have not validated them. We include
 them with the code for convenience of the users, but you are
 expected to check the quality and suitability of the
 pseudopotential for your application.



@emph{Options}:
@itemize @minus
@item @strong{none}:  Do not load any pseudopotential by default. All species must be
 specified in the Species block.
@item @strong{pseudodojo_pbe}:  PBE version of the pseudopotentials of http://pseudo-dojo.org. Version 0.4.
@item @strong{pseudodojo_lda}:  LDA pseudopotentials of http://pseudo-dojo.org. Version 0.4.
@item @strong{pseudodojo_pbesol}:  PBEsol version of the pseudopotentials of http://pseudo-dojo.org. Version 0.3.
@item @strong{standard}:  The standard set of Octopus that provides LDA pseudopotentials
 in the PSF format for some elements: H, Li, C, N, O, Na, Si, S, Ti, Se, Cd.
@item @strong{sg15}:  The set of Optimized Norm-Conserving Vanderbilt
 PBE pseudopotentials. Ref: M. Schlipf and F. Gygi, @emph{Comp. Phys. Commun.} @strong{196}, 36 (2015).
 This set provides pseudopotentials for elements up to Z = 83
 (Bi), excluding Lanthanides.
 Current version of the set is 1.2.
@item @strong{hgh_lda_sc}:  The semicore set of Hartwigsen-Goedecker-Hutter LDA pseudopotentials.
 Ref: C. Hartwigsen, S. Goedecker, and J. Hutter, @emph{Phys. Rev. B} @strong{58}, 3641 (1998).
@item @strong{hgh_lda}:  The set of Hartwigsen-Goedecker-Hutter LDA pseudopotentials for elements from H to Rn.
 Ref: C. Hartwigsen, S. Goedecker, and J. Hutter, @emph{Phys. Rev. B} @strong{58}, 3641 (1998).
@item @strong{hscv_lda}:  The set of Hamann-Schlueter-Chiang-Vanderbilt (HSCV) potentials
 for LDA exchange and correlation downloaded from http://fpmd.ucdavis.edu/potentials/index.htm.
 These pseudopotentials were originally intended for the QBox
 code. They were generated using the method of Hamann, Schluter
 and Chiang. Ref: D. Vanderbilt, @emph{Phys. Rev. B} @strong{32}, 8412 (1985).
 Warning from the original site: The potentials provided in this
 site are distributed without warranty. In most cases,
 potentials were not tested. Potentials should be thoroughly
 tested before being used in simulations.
@item @strong{hscv_pbe}:  PBE version of the HSCV pseudopotentials. Check the
 documentation of the option @t{hscv_lda} for details and warnings.
@end itemize

@c ----------------------------------
@item @strong{Species}@*
@vindex @code{Species}@*
@emph{Section}: System::Species@*
@emph{Type}: block@*
@* A species is by definition either an "ion" (nucleus + core electrons) described
 through a pseudopotential, or a model potential.

 Note that some sets of pseudopotentials are distributed with
 the code. To use these pseudopotentials, you do not need to define them
 explicitly in the @t{Species} block, as default parameters
 are provided.
 You can select the set for default pseudopotentials using the
 @t{PseudopotentialSet} variable.

 Additional pseudopotentials can be downloaded from the <a
 href='http://octopus-code.org/wiki/Pseudopotentials'>
 octopus homepage</a> or from other sources. Supported norm-conserving pseudopotential formats are
 detected by the file extension: UPF (@t{.upf}), PSF (SIESTA, @t{.psf}), FHI (ABINIT 6, @t{.fhi}),
 CPI (Fritz-Haber, @t{.cpi}), QSO (quantum-simulation.org, for Qbox, @t{.xml}),
 HGH (Hartwigsen-Goedecker-Hutter, @t{.hgh}).
 PSPIO format can also be used via @t{species_pspio} if that library is linked.
 Note: pseudopotentials may only be used in 3D.

 The format of this block is the following: The first field is a
 string that defines the name of the species. The second field
 defines the type of species (the valid options are detailed
 below).

 Then a list of parameters follows. The parameters are specified
 by a first field with the parameter name and the field that
 follows with the value of the parameter. Some parameters are
 specific to a certain species while others are accepted by all
 species. These are @t{mass}, @t{max_spacing}, and @t{min_radius}.

 These are examples of possible species:

 @t{%Species
 @*@ @ 'O'       | species_pseudo         | file | 'O.psf' | lmax |  1 | lloc | 1
 @*@ @ 'H'       | species_pseudo         | file | '../H.hgh'
 @*@ @ 'Xe'      | species_pseudo         | set | pseudojo_pbe_stringent
 @*@ @ 'C'       | species_pseudo         | file | "carbon.xml"
 @*@ @ 'jlm'     | species_jellium        | jellium_radius | 5.0
 @*@ @ 'rho'     | species_charge_density | density_formula | "exp(-r/a)" | mass | 17.0 | valence | 6
 @*@ @ 'udf'     | species_user_defined   | potential_formula | "1/2*r^2" | valence | 8
 @*@ @ 'He_all'  | species_full_delta
 @*@ @ 'H_all'   | species_full_gaussian  |  gaussian_width |  0.2
 @*@ @ 'Li1D'    | species_soft_coulomb   |  softening | 1.5 | valence | 3
 @*%}


@emph{Options}:
@itemize @minus
@item @strong{lmax}:  The maximum angular-momentum channel that will be used for the pseudopotential.
@item @strong{lloc}:  The angular-momentum channel of the pseudopotential to be considered local.
@item @strong{mass}:  The mass of the species in atomic mass units, @emph{i.e.} the mass of a proton is
 roughly one. It is set automatically for pseudopotentials from the
 <a href=http://www.nist.gov/pml/data/comp.cfm>NIST values</a>.
 For other species, the default is 1.0.
@item @strong{valence}:  The number of electrons of the species. It is set automatically for pseudopotentials,
 but is mandatory for other species.
@item @strong{jellium_radius}:  The radius of the sphere for @t{species_jellium}. If this value is not specified,
 the default of 0.5 bohr is used.
@item @strong{gaussian_width}:  The width of the Gaussian (in units of spacing) used to represent
 the nuclear charge for @t{species_full_gaussian}. If not present,
 the default is 0.25.
@item @strong{softening}:  The softening parameter @emph{a} for @t{species_soft_coulomb} in units of length.
@item @strong{file}:  The path for the file that describes the species.
@item @strong{db_file}:  Obsolete. Use the @t{set} option of the @t{PseudopotentialSet} variable instead.
@item @strong{potential_formula}:  Mathematical expression that defines the potential for @t{species_user_defined}. You can use
 any of the @emph{x}, @emph{y}, @emph{z} or @emph{r} variables.
@item @strong{density_formula}:  Mathematical expression that defines the charge density for @t{species_charge_density}. You can use
 any of the @emph{x}, @emph{y}, @emph{z} or @emph{r} variables.
@item @strong{thickness}:  The thickness of the slab for species_jellium_slab. Must be positive.
@item @strong{vdw_radius}:  The van der Waals radius that will be used for this species.
@item @strong{volume}:  Name of a volume block
@item @strong{set}:  For a @t{species_pseudo}, get the pseudopotential from a
 particular set. This flag must be followed with one of the
 valid values for the variable @t{PseudopotentialSet}.
@item @strong{hubbard_l}:  The angular-momentum for which the effective U will be applied.
@item @strong{hubbard_u}:  The effective U that will be used for the LDA+U calculations.
@item @strong{hubbard_j}:  The value of j (hubbard_l-1/2 or hubbard_l+1/2) on which the effective U is applied.
@item @strong{hubbard_alpha}:  The strength of the potential constraining the occupations of the localized subspace
 as defined in PRB 71, 035105 (2005)
@item @strong{species_pspio}:  (experimental) Alternative method to read pseudopotentials
 using the PSPIO library. This species uses the same parameters
 as @t{species_pseudo}.
@item @strong{species_user_defined}:  Species with user-defined potential. The potential for the
 species is defined by the formula given by the @t{potential_formula}
 parameter.
 The
 @t{valence} parameter determines the number of electrons
 associated with the species. By default, a valence of 0 is assumed.
@item @strong{species_full_gaussian}:  A full-potential atom is defined by a Gaussian accumulation of
 positive charge (distorted if curvilinear coordinates are
 used), in the form:

 \(q(r) = z \beta \exp[ - (\vec{r}-\vec{r_0})^2 / (\sqrt{2} \delta \sigma) ] \)

 \(\beta\) is chosen in order to maintain proper
 normalization (the integral of \(q\) should sum up to
 \(z\)). \(\delta\) is the grid spacing (the
 grid spacing in the first dimension, to be precise).
 \(\vec{r_0}\) is calculated in such a way that the the
 first moment of \(q(r)/z\) is equal to the atomic
 position. For a precise description, see N. A. Modine,
 @emph{Phys. Rev. B} @strong{55}, 10289 (1997). The width of the
 Gaussian is set by parameter @t{gaussian_width}. The
 atomic number is determined from the name of the species.
@item @strong{species_charge_density}:  The potential for this species is created from the distribution
 of charge given by the @t{density_formula} parameter.
 The
 @t{valence} parameter determines the number of electrons
 associated with the species. By default, a valence of 0 is assumed.
@item @strong{species_from_file}:  The potential is read from a file. Accepted file formats, detected by extension: obf, ncdf and csv.
 The
 @t{valence} parameter determines the number of electrons
 associated with the species. By default, a valence of 0 is assumed.
@item @strong{species_full_delta}:  Full atomic potential represented by a delta charge
 distribution. The atom will be displaced to the nearest grid
 point. The atomic number is determined from the name of the species.
@item @strong{species_soft_coulomb}:  The potential is a soft-Coulomb function, @emph{i.e.} a function in the form:

 \(v(r) = - z_{val} / \sqrt{a^2 + r^2}\)

 The value of @emph{a} should be given by the mandatory @t{softening} parameter.
 The charge associated with this species must be given by the @t{valence} parameter.
@item @strong{species_jellium_charge_density}:  The parameter is the name of a volume block specifying the shape of the jellium.
@item @strong{species_jellium}:  Jellium sphere.
 The charge associated with this species must be given by the @t{valence} parameter.
@item @strong{species_jellium_slab}:  A slab of jellium that extends across the simulation box in the
 @emph{xy}-plane. The dimension along the @emph{z} direction is
 determined by the required parameter @t{thickness}.
 The charge associated with this species must be given by the @t{valence} parameter.
@item @strong{species_pseudo}:  The species is a pseudopotential. How to get the
 pseudopotential can be specified by the @t{file} or
 the @t{set} parameters. If both are missing, the
 pseudopotential will be taken from the @t{PseudopotentialSet}
 specified for the run, this is useful if you want to change
 some parameters of the pseudo, like the @t{mass}.

 The optional parameters for this type of species are
 @t{lmax}, that defines the maximum angular momentum
 component to be used, and @t{lloc}, that defines the
 angular momentum to be considered as local. When these
 parameters are not set, the value for lmax is the maximum
 angular component from the pseudopotential file. The default
 value for @t{lloc} is taken from the pseudopotential if
 available, if not, it is set to 0. Note that, depending on the
 type of pseudopotential, it might not be possible to select
 @t{lmax} and @t{lloc}, if that is the case the
 parameters will be ignored.

@end itemize

@c ----------------------------------
@item @strong{SpeciesProjectorSphereThreshold}@*
@vindex @code{SpeciesProjectorSphereThreshold}@*
@emph{Section}: System::Species@*
@emph{Type}: float@*
@emph{Default}: 0.001@*
@* The pseudopotentials may be composed of a local part, and a linear combination of nonlocal
 operators. These nonlocal projectors have "projector" form, \( \left| v \right> \left< v \right| \)
 (or, more generally speaking, \( \left| u \right> \left< v \right| \)).
 These projectors are localized in real space -- that is, the function \(v\)
 has a finite support around the nucleus. This region where the projectors are localized should
 be small or else the computation time required to operate with them will be very large.

 In practice, this localization is fixed by requiring the definition of the projectors to be
 contained in a sphere of a certain radius. This radius is computed by making sure that the
 absolute value of the projector functions, at points outside the localization sphere, is
 below a certain threshold. This threshold is set by @t{SpeciesProjectorSphereThreshold}.



@c ----------------------------------
@item @strong{SpeciesTimeDependent}@*
@vindex @code{SpeciesTimeDependent}@*
@emph{Section}: System::Species@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* When this variable is set, the potential defined in the block @t{Species} is calculated
 and applied to the Hamiltonian at each time step. You must have at least one @t{species_user_defined}
 type of species to use this.



@c ----------------------------------
@end itemize
@node Velocities,,,
@subsection Velocities
@c ----------------------------------

@itemize
@item @strong{PDBVelocities}@*
@vindex @code{PDBVelocities}@*
@emph{Section}: System::Velocities@*
@emph{Type}: string@*
@* Like @t{XYZVelocities} but in PDB format, as in @t{PDBCoordinates}.



@c ----------------------------------
@item @strong{RandomVelocityTemp}@*
@vindex @code{RandomVelocityTemp}@*
@emph{Section}: System::Velocities@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* If this variable is present, @t{Octopus} will assign random
 velocities to the atoms following a Boltzmann distribution with
 temperature given by @t{RandomVelocityTemp} (in degrees Kelvin).
 The seed for the random number generator can be modified by setting
 @t{GSL_RNG_SEED} environment variable.



@c ----------------------------------
@item @strong{Velocities}@*
@vindex @code{Velocities}@*
@emph{Section}: System::Velocities@*
@emph{Type}: block@*
@* If @t{XYZVelocities}, @t{PDBVelocities}, and @t{XSFVelocities}
 are not present, @t{Octopus} will try to fetch the initial
 atomic velocities from this block. If this block is not present, @t{Octopus}
 will set the initial velocities to zero. The format of this block can be
 illustrated by this example:

 @t{%Velocities
 @*@ @ 'C'  |      -1.7 | 0.0 | 0.0
 @*@ @ 'O'  | @ 1.7 | 0.0 | 0.0
 @*%}

 It describes one carbon and one oxygen moving at the relative
 velocity of 3.4 velocity units.

 Note: It is important for the velocities to maintain the ordering
 in which the atoms were defined in the coordinates specifications.



@c ----------------------------------
@item @strong{XSFVelocities}@*
@vindex @code{XSFVelocities}@*
@emph{Section}: System::Velocities@*
@emph{Type}: string@*
@* Like @t{XYZVelocities} but in XCrySDen format, as in @t{XSFCoordinates}.



@c ----------------------------------
@item @strong{XYZVelocities}@*
@vindex @code{XYZVelocities}@*
@emph{Section}: System::Velocities@*
@emph{Type}: string@*
@* @t{Octopus} will try to read the starting velocities of the atoms from the XYZ file
 specified by the variable @t{XYZVelocities}.
 Note that you do not need to specify initial velocities if you are not going
 to perform ion dynamics; if you are going to allow the ions to move but the velocities
 are not specified, they are considered to be null.
 Note: It is important for the velocities to maintain the ordering
 in which the atoms were defined in the coordinates specifications.



@c ----------------------------------
@end itemize
@node Time-Dependent,,,
@section Time-Dependent
@c ----------------------------------

@itemize
@item @strong{MaxwellFunctions}@*
@vindex @code{MaxwellFunctions}@*
@emph{Section}: Time-Dependent@*
@emph{Type}: block@*
@* This block specifies the shape of a "spatial-dependent function", such as the
 envelope needed when using the @t{MaxwellFunctions} block. Each line in the block
 specifies one function. The first element of each line will be a string
 that defines the name of the function. The second element specifies which type
 of function we are using; in the following we provide an example for each of the
 possible types:



@emph{Options}:
@itemize @minus
@item @strong{mxf_const_wave}: 
 @t{%MaxwellFunctions
 @*@ @  "function-name" | mxf_const_wave | kx | ky | kz | x0 | y0 | z0
 @*%}

 The function is constant plane wave \( f(x,y,z) = a0 * \cos( kx*(x-x0) + ky*(y-y0) + kz*(z-z0) ) \)

@item @strong{mxf_const_phase}: 
 @t{%MaxwellFunctions
 @*@ @  "function-name" | mxf_const_phase | kx | ky | kz | x0 | y0 | z0
 @*%}

 The function is a constant phase of \( f(x,y,z) = a0 * (kx * x0 + ky * y0 + kz * z0) \)

@item @strong{mxf_gaussian_wave}: 
 @t{%MaxwellFunctions
 @*@ @  "function-name" | mxf_gaussian_wave | kx | ky | kz | x0 | y0 | z0 | width
 @*%}

 The function is a Gaussian, \( f(x,y,z) = a0 * \exp( -( kx*(x-x0) + ky*(y-y0) + kz*(z-z0) )^2 / (2 width^2) ) \)

@item @strong{mxf_cosinoidal_wave}: 
 @t{%MaxwellFunctions
 @*@ @  "function-name" | mxf_cosinoidal_wave | kx | ky | kz | x0 | y0 | z0 | width
 @*%}

 \( f(x,y,z) =  \cos( \frac{\pi}{2} \frac{kx*(x-x0)+ky*(y-y0)+kz*(z-z0)-2 width}{width} + \pi )  \)

 If \( | kx*x + ky*y + kz*z - x0 | > \xi\_0 \), then \( f(x,y,z) = 0 \).

@item @strong{mxf_logistic_wave}: 
 @t{%MaxwellFunctions
 @*@ @  "function-name" | mxf_logistic_wave | kx | ky | kz | x0 | y0 | z0 | growth | width
 @*%}

 The function is a logistic function, \( f(x,y,z) = a0 * 1/(1+\exp(growth*(kx*(x-x0)+ky*(y-y0)+kz*(kz*(z-z0))+width/2))) * 1/(1+\exp(-growth*(kx*(x-x0)+ky*(y-y0)+kz*(kz*(z-z0))-width/2)))  \)

@item @strong{mxf_trapezoidal_wave}: 
 @t{%MaxwellFunctions
 @*@ @  "function-name" | mxf_trapezoidal_wave | kx | ky | kz | x0 | y0 | z0 | growth | width
 @*%}

 The function is a logistic function,
   @* \( f(x,y,z)      = a0 * ( ( 1-growth*(k*(r-r0)-width/2)*\Theta(k*(r-r0)-width/2))*\Theta(-(k*(r-r0)+width/2+1/growth)) \)
   @* \( \qquad \qquad \qquad + (-1+growth*(k*(r-r0)+width/2)*\Theta(k*(r-r0)+width/2))*\Theta(-(k*(r-r0)-width/2+1/growth)) ) \)

@item @strong{mxf_from_expr}: 
 @t{%MaxwellFunctions
 @*@ @  "function-name" | mxf_from_expr | "expression"
 @*%}

 The temporal shape of the field is given as an expression (e.g., @t{cos(2.0*x-3*y+4*z)}. The
 letter @emph{x}, @emph{y}, @emph{z} means spatial coordinates, obviously.
 The expression is used to construct the function @emph{f}
 that defines the field.
@end itemize

@c ----------------------------------
@item @strong{MillerIndicesBasis}@*
@vindex @code{MillerIndicesBasis}@*
@emph{Section}: Time-Dependent@*
@emph{Type}: block@*
@* When this block is given, the polarisation of the TDExternalFields is
 understood to be defined in terms of Miller indices.
 This block define the corresponding basis, by defining the reduced coordinates
 of the X, Y, and Z high symmetry points, such that the code can do the corresponding
 transformation.

 For example, in an FCC crystal with the conventional primitive cell,
 the following input allows to define the polarization in terms of Miller indices

 @t{%MillerIndicesBasis
 @* 0.0 | 0.5 | 0.5
 @* 0.5 | 0.0 | 0.5
 @* 0.5 | 0.5 | 0.0
 @*%}

 Indeed, in this case, the reciprocal lattice vectors are (-1, 1, 1), (1, -1, 1),
 and (1, 1, -1) in units of 2*pi/a.
 This directly gives that the [100] direction correspond to the x direction, [111]
 gives the vector (1,1,1), etc.




@c ----------------------------------
@item @strong{TDExternalFields}@*
@vindex @code{TDExternalFields}@*
@emph{Section}: Time-Dependent@*
@emph{Type}: block@*
@* The block @t{TDExternalFields} describes the type and shape of time-dependent
 external perturbations that are applied to the system, in the form
 \(f(x,y,z) \cos(\omega t + \phi (t)) g(t)\), where \(f(x,y,z)\) is defined by
 by a field type and polarization or a scalar potential, as below; \(\omega\)
 is defined by @t{omega}; \(g(t)\) is defined by
 @t{envelope_function_name}; and \(\phi(t)\) is the (time-dependent) phase from @t{phase}.

 These perturbations are only applied for time-dependent runs. If
 you want the value of the perturbation at time zero to be
 applied for time-independent runs, use @t{TimeZero = yes}.

 Each line of the block describes an external field; this way you can actually have more
 than one laser (@emph{e.g.} a "pump" and a "probe").

 There are two ways to specify \(f(x,y,z)\) but both use the same @t{omega | envelope_function_name [| phase]}
 for the time-dependence.
 The float @t{omega} will be the carrier frequency of the
 pulse (in energy units). The envelope of the field is a time-dependent function whose definition
 must be given in a @t{TDFunctions} block. @t{envelope_function_name} is a string (and therefore
 it must be surrounded by quotation marks) that must match one of the function names
 given in the first column of the @t{TDFunctions} block.
 @t{phase} is optional and is taken to be zero if not provided, and is also a string specifying
 a time-dependent function.

 (A) type = @t{electric field, magnetic field, vector_potential}

 For these cases, the syntax is:

 @t{%TDExternalFields
 @*@ @  type | nx | ny | nz | omega | envelope_function_name | phase
 @*%}

 The @t{vector_potential} option (constant in space) permits us to describe
 an electric perturbation in the velocity gauge.
 The three (possibly complex) numbers (@t{nx}, @t{ny}, @t{nz}) mark the polarization
 direction of the field.
 By default, (@t{nx}, @t{ny}, @t{nz}) are defined in Cartesian space.
 However, it is possible for solids to define them using the Miller indices.
 This can be achieved by defining the block @t{MillerIndicesBasis}.

 (B) type = @t{scalar_potential}

 @t{%TDExternalFields
 @*@ @  scalar_potential | "spatial_expression" | omega | envelope_function_name | phase
 @*%}

 The scalar potential is any expression of the spatial coordinates given by the string
 "spatial_expression", allowing a field beyond the dipole approximation.

 For DFTB runs, only fields of type type = @t{electric field} are allowed for the moment, and the
 @t{type} keyword is omitted.

 A NOTE ON UNITS:

 It is very common to describe the strength of a laser field by its intensity, rather
 than using the electric-field amplitude. In atomic units (or, more precisely, in any
 Gaussian system of units), the relationship between instantaneous electric field
 and intensity is:
 \( I(t) = \frac{c}{8\pi} E^2(t) \).

 It is common to read intensities in W/cm\(^2\). The dimensions of intensities are
 [W]/(L\(^2\)T), where [W] are the dimensions of energy. The relevant conversion factors
 are:

 Hartree / (\(a_0^2\) atomic_time) = \(6.4364086 \times 10^{15} \mathrm{W/cm}^2\)

 eV / ( &Aring;\(^2 (\hbar\)/eV) ) = \(2.4341348 \times 10^{12} \mathrm{W/cm}^2\)

 If, in atomic units, we set the electric-field amplitude to \(E_0\),
 then the intensity is:

 \( I_0 = 3.51 \times 10^{16} \mathrm{W/cm}^2 (E_0^2) \)

 If, working with @t{Units = ev_angstrom}, we set \(E_0\), then the intensity is:

 \( I_0 = 1.327 \times 10^{13} (E_0^2) \mathrm{W/cm}^2 \)



@emph{Options}:
@itemize @minus
@item @strong{electric_field}:  The external field is an electric field, the usual case when we want to describe a
 laser in the length gauge.
@item @strong{magnetic_field}:  The external field is a (homogeneous) time-dependent magnetic field.
@item @strong{vector_potential}:  The external field is a time-dependent homogeneous vector potential, which may describe
 a laser field in the velocity gauge.
@item @strong{scalar_potential}:  The external field is an arbitrary scalar potential, which may describe an
 inhomogeneous electrical field.
@end itemize

@c ----------------------------------
@item @strong{TDFreezeDFTUOccupations}@*
@vindex @code{TDFreezeDFTUOccupations}@*
@emph{Section}: Time-Dependent@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* The occupation matrices than enters in the LDA+U potential
 are not evolved during the time evolution.



@c ----------------------------------
@item @strong{TDFreezeHXC}@*
@vindex @code{TDFreezeHXC}@*
@emph{Section}: Time-Dependent@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* The electrons are evolved as independent particles feeling the Hartree and
 exchange-correlation potentials from the ground-state electronic configuration.



@c ----------------------------------
@item @strong{TDFreezeOrbitals}@*
@vindex @code{TDFreezeOrbitals}@*
@emph{Section}: Time-Dependent@*
@emph{Type}: integer@*
@* (Experimental) You have the possibility of "freezing" a number of orbitals during a time-propagation.
 The Hartree and exchange-correlation potential due to these orbitals (which
 will be the lowest-energy ones) will be added during the propagation, but the orbitals
 will not be propagated.


@emph{Options}:
@itemize @minus
@item @strong{sae}:  Single-active-electron approximation. This option is only valid for time-dependent
 calculations (@t{CalculationMode = td}). Also, the nuclei should not move.
 The idea is that all orbitals except the last one are frozen. The orbitals are to
 be read from a previous ground-state calculation. The active orbital is then treated
 as independent (whether it contains one electron or two) -- although it will
 feel the Hartree and exchange-correlation potentials from the ground-state electronic
 configuration.

 It is almost equivalent to setting @t{TDFreezeOrbitals = N-1}, where @t{N} is the number
 of orbitals, but not completely.
@end itemize

@c ----------------------------------
@item @strong{TDFreezeU}@*
@vindex @code{TDFreezeU}@*
@emph{Section}: Time-Dependent@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* The effective U of LDA+U is not evolved during the time evolution.



@c ----------------------------------
@item @strong{TDFunctions}@*
@vindex @code{TDFunctions}@*
@emph{Section}: Time-Dependent@*
@emph{Type}: block@*
@* This block specifies the shape of a "time-dependent function", such as the
 envelope needed when using the @t{TDExternalFields} block. Each line in the block
 specifies one function. The first element of each line will be a string
 that defines the name of the function. The second element specifies which type
 of function we are using; in the following we provide an example for each of the
 possible types:



@emph{Options}:
@itemize @minus
@item @strong{tdf_cw}: 
 @t{%TDFunctions
 @*@ @  "function-name" | tdf_cw | amplitude
 @*%}

 The function is just a constant of value @t{amplitude}: \( f(t) \) = amplitude

@item @strong{tdf_gaussian}: 
 @t{%TDFunctions
 @*@ @  "function-name" | tdf_gaussian | amplitude | tau0 | t0
 @*%}

 The function is a Gaussian, \( f(t) = F_0 \exp( - (t-t_0)^2/(2\tau_0^2) ) \),
 where \(F_0\) = amplitude.

@item @strong{tdf_cosinoidal}: 
 @t{%TDFunctions
 @*@ @  "function-name" | tdf_cosinoidal | amplitude | tau0 | t0
 @*%}

 \( f(t) =  F_0 \cos( \frac{\pi}{2} \frac{t-2\tau_0-t_0}{\tau0} )  \)

 If \( | t - t_0 | > \tau_0 \), then \( f(t) = 0 \).

@item @strong{tdf_trapezoidal}: 
 @t{%TDFunctions
 @*@ @  "function-name" | tdf_trapezoidal | amplitude | tau0 | t0 | tau1
 @*%}

 This function is a trapezoidal centered around @t{t0}. The
 shape is determined by @t{tau0} and @t{tau1}. The
 function ramps linearly for @t{tau1} time units, stays
 constant for @t{tau0} time units, and then decays to zero
 linearly again for @t{tau1} time units.

@item @strong{tdf_from_file}: 
 @t{%TDFunctions
 @*@ @  "function-name" | tdf_from_file | "filename"
 @*%}

 The temporal shape of the function is contained in a file called @t{filename}. This file
 should contain three columns: first column is time, second and third column are the
 real part and the imaginary part of the temporal function @emph{f}(@emph{t}).

@item @strong{tdf_from_expr}: 
 @t{%TDFunctions
 @*@ @  "function-name" | tdf_from_expr | "expression"
 @*%}

 The temporal shape of the field is given as an expression (e.g., @t{cos(2.0*t)}. The
 letter @emph{t} means time, obviously. The expression is used to construct the function @emph{f}
 that defines the field.
@end itemize

@c ----------------------------------
@item @strong{TDGlobalForce}@*
@vindex @code{TDGlobalForce}@*
@emph{Section}: Time-Dependent@*
@emph{Type}: string@*
@* If this variable is set, a global time-dependent force will be
 applied to the ions in the x direction during a time-dependent
 run. This variable defines the base name of the force, that
 should be defined in the @t{TDFunctions} block. This force
 does not affect the electrons directly.



@c ----------------------------------
@item @strong{TDScissor}@*
@vindex @code{TDScissor}@*
@emph{Section}: Time-Dependent@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* (experimental) If set, a scissor operator will be applied in the
 Hamiltonian, shifting the excitation energies by the amount
 specified. By default, it is not applied.



@c ----------------------------------
@end itemize
@node Absorbing Boundaries,,,
@subsection Absorbing Boundaries
@c ----------------------------------

@itemize
@item @strong{ABCapHeight}@*
@vindex @code{ABCapHeight}@*
@emph{Section}: Time-Dependent::Absorbing Boundaries@*
@emph{Type}: float@*
@emph{Default}: -0.2 a.u.@*
@* When @t{AbsorbingBoundaries = cap}, this is the height of the imaginary potential.



@c ----------------------------------
@item @strong{ABShape}@*
@vindex @code{ABShape}@*
@emph{Section}: Time-Dependent::Absorbing Boundaries@*
@emph{Type}: block@*
@* Set the shape of the absorbing boundaries. Here you can set the inner
 and outer bounds by setting the block as follows:

 @t{%ABShape
 @*@ @  inner | outer | "user-defined"
 @*%}

 The optional 3rd column is a user-defined expression for the absorbing
 boundaries. For example, \(r\) creates a spherical absorbing zone for
 coordinates with \({\tt inner} < r < {\tt outer}\), and \(z\) creates an
 absorbing plane.
 Note, values @t{outer} larger than the box size may lead in these cases to
 unexpected reflection behaviours.
 If no expression is given, the absorbing zone follows the edges of the
 box (not valid for user-defined box).



@c ----------------------------------
@item @strong{ABWidth}@*
@vindex @code{ABWidth}@*
@emph{Section}: Time-Dependent::Absorbing Boundaries@*
@emph{Type}: float@*
@* Specifies the boundary width. For a finer control over the absorbing boundary
 shape use ABShape.



@c ----------------------------------
@item @strong{AbsorbingBoundaries}@*
@vindex @code{AbsorbingBoundaries}@*
@emph{Section}: Time-Dependent::Absorbing Boundaries@*
@emph{Type}: flag@*
@emph{Default}: not_absorbing@*
@* To improve the quality of the spectra by avoiding the formation of
 standing density waves, one can make the boundaries of the simulation
 box absorbing and use exterior complex scaling.


@emph{Options}:
@itemize @minus
@item @strong{not_absorbing}:  Reflecting boundaries.
@item @strong{mask}:  Absorbing boundaries with a mask function.
@item @strong{cap}:  Absorbing boundaries with a complex absorbing potential.
@item @strong{exterior}:  Exterior complex scaling (not yet implemented).
@end itemize

@c ----------------------------------
@item @strong{MaxwellABPMLPower}@*
@vindex @code{MaxwellABPMLPower}@*
@emph{Section}: Time-Dependent::Absorbing Boundaries@*
@emph{Type}: float@*
@emph{Default}: 3.5@*
@* Exponential of the polynomial profile for the non-physical conductivity of the PML.
 Should be between 2 and 4



@c ----------------------------------
@item @strong{MaxwellABPMLReflectionError}@*
@vindex @code{MaxwellABPMLReflectionError}@*
@emph{Section}: Time-Dependent::Absorbing Boundaries@*
@emph{Type}: float@*
@emph{Default}: 1.0e-16@*
@* Tolerated reflection error for the PML



@c ----------------------------------
@item @strong{MaxwellABWidth}@*
@vindex @code{MaxwellABWidth}@*
@emph{Section}: Time-Dependent::Absorbing Boundaries@*
@emph{Type}: float@*
@* Width of the region used to apply the absorbing boundaries. The default value is twice
 the derivative order.



@c ----------------------------------
@item @strong{MediumElectricSigma}@*
@vindex @code{MediumElectricSigma}@*
@emph{Section}: Time-Dependent::Absorbing Boundaries@*
@emph{Type}: float@*
@emph{Default}: 0.@*
@* Electric conductivity of the linear medium.



@c ----------------------------------
@item @strong{MediumEpsilonFactor}@*
@vindex @code{MediumEpsilonFactor}@*
@emph{Section}: Time-Dependent::Absorbing Boundaries@*
@emph{Type}: float@*
@emph{Default}: 1.0.@*
@* Linear medium electric susceptibility.



@c ----------------------------------
@item @strong{MediumMagneticSigma}@*
@vindex @code{MediumMagneticSigma}@*
@emph{Section}: Time-Dependent::Absorbing Boundaries@*
@emph{Type}: float@*
@emph{Default}: 0.@*
@* Magnetic conductivity of the linear medium.



@c ----------------------------------
@item @strong{MediumMuFactor}@*
@vindex @code{MediumMuFactor}@*
@emph{Section}: Time-Dependent::Absorbing Boundaries@*
@emph{Type}: float@*
@emph{Default}: 1.0@*
@* Linear medium magnetic susceptibility.



@c ----------------------------------
@item @strong{MediumWidth}@*
@vindex @code{MediumWidth}@*
@emph{Section}: Time-Dependent::Absorbing Boundaries@*
@emph{Type}: float@*
@emph{Default}: 0.0 a.u.@*
@* Width of the boundary region with medium



@c ----------------------------------
@end itemize
@node PhotoElectronSpectrum,,,
@subsection PhotoElectronSpectrum
@c ----------------------------------

@itemize
@item @strong{PESMask2PEnlargeFactor}@*
@vindex @code{PESMask2PEnlargeFactor}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: float@*
@emph{Default}: 1.0@*
@* Mask two points enlargement factor. Enlarges the mask box by adding two
 points at the edges of the box in each direction (x,y,z) at a distance
 L=Lb*@t{PESMask2PEnlargeFactor} where @emph{Lb} is the box size.
 This allows to run simulations with an additional void space at a price of
 adding few points. The Fourier space associated with the new box is restricted
 by the same factor.

 Note: needs @t{ PESMaskPlaneWaveProjection = nfft_map or pnfft_map }.



@c ----------------------------------
@item @strong{PESMaskEnlargeFactor}@*
@vindex @code{PESMaskEnlargeFactor}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: float@*
@emph{Default}: 1@*
@* Mask box enlargement level. Enlarges the mask bounding box by a @t{PESMaskEnlargeFactor}.
 This helps to avoid wavefunction wrapping at the boundaries.



@c ----------------------------------
@item @strong{PESMaskFilterCutOff}@*
@vindex @code{PESMaskFilterCutOff}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: float@*
@emph{Default}: -1@*
@* In calculation with @t{PESMaskMode = fullmask_mode} and NFFT, spurious frequencies
 may lead to numerical instability of the algorithm. This option gives the possibility
 to filter out the unwanted components by setting an energy cut-off.
 If @t{PESMaskFilterCutOff = -1} no filter is applied.



@c ----------------------------------
@item @strong{PESMaskIncludePsiA}@*
@vindex @code{PESMaskIncludePsiA}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* Add the contribution of \(\Psi_A\) in the mask region to the photo-electron spectrum.
 Literally adds the Fourier components of:
 \(\Theta(r-R1) \Psi_A(r)\)
 with \(\Theta\) being the Heaviside step function.
 With this option PES will contain all the contributions starting from the inner
 radius \(R1\). Use this option to improve convergence with respect to the box size
 and total simulation time.
 Note: Carefully choose \(R1\) in order to avoid contributions from returning electrons.



@c ----------------------------------
@item @strong{PESMaskMode}@*
@vindex @code{PESMaskMode}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: integer@*
@emph{Default}: mask_mode@*
@* PES calculation mode.


@emph{Options}:
@itemize @minus
@item @strong{mask_mode}:  Mask method.
@item @strong{fullmask_mode}:  Full mask method. This includes a back action of the momentum-space states on the
 interaction region. This enables electrons to come back from the continuum.
@item @strong{passive_mode}:  Passive analysis of the wf. Simply analyze the plane-wave components of the
 wavefunctions on the region @emph{r} > @emph{R1}. This mode employs a step masking function by default.
@end itemize

@c ----------------------------------
@item @strong{PESMaskPlaneWaveProjection}@*
@vindex @code{PESMaskPlaneWaveProjection}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: integer@*
@emph{Default}: fft_map@*
@* With the mask method, wavefunctions in the continuum are treated as plane waves.
 This variable sets how to calculate the plane-wave projection in the buffer
 region. We perform discrete Fourier transforms (DFT) in order to approximate
 a continuous Fourier transform. The major drawback of this approach is the built-in
 periodic boundary condition of DFT. Choosing an appropriate plane-wave projection
 for a given simulation in addition to @t{PESMaskEnlargeFactor} and
 @t{PESMask2PEnlargeFactor}will help to converge the results.

 NOTE: depending on the value of @t{PESMaskMode} @t{PESMaskPlaneWaveProjection},
 may affect not only performance but also the time evolution of the density.


@emph{Options}:
@itemize @minus
@item @strong{fft_out}:  FFT filtered in order to keep only outgoing waves. 1D only.
@item @strong{fft_map}:  FFT transform.
@item @strong{nfft_map}:  Non-equispaced FFT map.
@item @strong{pfft_map}:  Use PFFT library.
@item @strong{pnfft_map}:  Use PNFFT library.
@end itemize

@c ----------------------------------
@item @strong{PESMaskShape}@*
@vindex @code{PESMaskShape}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: integer@*
@emph{Default}: m_sin2@*
@* The mask function shape.


@emph{Options}:
@itemize @minus
@item @strong{m_sin2}:  sin2 mask.
@end itemize

@c ----------------------------------
@item @strong{PESMaskSize}@*
@vindex @code{PESMaskSize}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: block@*
@* Set the size of the mask function.
 Here you can set the inner (R1) and outer (R2) radius by setting
 the block as follows:

 @t{%PESMaskSize
 @*@ @  R1 | R2 | "user-defined"
 @*%}

 The optional 3rd column is a user-defined expression for the mask
 function. For example, @emph{r} creates a spherical mask (which is the
 default for @t{BoxShape = sphere}). Note, values R2 larger than
 the box size may lead in this case to unexpected reflection
 behaviours.



@c ----------------------------------
@item @strong{PESMaskSpectEnergyMax}@*
@vindex @code{PESMaskSpectEnergyMax}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: float@*
@emph{Default}: maxval(mask%Lk)\(^2/2\)@*
@* The maximum energy for the PES spectrum.



@c ----------------------------------
@item @strong{PESMaskSpectEnergyStep}@*
@vindex @code{PESMaskSpectEnergyStep}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: float@*
@* The PES spectrum energy step.



@c ----------------------------------
@item @strong{PESMaskStartTime}@*
@vindex @code{PESMaskStartTime}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: float@*
@emph{Default}: -1.0@*
@* The time photoelectrons start to be recorded. In pump-probe simulations, this allows
 getting rid of an unwanted ionization signal coming from the pump.
 NOTE: This will enforce the mask boundary conditions for all times.



@c ----------------------------------
@item @strong{PES_Flux_ARPES_grid}@*
@vindex @code{PES_Flux_ARPES_grid}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: logical@*
@* Use a curvilinear momentum space grid that compensates the transformation
 used to obtain ARPES. With this choice ARPES data is laid out on a Cartesian
 regular grid.
 By default true when @t{PES_Flux_Shape = pln} and a @t{KPointsPath}
 is specified.



@c ----------------------------------
@item @strong{PES_Flux_AnisotropyCorrection}@*
@vindex @code{PES_Flux_AnisotropyCorrection}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: logical@*
@* Apply anisotropy correction.




@c ----------------------------------
@item @strong{PES_Flux_DeltaK}@*
@vindex @code{PES_Flux_DeltaK}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: float@*
@emph{Default}: 0.02@*
@* Spacing of the the photoelectron momentum grid.



@c ----------------------------------
@item @strong{PES_Flux_EnergyGrid}@*
@vindex @code{PES_Flux_EnergyGrid}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: block@*
@* The block @t{PES_Flux_EnergyGrid} specifies the energy grid
 in momentum space.
 @t{@*%PES_Flux_EnergyGrid
 @*@ @  Emin | Emax | DeltaE
 @*%}



@c ----------------------------------
@item @strong{PES_Flux_Face_Dens}@*
@vindex @code{PES_Flux_Face_Dens}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: block@*
@* Define the number of points density per unit of area (in au) on the
 face of the 'cub' surface.



@c ----------------------------------
@item @strong{PES_Flux_GridTransformMatrix}@*
@vindex @code{PES_Flux_GridTransformMatrix}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: block@*
@* Define an optional transformation matrix for the momentum grid.

 @t{%PES_Flux_GridTransformMatrix
 @*@ @  M_11 | M_12  | M_13
 @*@ @  M_21 | M_22  | M_23
 @*@ @  M_31 | M_32  | M_33
 @*%
 }



@c ----------------------------------
@item @strong{PES_Flux_Kmax}@*
@vindex @code{PES_Flux_Kmax}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: float@*
@emph{Default}: 1.0@*
@* The maximum value of the photoelectron momentum.
 For cartesian momentum grids one can specify a value different
 for cartesian direction using a block input.



@c ----------------------------------
@item @strong{PES_Flux_Kmin}@*
@vindex @code{PES_Flux_Kmin}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* The minimum value of the photoelectron momentum.
 For cartesian momentum grids one can specify a value different
 for cartesian direction using a block input.



@c ----------------------------------
@item @strong{PES_Flux_Lmax}@*
@vindex @code{PES_Flux_Lmax}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: integer@*
@emph{Default}: 80@*
@* Maximum order of the spherical harmonic to be integrated on an equidistant spherical
 grid (to be changed to Gauss-Legendre quadrature).



@c ----------------------------------
@item @strong{PES_Flux_Lsize}@*
@vindex @code{PES_Flux_Lsize}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: block@*
@* For @t{PES_Flux_Shape = cub} sets the dimensions along each direction. The syntax is:

 @t{%PES_Flux_Lsize
 @*@ @ xsize | ysize | zsize
 @*%
 }

 where @t{xsize}, @t{ysize}, and @t{zsize} are with respect to the origin. The surface can
 be shifted with @t{PES_Flux_Offset}.
 If @t{PES_Flux_Shape = pln}, specifies the position of two planes perpendicular to
 the non-periodic dimension symmetrically placed at @t{PES_Flux_Lsize} distance from
 the origin.



@c ----------------------------------
@item @strong{PES_Flux_Momenutum_Grid}@*
@vindex @code{PES_Flux_Momenutum_Grid}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: integer@*
@* Decides how the grid in momentum space is generated.


@emph{Options}:
@itemize @minus
@item @strong{polar}:  The grid is in polar coordinates with the zenith axis is along z.
 The grid parameters are defined by PES_Flux_Kmax, PES_Flux_DeltaK,
 PES_Flux_StepsThetaK, PES_Flux_StepsPhiK.
 This is the default choice for PES_Flux_Shape = sph or cub.
@item @strong{cartesian}:  The grid is in cartesian coordinates with parameters defined by
 PES_Flux_ARPES_grid, PES_Flux_EnergyGrid.
 This is the default choice for PES_Flux_Shape = sph or cub.
@end itemize

@c ----------------------------------
@item @strong{PES_Flux_Offset}@*
@vindex @code{PES_Flux_Offset}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: block@*
@* Shifts the surface for @t{PES_Flux_Shape = cub}. The syntax is:

 @t{%PES_Flux_Offset
 @*@ @ xshift | yshift | zshift
 @*%
 }



@c ----------------------------------
@item @strong{PES_Flux_Parallelization}@*
@vindex @code{PES_Flux_Parallelization}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: flag@*
@* The parallelization strategy to be used to calculate the PES spectrum
 using the resources available in the domain parallelization pool.
 This option is not available without domain parallelization.
 Parallelization over k-points and states is always enabled when available.


@emph{Options}:
@itemize @minus
@item @strong{pf_none}:  No parallelization.
@item @strong{pf_time}:  Parallelize time integration. This requires to store some quantities over a
 number of time steps equal to the number of cores available.
@item @strong{pf_momentum}:  Parallelize over the final momentum grid. This strategy has a much lower
 memory footprint than the one above (time) but seems to provide a smaller
 speedup.
@item @strong{pf_surface}:  Parallelize over surface points.


 Option pf_time and pf_surface can be combined: pf_time + pf_surface.

@end itemize

@c ----------------------------------
@item @strong{PES_Flux_PhiK}@*
@vindex @code{PES_Flux_PhiK}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: block@*
@* Define the grid points on theta (\(0 \le \theta \le 2\pi\)) when
 using a spherical grid in momentum.
 The block defines the maximum and minimum values of theta and the number of
 of points for the discretization.

 @t{%PES_Flux_PhiK
 @*@ @  theta_min | theta_max  | npoints
 @*%
 }

 By default theta_min=0, theta_max = pi, npoints = 90.



@c ----------------------------------
@item @strong{PES_Flux_Radius}@*
@vindex @code{PES_Flux_Radius}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: float@*
@* The radius of the sphere, if @t{PES_Flux_Shape == sph}.



@c ----------------------------------
@item @strong{PES_Flux_RuntimeOutput}@*
@vindex @code{PES_Flux_RuntimeOutput}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: logical@*
@* Write output in ascii format at runtime.




@c ----------------------------------
@item @strong{PES_Flux_Shape}@*
@vindex @code{PES_Flux_Shape}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: integer@*
@* The shape of the surface.


@emph{Options}:
@itemize @minus
@item @strong{cub}:  Uses a parallelepiped as surface. All surface points are grid points.
 Choose the location of the surface with variable @t{PES_Flux_Lsize}
 (default for 1D and 2D).
@item @strong{sph}:  Constructs a sphere with radius @t{PES_Flux_Radius}. Points on the sphere
 are interpolated by trilinear interpolation (default for 3D).
@item @strong{pln}:  This option is for periodic systems.
 Constructs a plane perpendicular to the non-periodic dimension
 at @t{PES_Flux_Lsize}.
@end itemize

@c ----------------------------------
@item @strong{PES_Flux_StepsPhiK}@*
@vindex @code{PES_Flux_StepsPhiK}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: integer@*
@emph{Default}: 90@*
@* Number of steps in \(\phi\) (\(0 \le \phi \le 2 \pi\)) for the spherical grid in k.



@c ----------------------------------
@item @strong{PES_Flux_StepsPhiR}@*
@vindex @code{PES_Flux_StepsPhiR}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: integer@*
@* Number of steps in \(\phi\) (\(0 \le \phi \le 2 \pi\)) for the spherical surface.



@c ----------------------------------
@item @strong{PES_Flux_StepsThetaK}@*
@vindex @code{PES_Flux_StepsThetaK}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: integer@*
@emph{Default}: 45@*
@* Number of steps in \(\theta\) (\(0 \le \theta \le \pi\)) for the spherical grid in k.



@c ----------------------------------
@item @strong{PES_Flux_StepsThetaR}@*
@vindex @code{PES_Flux_StepsThetaR}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: integer@*
@* Number of steps in \(\theta\) (\(0 \le \theta \le \pi\)) for the spherical surface.



@c ----------------------------------
@item @strong{PES_Flux_ThetaK}@*
@vindex @code{PES_Flux_ThetaK}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: block@*
@* Define the grid points on theta (\(0 \le \theta \le \pi\)) when
 using a spherical grid in momentum.
 The block defines the maximum and minimum values of theta and the number of
 of points for the discretization.

 @t{%PES_Flux_ThetaK
 @*@ @  theta_min | theta_max  | npoints
 @*%
 }

 By default theta_min=0, theta_max = pi, npoints = 45.



@c ----------------------------------
@item @strong{PES_Flux_UseSymmetries}@*
@vindex @code{PES_Flux_UseSymmetries}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: logical@*
@* Use surface and momentum grid symmetries to speed up calculation and
 lower memory footprint.
 By default available only when the surface shape matches the grid symmetry i.e.:
 PES_Flux_Shape = m_cub or m_pln and PES_Flux_Momenutum_Grid = m_cartesian
 or
 PES_Flux_Shape = m_sph and PES_Flux_Momenutum_Grid = m_polar



@c ----------------------------------
@item @strong{PES_spm_DeltaOmega}@*
@vindex @code{PES_spm_DeltaOmega}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: float@*
@* The spacing in frequency domain for the photoelectron spectrum (if @t{PES_spm_OmegaMax > 0}).
 The default is @t{PES_spm_OmegaMax/500}.



@c ----------------------------------
@item @strong{PES_spm_OmegaMax}@*
@vindex @code{PES_spm_OmegaMax}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* If @t{PES_spm_OmegaMax > 0}, the photoelectron spectrum is directly calculated during
 time-propagation, evaluated by the PES_spm method. @t{PES_spm_OmegaMax} is then the maximum frequency
 (approximate kinetic energy) and @t{PES_spm_DeltaOmega} the spacing in frequency domain of the spectrum.



@c ----------------------------------
@item @strong{PES_spm_Radius}@*
@vindex @code{PES_spm_Radius}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: float@*
@* The radius of the sphere for the spherical grid (if no @t{PES_spm_points}
 are given).



@c ----------------------------------
@item @strong{PES_spm_StepsPhiR}@*
@vindex @code{PES_spm_StepsPhiR}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: integer@*
@emph{Default}: 90@*
@* Number of steps in \(\phi\) (\(0 \le \phi \le 2 \pi\)) for the spherical grid (if no
 @t{PES_spm_points} are given).



@c ----------------------------------
@item @strong{PES_spm_StepsThetaR}@*
@vindex @code{PES_spm_StepsThetaR}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: integer@*
@emph{Default}: 45@*
@* Number of steps in \(\theta\) (\(0 \le \theta \le \pi\)) for the spherical grid (if no
 @t{PES_spm_points} are given).



@c ----------------------------------
@item @strong{PES_spm_points}@*
@vindex @code{PES_spm_points}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: block@*
@* List of points at which to calculate the photoelectron spectrum by the sample point
 method. If no points are given, a spherical grid is generated automatically.
 The exact syntax is:

 @t{%PES_spm_points
 @*@ @ x1 | y1 | z1
 @*%
 }



@c ----------------------------------
@item @strong{PES_spm_recipe}@*
@vindex @code{PES_spm_recipe}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: integer@*
@emph{Default}: phase@*
@* The type for calculating the photoelectron spectrum in the sample point method.


@emph{Options}:
@itemize @minus
@item @strong{raw}:  Calculate the photoelectron spectrum according to A. Pohl, P.-G. Reinhard, and
 E. Suraud, @emph{Phys. Rev. Lett.} @strong{84}, 5090 (2000).
@item @strong{phase}:  Calculate the photoelectron spectrum by including the Volkov phase (approximately), see
 P. M. Dinh, P. Romaniello, P.-G. Reinhard, and E. Suraud, @emph{Phys. Rev. A.} @strong{87}, 032514 (2013).
@end itemize

@c ----------------------------------
@item @strong{PhotoElectronSpectrum}@*
@vindex @code{PhotoElectronSpectrum}@*
@emph{Section}: Time-Dependent::PhotoElectronSpectrum@*
@emph{Type}: integer@*
@emph{Default}: none@*
@* This variable controls the method used for the calculation of
 the photoelectron spectrum. You can specify more than one value
 by giving them as a sum, for example:
 @t{PhotoElectronSpectrum = pes_spm + pes_mask}


@emph{Options}:
@itemize @minus
@item @strong{none}:  The photoelectron spectrum is not calculated. This is the default.
@item @strong{pes_spm}:  Store the wavefunctions at specific points in order to
 calculate the photoelectron spectrum at a point far in the box as proposed in
 A. Pohl, P.-G. Reinhard, and E. Suraud, @emph{Phys. Rev. Lett.} @strong{84}, 5090 (2000).
@item @strong{pes_mask}:  Calculate the photo-electron spectrum using the mask method.
 U. De Giovannini, D. Varsano, M. A. L. Marques, H. Appel, E. K. U. Gross, and A. Rubio,
 @emph{Phys. Rev. A} @strong{85}, 062515 (2012).
@item @strong{pes_flux}:  Calculate the photo-electron spectrum using the t-surff technique, @emph{i.e.},
 spectra are computed from the electron flux through a surface close to the absorbing
 boundaries of the box. (Experimental.)
 L. Tao and A. Scrinzi, @emph{New Journal of Physics} @strong{14}, 013021 (2012).
@end itemize

@c ----------------------------------
@end itemize
@node Propagation,,,
@subsection Propagation
@c ----------------------------------

@itemize
@item @strong{ArnoldiOrthogonalization}@*
@vindex @code{ArnoldiOrthogonalization}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: integer@*
@* The orthogonalization method used for the Arnoldi procedure.
 Only for TDExponentialMethod = lanczos.


@emph{Options}:
@itemize @minus
@item @strong{cgs}:  Classical Gram-Schmidt (CGS) orthogonalization.
 The algorithm is defined in Giraud et al., Computers and Mathematics with Applications 50, 1069 (2005).
@item @strong{drcgs}:  Classical Gram-Schmidt orthogonalization with double-step reorthogonalization.
 The algorithm is taken from Giraud et al., Computers and Mathematics with Applications 50, 1069 (2005).
 According to this reference, this is much more precise than CGS or MGS algorithms.
@end itemize

@c ----------------------------------
@item @strong{InteractionTiming}@*
@vindex @code{InteractionTiming}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: integer@*
@emph{Default}: timing_exact@*
@* A parameter to determine if interactions should use the quantities
 at the exact time or if retardation is allowed.


@emph{Options}:
@itemize @minus
@item @strong{timing_exact}:  Only allow interactions at exactly the same times
@item @strong{timing_retarded}:  Allow retarded interactions
@end itemize

@c ----------------------------------
@item @strong{IonsConstantVelocity}@*
@vindex @code{IonsConstantVelocity}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* (Experimental) If this variable is set to yes, the ions will
 move with a constant velocity given by the initial
 conditions. They will not be affected by any forces.



@c ----------------------------------
@item @strong{IonsTimeDependentDisplacements}@*
@vindex @code{IonsTimeDependentDisplacements}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: block@*
@* (Experimental) This variable allows you to specify a
 time-dependent function describing the displacement of the ions
 from their equilibrium position: \(r(t) = r_0 + \Delta
 r(t)\).  Specify the displacements dx(t), dy(t), dz(t) as
 follows, for some or all of the atoms:

 @t{%IonsTimeDependentDisplacements
 @*@ @  atom_index | "dx(t)" | "dy(t)" | "dz(t)"
 @*%}

 The displacement functions are time-dependent functions and should match one
 of the function names given in the first column of the @t{TDFunctions} block.
 If this block is set, the ions will not be affected by any forces.



@c ----------------------------------
@item @strong{MaxwellAbsorbingBoundaries}@*
@vindex @code{MaxwellAbsorbingBoundaries}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: block@*
@* Type of absorbing boundaries used for Maxwell propagation in each direction.

 Example:

 @t{%MaxwellAbsorbingBoundaries
 @*@ @    cpml | cpml | cpml
 @*%}



@emph{Options}:
@itemize @minus
@item @strong{not_absorbing}:  No absorbing boundaries.
@item @strong{mask}:  A mask equal to the wavefunctions mask is applied to the Maxwell states at the boundaries
@item @strong{cpml}:  Perfectly matched layer absorbing boundary
@item @strong{mask_zero}:  Absorbing boundary region is set to zero
@end itemize

@c ----------------------------------
@item @strong{MaxwellBoundaryConditions}@*
@vindex @code{MaxwellBoundaryConditions}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: block@*
@* Defines boundary conditions for the electromagnetic field propagation.

 Example:

 @t{%MaxwellBoundaryConditions
 @*@ @    zero | mirror_pec | consant
 @*%}




@emph{Options}:
@itemize @minus
@item @strong{zero}:  Boundaries are set to zero.
@item @strong{constant}:  Boundaries are set to a constant.
@item @strong{mirror_pec}:  Perfect electric conductor.
@item @strong{mirror_pmc}:  Perfect magnetic conductor.
@item @strong{plane_waves}:  Boundaries feed in plane waves.
@item @strong{periodic}:  Periodic boundary conditions (not yet implemented).
@item @strong{medium}:  Boundaries as linear medium (not yet implemented).
@end itemize

@c ----------------------------------
@item @strong{MaxwellTDETRSApprox}@*
@vindex @code{MaxwellTDETRSApprox}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: integer@*
@emph{Default}: no@*
@* Whether to perform  aproximations to the ETRS propagator.


@emph{Options}:
@itemize @minus
@item @strong{no}:  No approximations.
@item @strong{const_steps}:  Use constant current density.
@end itemize

@c ----------------------------------
@item @strong{MaxwellTDOperatorMethod}@*
@vindex @code{MaxwellTDOperatorMethod}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: integer@*
@emph{Default}: op_fd@*
@* The Maxwell Operator e.g. the curl operation can be obtained by
 two different methods, the finid-difference or the fast fourier
 transform.


@emph{Options}:
@itemize @minus
@item @strong{op_fd}:  Maxwell operator calculated by finite differnce method
@item @strong{op_fft}:  Maxwell operator calculated by fast fourier transform
@end itemize

@c ----------------------------------
@item @strong{MaxwellTDSCFThreshold}@*
@vindex @code{MaxwellTDSCFThreshold}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: float@*
@emph{Default}: 1.0e-6@*
@* Since the Maxwell-KS propagator is non-linear, each propagation step
 should be performed self-consistently.  In practice, for most
 purposes this is not necessary, except perhaps in the first
 iterations. This variable holds the number of propagation steps
 for which the propagation is done self-consistently.

 This variable controls the accuracy threshold for the self consistency.



@c ----------------------------------
@item @strong{MoveIons}@*
@vindex @code{MoveIons}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: logical@*
@* This variable controls whether atoms are moved during a time
 propagation run. The default is yes when the ion velocity is
 set explicitly or implicitly, otherwise is no.



@c ----------------------------------
@item @strong{RecalculateGSDuringEvolution}@*
@vindex @code{RecalculateGSDuringEvolution}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* In order to calculate some information about the system along the
 evolution (e.g. projection onto the ground-state KS determinant,
 projection of the TDKS spin-orbitals onto the ground-state KS
 spin-orbitals), the ground-state KS orbitals are needed. If the
 ionic potential changes -- that is, the ions move -- one may want
 to recalculate the ground state. You may do this by setting this
 variable.

 The recalculation is not done every time step, but only every
 @t{RestartWriteInterval} time steps.



@c ----------------------------------
@item @strong{TDDynamics}@*
@vindex @code{TDDynamics}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: integer@*
@emph{Default}: ehrenfest@*
@* Type of dynamics to follow during a time propagation.
 For BO, you must set @t{MoveIons = yes}.


@emph{Options}:
@itemize @minus
@item @strong{ehrenfest}:  Ehrenfest dynamics.
@item @strong{bo}:  Born-Oppenheimer (Experimental).
@end itemize

@c ----------------------------------
@item @strong{TDEnergyUpdateIter}@*
@vindex @code{TDEnergyUpdateIter}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: integer@*
@* This variable controls after how many iterations Octopus
 updates the total energy during a time-propagation run. For
 iterations where the energy is not updated, the last calculated
 value is reported. If you set this variable to 1, the energy
 will be calculated in each step.



@c ----------------------------------
@item @strong{TDExpOrder}@*
@vindex @code{TDExpOrder}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: integer@*
@emph{Default}: 4@*
@* For @t{TDExponentialMethod} = @t{standard} or @t{chebyshev},
 the order to which the exponential is expanded. For the Lanczos approximation,
 it is the Lanczos-subspace dimension.



@c ----------------------------------
@item @strong{TDExponentialMethod}@*
@vindex @code{TDExponentialMethod}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: integer@*
@emph{Default}: taylor@*
@* Method used to numerically calculate the exponential of the Hamiltonian,
 a core part of the full algorithm used to approximate the evolution
 operator, specified through the variable @t{TDPropagator}.
 In the case of using the Magnus method, described below, the action of the exponential
 of the Magnus operator is also calculated through the algorithm specified
 by this variable.


@emph{Options}:
@itemize @minus
@item @strong{lanczos}:  Allows for larger time-steps.
 However, the larger the time-step, the longer the computational time per time-step.
 In certain cases, if the time-step is too large, the code will emit a warning
 whenever it considers that the evolution may not be properly proceeding --
 the Lanczos process did not converge. The method consists in a Krylov
 subspace approximation of the action of the exponential
 (see M. Hochbruck and C. Lubich, @emph{SIAM J. Numer. Anal.} @strong{34}, 1911 (1997) for details).
 Two more variables control the performance of the method: the maximum dimension
 of this subspace (controlled by variable @t{TDExpOrder}), and
 the stopping criterion (controlled by variable @t{TDLanczosTol}).
 The smaller the stopping criterion, the more precisely the exponential
 is calculated, but also the larger the dimension of the Arnoldi
 subspace. If the maximum dimension allowed by @t{TDExpOrder} is not
 enough to meet the criterion, the above-mentioned warning is emitted.
@item @strong{taylor}:  This method amounts to a straightforward application of the definition of
 the exponential of an operator, in terms of its Taylor expansion.

 \(\exp_{\rm STD} (-i\delta t H) = \sum_{i=0}^{k} {(-i\delta t)^i\over{i!}} H^i.\)

 The order @emph{k} is determined by variable @t{TDExpOrder}.
 Some numerical considerations from <a href=http://www.phys.washington.edu/~bertsch/num3.ps>
 Jeff Giansiracusa and George F. Bertsch</a>
 suggest the 4th order as especially suitable and stable.
@item @strong{chebyshev}:  In principle, the Chebyshev expansion
 of the exponential represents it more accurately than the canonical or standard expansion.
 As in the latter case, @t{TDExpOrder} determines the order of the expansion.

 There exists a closed analytic form for the coefficients of the exponential in terms
 of Chebyshev polynomials:

 \(\exp_{\rm CHEB} \left( -i\delta t H \right) = \sum_{k=0}^{\infty} (2-\delta_{k0})(-i)^{k}J_k(\delta t) T_k(H),\)

 where \(J_k\) are the Bessel functions of the first kind, and H has to be previously
 scaled to \([-1,1]\).
 See H. Tal-Ezer and R. Kosloff, @emph{J. Chem. Phys.} @strong{81},
 3967 (1984); R. Kosloff, @emph{Annu. Rev. Phys. Chem.} @strong{45}, 145 (1994);
 C. W. Clenshaw, @emph{MTAC} @strong{9}, 118 (1955).
@end itemize

@c ----------------------------------
@item @strong{TDIonicTimeScale}@*
@vindex @code{TDIonicTimeScale}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: float@*
@emph{Default}: 1.0@*
@* This variable defines the factor between the timescale of ionic
 and electronic movement. It allows reasonably fast
 Born-Oppenheimer molecular-dynamics simulations based on
 Ehrenfest dynamics. The value of this variable is equivalent to
 the role of \(\mu\) in Car-Parrinello. Increasing it
 linearly accelerates the time step of the ion
 dynamics, but also increases the deviation of the system from the
 Born-Oppenheimer surface. The default is 1, which means that both
 timescales are the same. Note that a value different than 1
 implies that the electrons will not follow physical behaviour.

 According to our tests, values around 10 are reasonable, but it
 will depend on your system, mainly on the width of the gap.

 Important: The electronic time step will be the value of
 @t{TDTimeStep} divided by this variable, so if you have determined an
 optimal electronic time step (that we can call @emph{dte}), it is
 recommended that you define your time step as:

 @t{TDTimeStep} = @emph{dte} * @t{TDIonicTimeScale}

 so you will always use the optimal electronic time step
 (<a href=http://arxiv.org/abs/0710.3321>more details</a>).



@c ----------------------------------
@item @strong{TDLanczosTol}@*
@vindex @code{TDLanczosTol}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: float@*
@emph{Default}: 1e-5@*
@* An internal tolerance variable for the Lanczos method. The smaller, the more
 precisely the exponential is calculated, and also the bigger the dimension
 of the Krylov subspace needed to perform the algorithm. One should carefully
 make sure that this value is not too big, or else the evolution will be
 wrong.



@c ----------------------------------
@item @strong{TDMaxSteps}@*
@vindex @code{TDMaxSteps}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: integer@*
@emph{Default}: 1500@*
@* Number of time-propagation steps that will be performed. You
 cannot use this variable together with @t{TDPropagationTime}.



@c ----------------------------------
@item @strong{TDPhotonicTimeScale}@*
@vindex @code{TDPhotonicTimeScale}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: float@*
@emph{Default}: 1.0@*
@* This variable defines the factor between the timescale of photonic
 and electronic movement.
 for more details see the documentation of TDIonicTimeScale
 If you also use TDIonicTimeScale, we advise to set
 TDPhotonicTimeScale = TDIonicTimeScale, in the case the
 photon frequency is in a vibrational energy range.
 Important: The electronic time step will be the value of
 @t{TDTimeStep} divided by this variable, so if you have determined an
 optimal electronic time step (that we can call @emph{dte}), it is
 recommended that you define your time step as:

 @t{TDTimeStep} = @emph{dte} * @t{TDPhotonicTimeScale}

 so you will always use the optimal electronic time step
 (<a href=http://arxiv.org/abs/0710.3321>more details</a>).



@c ----------------------------------
@item @strong{TDPropagationTime}@*
@vindex @code{TDPropagationTime}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: float@*
@* The length of the time propagation. You cannot set this variable
 at the same time as @t{TDMaxSteps}. By default this variable will
 not be used.

 The units for this variable are \(\hbar\)/Hartree (or \(\hbar\)/eV if you
 selected @t{ev_angstrom} as input units). The approximate conversions to
 femtoseconds are 1 fs = 41.34 \(\hbar\)/Hartree = 1.52 \(\hbar\)/eV.



@c ----------------------------------
@item @strong{TDPropagator}@*
@vindex @code{TDPropagator}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: integer@*
@emph{Default}: etrs@*
@* This variable determines which algorithm will be used to approximate
 the evolution operator \(U(t+\delta t, t)\). That is, given
 \(\psi(\tau)\) and \(H(\tau)\) for \(\tau \le t\),
 calculate \(t+\delta t\). Note that in general the Hamiltonian
 is not known at times in the interior of the interval \([t,t+\delta t]\).
 This is due to the self-consistent nature of the time-dependent Kohn-Sham problem:
 the Hamiltonian at a given time \(\tau\) is built from the
 "solution" wavefunctions at that time.

 Some methods, however, do require the knowledge of the Hamiltonian at some
 point of the interval \([t,t+\delta t]\). This problem is solved by making
 use of extrapolation: given a number \(l\) of time steps previous to time
 \(t\), this information is used to build the Hamiltonian at arbitrary times
 within \([t,t+\delta t]\). To be fully precise, one should then proceed
 @emph{self-consistently}: the obtained Hamiltonian at time \(t+\delta t\)
 may then be used to interpolate the Hamiltonian, and repeat the evolution
 algorithm with this new information. Whenever iterating the procedure does
 not change the solution wavefunctions, the cycle is stopped. In practice,
 in @t{Octopus} we perform a second-order extrapolation without a
 self-consistency check, except for the first two iterations, where obviously
 the extrapolation is not reliable.

 The proliferation of methods is certainly excessive. The reason for it is that
 the propagation algorithm is currently a topic of active development. We
 hope that in the future the optimal schemes are clearly identified. In the
 mean time, if you do not feel like testing, use the default choices and
 make sure the time step is small enough.


@emph{Options}:
@itemize @minus
@item @strong{qoct_tddft_propagator}:  WARNING: EXPERIMENTAL
@item @strong{caetrs}:  (experimental) Corrected Approximated Enforced Time-Reversal
 Symmetry (AETRS), this is the previous propagator but including
 a correction step to the exponential.
@item @strong{runge_kutta4}:  WARNING: EXPERIMENTAL. Implicit Gauss-Legendre 4th order Runge-Kutta.
@item @strong{runge_kutta2}:  WARNING: EXPERIMENTAL. Implicit 2nd order Runge-Kutta (trapezoidal rule).
 Similar, but not identical, to Crank-Nicolson method.
@item @strong{expl_runge_kutta4}:  WARNING: EXPERIMENTAL. Explicit RK4 method.
@item @strong{cfmagnus4}:  WARNING EXPERIMENTAL
@item @strong{etrs}:  The idea is to make use of time-reversal symmetry from the beginning:

 \(
   \exp \left(-i\delta t H_{n} / 2 \right)\psi_n = \exp \left(i\delta t H_{n+1} / 2 \right)\psi_{n+1},
 \)

 and then invert to obtain:

 \(
   \psi_{n+1} = \exp \left(-i\delta t H_{n+1} / 2 \right) \exp \left(-i\delta t H_{n} / 2 \right)\psi_{n}.
 \)

 But we need to know \(H_{n+1}\), which can only be known exactly through the solution
 \(\psi_{n+1}\). What we do is to estimate it by performing a single exponential:
 \(\psi^{*}_{n+1}=\exp \left( -i\delta t H_{n} \right) \psi_n\), and then
 \(H_{n+1} = H[\psi^{*}_{n+1}]\). Thus no extrapolation is performed in this case.
@item @strong{aetrs}:  Approximated Enforced Time-Reversal Symmetry (AETRS).
 A modification of previous method to make it faster.
 It is based on extrapolation of the time-dependent potentials. It is faster
 by about 40%.
 The only difference is the procedure to estimate \(H_{n+1}\): in this case
 it is extrapolated via a second-order polynomial by making use of the
 Hamiltonian at time \(t-2\delta t\), \(t-\delta t\) and \(t\).
@item @strong{exp_mid}:  Exponential Midpoint Rule (EM).
 This is maybe the simplest method, but it is very well grounded theoretically:
 it is unitary (if the exponential is performed correctly) and preserves
 time-reversal symmetry (if the self-consistency problem is dealt with correctly).
 It is defined as:
 \(
   U_{\rm EM}(t+\delta t, t) = \exp \left( -i\delta t H_{t+\delta t/2}\right)\,.
 \)
@item @strong{crank_nicolson}:  Classical Crank-Nicolson propagator.
 \(
  (1 + i\delta t H_{n+1/2} / 2) \psi_{n+1} = (1 - i\delta t H_{n+1/2} / 2) \psi_{n}
 \)
@item @strong{crank_nicolson_sparskit}:  Classical Crank-Nicolson propagator. Requires the SPARSKIT library.
 \(
  (1 + i\delta t H_{n+1/2} / 2) \psi_{n+1} = (1 - i\delta t H_{n+1/2} / 2) \psi_{n}
 \)
@item @strong{magnus}:  Magnus Expansion (M4).
 This is the most sophisticated approach. It is a fourth-order scheme (a feature
 which it shares with the ST scheme; the other schemes are in principle second-order).
 It is tailored for making use of very large time steps, or equivalently,
 dealing with problem with very high-frequency time-dependence.
 It is still in a experimental state; we are not yet sure of when it is
 advantageous.
@end itemize

@c ----------------------------------
@item @strong{TDSCFThreshold}@*
@vindex @code{TDSCFThreshold}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: float@*
@emph{Default}: 1.0e-6@*
@* Since the KS propagator is non-linear, each propagation step
 should be performed self-consistently.  In practice, for most
 purposes this is not necessary, except perhaps in the first
 iterations. This variable holds the number of propagation steps
 for which the propagation is done self-consistently.

 The self consistency has to be measured against some accuracy
 threshold. This variable controls the value of that threshold.



@c ----------------------------------
@item @strong{TDStepsWithSelfConsistency}@*
@vindex @code{TDStepsWithSelfConsistency}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: integer@*
@* Since the KS propagator is non-linear, each propagation step
 should be performed self-consistently.  In practice, for most
 purposes this is not necessary, except perhaps in the first
 iterations. This variable holds the number of propagation steps
 for which the propagation is done self-consistently.

 The special value @t{all_steps} forces self-consistency to
 be imposed on all propagation steps. A value of 0 means that
 self-consistency will not be imposed.  The default is 0.


@emph{Options}:
@itemize @minus
@item @strong{all_steps}:  Self-consistency is imposed for all propagation steps.
@end itemize

@c ----------------------------------
@item @strong{TDSystemPropagator}@*
@vindex @code{TDSystemPropagator}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: integer@*
@emph{Default}: static@*
@* A variable to set the propagator in the multisystem framework.
 This is a temporary solution, and should be replaced by the
 TDPropagator variable.


@emph{Options}:
@itemize @minus
@item @strong{static}:  (Experimental) Do not propagate the system in time.
@item @strong{verlet}:  (Experimental) Verlet propagator.
@item @strong{beeman}:  (Experimental) Beeman propagator without predictor-corrector.
@item @strong{beeman_scf}:  (Experimental) Beeman propagator with predictor-corrector scheme.
@item @strong{exp_mid}:  (Experimental) Exponential midpoint propagator without predictor-corrector.
@item @strong{exp_mid_scf}:  (Experimental) Exponential midpoint propagator with predictor-corrector scheme.
@end itemize

@c ----------------------------------
@item @strong{TDTimeStep}@*
@vindex @code{TDTimeStep}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: float@*
@* The time-step for the time propagation. For most propagators you
 want to use the largest value that is possible without the
 evolution becoming unstable.

 The default value is the maximum value that we have found
 empirically that is stable for the spacing \(h\):
 \(dt = 0.0426 - 0.207 h + 0.808 h^2\)
 (from parabolic fit to Fig. 4 of http://dx.doi.org/10.1021/ct800518j,
 probably valid for 3D systems only).
 However, you might need to adjust this value.



@c ----------------------------------
@item @strong{TemperatureFunction}@*
@vindex @code{TemperatureFunction}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: integer@*
@emph{Default}: "temperature"@*
@* If a thermostat is used, this variable indicates the name of the
 function in the @t{TDFunctions} block that will be used to control the
 temperature. The values of the temperature are given in
 degrees Kelvin.



@c ----------------------------------
@item @strong{Thermostat}@*
@vindex @code{Thermostat}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: integer@*
@emph{Default}: none@*
@* This variable selects the type of thermostat applied to
 control the ionic temperature.


@emph{Options}:
@itemize @minus
@item @strong{none}:  No thermostat is applied. This is the default.
@item @strong{velocity_scaling}:  Velocities are scaled to control the temperature.
@item @strong{nose_hoover}:  Nose-Hoover thermostat.
@end itemize

@c ----------------------------------
@item @strong{ThermostatMass}@*
@vindex @code{ThermostatMass}@*
@emph{Section}: Time-Dependent::Propagation@*
@emph{Type}: float@*
@emph{Default}: 1.0@*
@* This variable sets the fictitious mass for the Nose-Hoover
 thermostat.



@c ----------------------------------
@end itemize
@node Response,,,
@subsection Response
@c ----------------------------------

@itemize
@item @strong{TDDeltaKickTime}@*
@vindex @code{TDDeltaKickTime}@*
@emph{Section}: Time-Dependent::Response@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* The delta-perturbation that can be applied by making use of the @t{TDDeltaStrength} variable,
 can be applied at the time given by this variable. Usually, this time is zero, since one wants
 to apply the delta pertubation or "kick" at a system at equilibrium, and no other time-dependent
 external potential is used. However, one may want to apply a kick on top of a laser field,
 for example.



@c ----------------------------------
@item @strong{TDDeltaStrength}@*
@vindex @code{TDDeltaStrength}@*
@emph{Section}: Time-Dependent::Response@*
@emph{Type}: float@*
@* When no laser is applied, a delta (in time) perturbation with
 strength @t{TDDeltaStrength} can be applied. This is used to
 calculate, @emph{e.g.}, the linear optical spectra. If the ions are
 allowed to move, the kick will affect them also.
 The electric field is \(-(\hbar k / e) \delta(t)\) for a dipole with
 zero wavevector, where @emph{k} = @t{TDDeltaStrength}, which causes
 the wavefunctions instantaneously to acquire a phase \(e^{ikx}\).
 The unit is inverse length.



@c ----------------------------------
@item @strong{TDDeltaStrengthMode}@*
@vindex @code{TDDeltaStrengthMode}@*
@emph{Section}: Time-Dependent::Response@*
@emph{Type}: integer@*
@emph{Default}: kick_density@*
@* When calculating the density response via real-time propagation,
 one needs to perform an initial kick on the KS system, at
 time zero. Depending on what kind of response property one wants to obtain,
 this kick may be done in several modes. For use to calculate triplet excitations,
 see MJT Oliveira, A Castro, MAL Marques, and A Rubio, @emph{J. Nanoscience and Nanotechnology} @strong{8}, 3392 (2008).


@emph{Options}:
@itemize @minus
@item @strong{kick_density}:  The total density of the system is perturbed. This mode is appropriate for
 electric dipole response, as for optical absorption.
@item @strong{kick_spin}:  The individual spin densities are perturbed oppositely. Note that this mode
 is only possible if the run is done in spin-polarized mode, or with spinors.
 This mode is appropriate for the paramagnetic dipole response, which can couple
 to triplet excitations.
@item @strong{kick_spin_and_density}:  A combination of the two above. Note that this mode
 is only possible if the run is done in spin-polarized mode, or with spinors.
 This mode is intended for use with symmetries to obtain both of the responses
 at once, at described in the reference above.
@item @strong{kick_magnon}:  Rotates the magnetization. Only works for spinors.
 Can be used in a supercell or my making use of the generalized Bloch theorem.
 In the later case (see @t{SpiralBoundaryConditions}) spin-orbit coupling cannot be used.
@end itemize

@c ----------------------------------
@item @strong{TDDeltaUserDefined}@*
@vindex @code{TDDeltaUserDefined}@*
@emph{Section}: Time-Dependent::Response@*
@emph{Type}: string@*
@* By default, the kick function will be a dipole. This will change if (1) the variable
 @t{TDDeltaUserDefined} is present in the inp file, or (2) if the block @t{TDKickFunction}
 is present in the @t{inp} file. If both are present in the @t{inp} file, the @t{TDKickFunction}
 block will be ignored. The value of @t{TDDeltaUserDefined} should be a string describing
 the function that is going to be used as delta perturbation.



@c ----------------------------------
@item @strong{TDKickFunction}@*
@vindex @code{TDKickFunction}@*
@emph{Section}: Time-Dependent::Response@*
@emph{Type}: block@*
@* If the block @t{TDKickFunction} is present in the input file, and the variable
 @t{TDDeltaUserDefined} is not present in the input file, the kick function to
 be applied at time zero of the time-propagation will not be a "dipole" function
 (@emph{i.e.} \(\phi \rightarrow e^{ikx} \phi\), but a general multipole in the form \(r^l Y_{lm}(r)\).

 Each line has three columns: integers @emph{l} and @emph{m} that defines the
 multipole, and a weight. Any number of lines may be given, and the kick will be the sum of those
 multipoles with the given weights.

 This feature allows calculation of quadrupole, octupole, etc., response functions.



@c ----------------------------------
@item @strong{TDMomentumTransfer}@*
@vindex @code{TDMomentumTransfer}@*
@emph{Section}: Time-Dependent::Response@*
@emph{Type}: block@*
@* Momentum-transfer vector for the calculation of the dynamic structure factor.
 When this variable is set, a non-dipole field is applied, and an output file
 @t{ftchd} is created (it contains the Fourier transform of the charge density
 at each time). The type of the applied external field can be set by
 an optional last number. Possible options are @t{qexp} (default), @t{qcos},
 @t{qsin}, or @t{qcos+qsin}. In the formulae below,
 \(\vec{q}\) is the momentum-transfer vector.


@emph{Options}:
@itemize @minus
@item @strong{qexp}:  External field is \(e^{i \vec{q} \cdot \vec{r}}\).
@item @strong{qcos}:  External field is \(\cos \left( i \vec{q} \cdot \vec{r} \right)\).
@item @strong{qsin}:  External field is \(\sin \left( i \vec{q} \cdot \vec{r} \right)\).
@item @strong{qbessel}:  External field is \(j_l \left( \vec{q} \cdot \vec{r} \right) Y_{lm} \left(\vec{r} \right)\).
 In this case, the block has to include two extra values (@emph{l} and @emph{m}).
@end itemize

@c ----------------------------------
@item @strong{TDMultipleMomentumTransfer}@*
@vindex @code{TDMultipleMomentumTransfer}@*
@emph{Section}: Time-Dependent::Response@*
@emph{Type}: block@*
@* For magnon kicks only.
 A simple way to specify momentum-transfer vectors for the calculation of
 the magnetization dynamics. This variable should be used for a supercell.
 For each reciprocal lattice vectors, the code will kick the original magnetization
 using all the multiples of it.
 The syntax reads:

 @t{%TDMultipleMomentumTransfer
 @*@ @ N_x | N_y | N_z
 @*%}

 and will include the (2N_x+1)*(2N_y+1)*(2N_z+1) multiples vectors of the reciprocal
 lattice vectors of the current cell.



@c ----------------------------------
@item @strong{TDReducedMomentumTransfer}@*
@vindex @code{TDReducedMomentumTransfer}@*
@emph{Section}: Time-Dependent::Response@*
@emph{Type}: block@*
@* The same as TDMomentumTransfer, but the momentum is specified in reduced coordinates.
 Only available for magnon kicks at the moment, and only with an exponential kick.



@c ----------------------------------
@end itemize
@node Dipole,,,
@subsubsection Dipole
@c ----------------------------------

@itemize
@item @strong{TDEasyAxis}@*
@vindex @code{TDEasyAxis}@*
@emph{Section}: Time-Dependent::Response::Dipole@*
@emph{Type}: block@*
@* For magnon kicks only.
 This variable defines the direction of the easy axis of the crystal.
 The magnetization is kicked in the plane transverse to this vector



@c ----------------------------------
@item @strong{TDPolarization}@*
@vindex @code{TDPolarization}@*
@emph{Section}: Time-Dependent::Response::Dipole@*
@emph{Type}: block@*
@* The (real) polarization of the delta electric field. Normally
 one needs three perpendicular polarization directions to calculate a
 spectrum (unless symmetry is used).
 The format of the block is:

 @t{%TDPolarization
 @*@ @ pol1x | pol1y | pol1z
 @*@ @ pol2x | pol2y | pol2z
 @*@ @ pol3x | pol3y | pol3z
 @*%}

 @t{Octopus} uses both this block and the variable
 @t{TDPolarizationDirection} to determine the polarization
 vector for the run. For example, if
 @t{TDPolarizationDirection=2} the polarization @t{(pol2x,
 pol2y, pol2z)} would be used.
 These directions may not be in periodic directions.

 The default value for @t{TDPolarization} is the three
 Cartesian unit vectors (1,0,0), (0,1,0), and (0,0,1).

 Note that the directions do not necessarily need to be perpendicular
 when symmetries are used.

 WARNING: If you want to obtain the cross-section tensor, the
 @t{TDPolarization} block must be exactly the same for the run in
 each direction. The direction must be selected by the
 @t{TDPolarizationDirection} variable.




@c ----------------------------------
@item @strong{TDPolarizationDirection}@*
@vindex @code{TDPolarizationDirection}@*
@emph{Section}: Time-Dependent::Response::Dipole@*
@emph{Type}: integer@*
@* When a delta potential is included in a time-dependent run, this
 variable defines in which direction the field will be applied
 by selecting one of the lines of @t{TDPolarization}. In a
 typical run (without using symmetry), the @t{TDPolarization} block
 would contain the three Cartesian unit vectors (the default
 value), and one would make 3 runs varying
 @t{TDPolarization} from 1 to 3.
 If one is using symmetry,  @t{TDPolarization} should run only from 1
 to @t{TDPolarizationEquivAxes}.



@c ----------------------------------
@item @strong{TDPolarizationEquivAxes}@*
@vindex @code{TDPolarizationEquivAxes}@*
@emph{Section}: Time-Dependent::Response::Dipole@*
@emph{Type}: integer@*
@* Defines how many of the @t{TDPolarization} axes are equivalent. This information is stored in a file and then
 used by @t{oct-propagation_spectrum} to rebuild the full polarizability tensor from just the
 first @t{TDPolarizationEquivAxes} directions. This variable is also used by @t{CalculationMode = vdw}.



@c ----------------------------------
@item @strong{TDPolarizationWprime}@*
@vindex @code{TDPolarizationWprime}@*
@emph{Section}: Time-Dependent::Response::Dipole@*
@emph{Type}: block@*
@* This block is needed only when
 @t{TDPolarizationEquivAxes} is set to 3.  In such a case,
 the three directions (@emph{pol1}, @emph{pol2}, and @emph{pol3}) defined in
 the @t{TDPolarization} block should be related by symmetry
 operations. If @emph{A} is the symmetry operation that takes you
 from @emph{pol1} to @emph{pol2}, then @t{TDPolarizationWprime}
 should be set to the direction defined by @emph{A}\(^{-1}\)@emph{pol3}.
 For more information see MJT Oliveira
 @emph{et al.}, @emph{J. Nanoscience and Nanotechnology} @strong{8},
 3392 (2008).



@c ----------------------------------
@end itemize
@node TD Output,,,
@subsection TD Output
@c ----------------------------------

@itemize
@item @strong{MaxwellTDOutput}@*
@vindex @code{MaxwellTDOutput}@*
@emph{Section}: Time-Dependent::TD Output@*
@emph{Type}: flag@*
@emph{Default}: maxwell_energy@*
@* Defines what should be output during the time-dependent
 Maxwell simulation. Many of the options can increase the computational
 cost of the simulation, so only use the ones that you need. In
 most cases the default value is enough, as it is adapted to the
 details of the TD run.
 WARNING: the calculation of the longitudinal or transverse E and B fields
 can be very expensive, so please consider using the MaxwellOutput block
 to calculate and output these quantities at certain timesteps.


@emph{Options}:
@itemize @minus
@item @strong{e_field_surface_y}:  Output of the E field sliced along the plane y=0 for each field component
@item @strong{b_field_surface_z}:  Output of the B field sliced along the plane z=0 for each field component
@item @strong{maxwell_total_e_field}:  Output of the total (longitudinal plus transverse) electric field at
 the points specified in the MaxwellFieldsCoordinate block
@item @strong{e_field_surface_z}:  Output of the E field sliced along the plane z=0 for each field component
@item @strong{maxwell_energy}:  Output of the electromagnetic field energy into the folder @t{td.general/maxwell}.
 WARNING: the transverse and longitudinal energies will be correct only if you request
 the longitudinal and transverse E or B fields as output. Otherwise they will be set to
 zero.
@item @strong{maxwell_transverse_b_field}:  Output of the transverse magnetic field at the points
 specified in the MaxwellFieldsCoordinate block  (can slow down the run)
@item @strong{maxwell_transverse_e_field}:  Output of the transverse electric field at the points
 specified in the MaxwellFieldsCoordinate block  (can slow down the run)
@item @strong{b_field_surface_x}:  Output of the B field sliced along the plane x=0 for each field component
@item @strong{maxwell_longitudinal_b_field}:  Output of the longitudinal magnetic field at the points
 specified in the MaxwellFieldsCoordinate block  (can slow down the run)
@item @strong{e_field_surface_x}:  Output of the E field sliced along the plane x=0 for each field component
@item @strong{maxwell_longitudinal_e_field}:  Output of the longitudinal electric field at the points
 specified in the MaxwellFieldsCoordinate block  (can slow down the run)
@item @strong{b_field_surface_y}:  Output of the B field sliced along the plane y=0 for each field component
@item @strong{maxwell_total_b_field}:  Output of the total (longitudinal plus transverse) magnetic field at
 the points specified in the MaxwellFieldsCoordinate block
@end itemize

@c ----------------------------------
@item @strong{TDExcitedStatesToProject}@*
@vindex @code{TDExcitedStatesToProject}@*
@emph{Section}: Time-Dependent::TD Output@*
@emph{Type}: block@*
@* @strong{[WARNING: This is a *very* experimental feature]}
 To be used with @t{TDOutput = populations}.
 The population of the excited states
 (as defined by <Phi_I|Phi(t)> where |Phi(t)> is the many-body time-dependent state at
 time @emph{t}, and |Phi_I> is the excited state of interest) can be approximated -- it is not clear
 how well -- by substituting for those real many-body states the time-dependent Kohn-Sham
 determinant and some modification of the Kohn-Sham ground-state determinant (@emph{e.g.},
 a simple HOMO-LUMO substitution, or the Casida ansatz for excited states in linear-response
 theory. If you set @t{TDOutput} to contain @t{populations}, you may ask for these approximated
 populations for a number of excited states, which will be described in the files specified
 in this block: each line should be the name of a file that contains one excited state.

 This file structure is the one written by the casida run mode, in the files in the directory @t{*_excitations}.
 The file describes the "promotions" from occupied
 to unoccupied levels that change the initial Slater determinant
 structure specified in ground_state. These promotions are a set
 of electron-hole pairs. Each line in the file, after an optional header, has four
 columns:

 @emph{i  a  \(\sigma\) weight}

 where @emph{i} should be an occupied state, @emph{a} an unoccupied one, and \(\sigma\)
 the spin of the corresponding orbital. This pair is then associated with a
 creation-annihilation pair \(a^{\dagger}_{a,\sigma} a_{i,\sigma}\), so that the
 excited state will be a linear combination in the form:

 \(\left|{\rm ExcitedState}\right> =
 \sum weight(i,a,\sigma) a^{\dagger}_{a,\sigma} a_{i,\sigma} \left|{\rm GroundState}\right>\)

 where @emph{weight} is the number in the fourth column.
 These weights should be normalized to one; otherwise the routine
 will normalize them, and write a warning.



@c ----------------------------------
@item @strong{TDFloquetDimension}@*
@vindex @code{TDFloquetDimension}@*
@emph{Section}: Time-Dependent::TD Output@*
@emph{Type}: integer@*
@emph{Default}: -1@*
@* Order of Floquet Hamiltonian. If negative number is given, downfolding is performed.



@c ----------------------------------
@item @strong{TDFloquetFrequency}@*
@vindex @code{TDFloquetFrequency}@*
@emph{Section}: Time-Dependent::TD Output@*
@emph{Type}: float@*
@* Frequency for the Floquet analysis, this should be the carrier frequency or integer multiples of it.
 Other options will work, but likely be nonsense.




@c ----------------------------------
@item @strong{TDFloquetSample}@*
@vindex @code{TDFloquetSample}@*
@emph{Section}: Time-Dependent::TD Output@*
@emph{Type}: integer@*
@emph{Default}: 20@*
@* Number of points on which one Floquet cycle is sampled in the time-integral of the Floquet analysis.




@c ----------------------------------
@item @strong{TDMultipoleLmax}@*
@vindex @code{TDMultipoleLmax}@*
@emph{Section}: Time-Dependent::TD Output@*
@emph{Type}: integer@*
@emph{Default}: 1@*
@* Maximum electric multipole of the density output to the file @t{td.general/multipoles}
 during a time-dependent simulation. Must be non-negative.



@c ----------------------------------
@item @strong{TDOutput}@*
@vindex @code{TDOutput}@*
@emph{Section}: Time-Dependent::TD Output@*
@emph{Type}: block@*
@emph{Default}: multipoles + energy (+ others depending on other options)@*
@* Defines what should be output during the time-dependent
 simulation. Many of the options can increase the computational
 cost of the simulation, so only use the ones that you need. In
 most cases the default value is enough, as it is adapted to the
 details of the TD run. If the ions are allowed to be moved, additionally
 the geometry and the temperature are output. If a laser is
 included it will output by default.

 Note: the output files generated by this option are updated
 every @t{RestartWriteInterval} steps.

 Example:
 @t{%TDOutput
 @*@ @ multipoles
 @*@ @ energy
 @*%@*}



@emph{Options}:
@itemize @minus
@item @strong{local_mag_moments}:  If set, outputs the local magnetic moments, integrated in sphere centered around each atom.
 The radius of the sphere can be set with @t{LocalMagneticMomentsSphereRadius}.
@item @strong{gauge_field}:  If set, outputs the vector gauge field corresponding to a spatially uniform (but time-dependent)
 external electrical potential. This is only useful in a time-dependent periodic run.
 On by default if @t{GaugeVectorField} is set.
@item @strong{temperature}:  If set, the ionic temperature at each step is printed. On by default if @t{MoveIons = yes}.
@item @strong{ftchd}:  Write Fourier transform of the electron density to the file @t{ftchd.X},
 where X depends on the kick (e.g. with sin-shaped perturbation X=sin).
 This is needed for calculating the dynamic structure factor.
 In the case that the kick mode is qbessel, the written quantity is integral over
 density, multiplied by spherical Bessel function times real spherical harmonic.
 On by default if @t{TDMomentumTransfer} is set.
@item @strong{dipole_velocity}:  When set, outputs the dipole velocity, calculated from the Ehrenfest theorem,
 in the file @t{td.general/velocity}. This file can then be
 processed by the utility @t{oct-harmonic-spectrum} in order to obtain the harmonic spectrum.
@item @strong{eigenvalues}:  Write the KS eigenvalues.
@item @strong{ionization_channels}:  Write the multiple-ionization channels using the KS orbital densities as proposed in
 C. Ullrich, Journal of Molecular Structure: THEOCHEM 501, 315 (2000).
@item @strong{total_current}:  Output the total current (average of the current density over the cell).
@item @strong{partial_charges}:  Bader and Hirshfeld partial charges. The output file is called 'td.general/partial_charges'.
@item @strong{td_kpoint_occup}:  Project propagated Kohn-Sham states to the states at t=0 given in the directory
 restart_proj (see %RestartOptions). This is an alternative to the option
 td_occup, with a formating more suitable for k-points and works only in
 k- and/or state parallelization
@item @strong{multipoles}:  Outputs the (electric) multipole moments of the density to the file @t{td.general/multipoles}.
 This is required to, @emph{e.g.}, calculate optical absorption spectra of finite systems. The
 maximum value of \(l\) can be set with the variable @t{TDMultipoleLmax}.
@item @strong{td_floquet}:  Compute non-interacting Floquet bandstructure according to further options:
 TDFloquetFrequency, TDFloquetSample, TDFloquetDimension.
 This is done only once per td-run at t=0.
 works only in k- and/or state parallelization
@item @strong{n_excited_el}:  Output the number of excited electrons, based on the projections
 of the time evolved wave-functions on the ground-state wave-functions.
 The output interval of this quantity is controled by the variable @t{TDOutputComputeInterval}
@item @strong{coordinates_sep}:  Writes geometries in a separate file.
@item @strong{velocities_sep}:  Writes velocities in a separate file.
@item @strong{forces_sep}:  Writes forces in a separate file.
@item @strong{total_heat_current}:  Output the total heat current (average of the heat current density over the cell).
@item @strong{total_magnetization}:  Writes the total magnetization, where the total magnetization is calculated at the momentum
 defined by @t{TDMomentumTransfer}.
 This is used to extract the magnon frequency in case of a magnon kick.
@item @strong{photons_q}:  Writes photons_q in a separate file.
@item @strong{angular}:  Outputs the orbital angular momentum of the system to @t{td.general/angular}, which can be used to calculate circular
 dichroism.
@item @strong{spin}:  (Experimental) Outputs the expectation value of the spin, which can be used to calculate magnetic
 circular dichroism.
@item @strong{populations}:  (Experimental) Outputs the projection of the time-dependent
 Kohn-Sham Slater determinant onto the ground state (or
 approximations to the excited states) to the file
 @t{td.general/populations}. Note that the calculation of
 populations is expensive in memory and computer time, so it
 should only be used if it is really needed. See @t{TDExcitedStatesToProject}.
@item @strong{geometry}:  If set (and if the atoms are allowed to move), outputs the coordinates, velocities,
 and forces of the atoms to the the file @t{td.general/coordinates}. On by default if @t{MoveIons = yes}.
@item @strong{dipole_acceleration}:  When set, outputs the acceleration of the electronic dipole, calculated from the Ehrenfest theorem,
 in the file @t{td.general/acceleration}. This file can then be
 processed by the utility @t{oct-harmonic-spectrum} in order to obtain the harmonic spectrum.
@item @strong{laser}:  If set, outputs the laser field to the file @t{td.general/laser}.
 On by default if @t{TDExternalFields} is set.
@item @strong{energy}:  If set, @t{octopus} outputs the different components of the energy
 to the file @t{td.general/energy}. Will be zero except for every @t{TDEnergyUpdateIter} iterations.
@item @strong{td_occup}:  (Experimental) If set, outputs the projections of the
 time-dependent Kohn-Sham wavefunctions onto the static
 (zero-time) wavefunctions to the file
 @t{td.general/projections.XXX}. Only use this option if
 you really need it, as it might be computationally expensive. See @t{TDProjStateStart}.
 The output interval of this quantity is controled by the variable @t{TDOutputComputeInterval}
 In case of states parallelization, all the ground-state states are stored by each task.
@end itemize

@c ----------------------------------
@item @strong{TDOutputComputeInterval}@*
@vindex @code{TDOutputComputeInterval}@*
@emph{Section}: Time-Dependent::TD Output@*
@emph{Type}: integer@*
@emph{Default}: 50@*
@* The TD output requested are computed
 when the iteration number is a multiple of the @t{TDOutputComputeInterval} variable.
 Must be >= 0. If it is 0, then no output is written.
 Implemented only for projections and number of excited electrons for the moment.



@c ----------------------------------
@item @strong{TDOutputDFTU}@*
@vindex @code{TDOutputDFTU}@*
@emph{Section}: Time-Dependent::TD Output@*
@emph{Type}: flag@*
@emph{Default}: none@*
@* Defines what should be output during the time-dependent
 simulation, related to LDA+U.

 Note: the output files generated by this option are updated
 every @t{RestartWriteInterval} steps.


@emph{Options}:
@itemize @minus
@item @strong{effective_u}:  Writes the effective U for each orbital set as a function of time.
@end itemize

@c ----------------------------------
@item @strong{TDOutputResolveStates}@*
@vindex @code{TDOutputResolveStates}@*
@emph{Section}: Time-Dependent::TD Output@*
@emph{Type}: logical@*
@emph{Default}: No@*
@* Defines whether the output should be resolved by states.

 So far only TDOutput = multipoles is supported.




@c ----------------------------------
@item @strong{TDProjStateStart}@*
@vindex @code{TDProjStateStart}@*
@emph{Section}: Time-Dependent::TD Output@*
@emph{Type}: integer@*
@emph{Default}: 1@*
@* To be used with @t{TDOutput = td_occup}. Not available if @t{TDOutput = populations}.
 Only output projections to states above @t{TDProjStateStart}. Usually one is only interested
 in particle-hole projections around the HOMO, so there is no need to calculate (and store)
 the projections of all TD states onto all static states. This sets a lower limit. The upper limit
 is set by the number of states in the propagation and the number of unoccupied states
 available.



@c ----------------------------------
@end itemize
@node Utilities,,,
@section Utilities
@c ----------------------------------

@itemize
@item @strong{Volume}@*
@vindex @code{Volume}@*
@emph{Section}: Utilities::@*
@emph{Type}: block@*
@* Describes a volume in space defined through the addition and substraction of
 spheres. The first field is always "+" (include points inside the volume) or "-"
 (exclude points inside the volume)


@emph{Options}:
@itemize @minus
@item @strong{vol_sphere}: 
 @t{%Volume
 @*@ @  "+"/"-" | vol_sphere | center_x | center_y | center_z | radius
 @*%}
@item @strong{vol_slab}: 
 @t{%Volume
 @*@ @  "+"/"-" | vol_slab | thickness
 @*%}

@end itemize

@c ----------------------------------
@end itemize
@node oct-casida_spectrum,,,
@subsection oct-casida_spectrum
@c ----------------------------------

@itemize
@item @strong{CasidaSpectrumBroadening}@*
@vindex @code{CasidaSpectrumBroadening}@*
@emph{Section}: Utilities::oct-casida_spectrum@*
@emph{Type}: float@*
@emph{Default}: 0.005 Ha@*
@* Width of the Lorentzian used to broaden the excitations.



@c ----------------------------------
@item @strong{CasidaSpectrumEnergyStep}@*
@vindex @code{CasidaSpectrumEnergyStep}@*
@emph{Section}: Utilities::oct-casida_spectrum@*
@emph{Type}: float@*
@emph{Default}: 0.001 Ha@*
@* Sampling rate for the spectrum.



@c ----------------------------------
@item @strong{CasidaSpectrumMaxEnergy}@*
@vindex @code{CasidaSpectrumMaxEnergy}@*
@emph{Section}: Utilities::oct-casida_spectrum@*
@emph{Type}: float@*
@emph{Default}: 1.0 Ha@*
@* The broadening is done for energies smaller than @t{CasidaSpectrumMaxEnergy}.



@c ----------------------------------
@item @strong{CasidaSpectrumMinEnergy}@*
@vindex @code{CasidaSpectrumMinEnergy}@*
@emph{Section}: Utilities::oct-casida_spectrum@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* The broadening is done for energies greater than @t{CasidaSpectrumMinEnergy}.



@c ----------------------------------
@item @strong{CasidaSpectrumRotationMatrix}@*
@vindex @code{CasidaSpectrumRotationMatrix}@*
@emph{Section}: Utilities::oct-casida_spectrum@*
@emph{Type}: block@*
@emph{Default}: identity@*
@* Supply a rotation matrix to apply to the transition dipoles in generating the spectrum. The rotated atomic structure
 will also be output. Size of matrix must be @t{Dimensions}.



@c ----------------------------------
@end itemize
@node oct-center-geom,,,
@subsection oct-center-geom
@c ----------------------------------

@itemize
@item @strong{AxisType}@*
@vindex @code{AxisType}@*
@emph{Section}: Utilities::oct-center-geom@*
@emph{Type}: integer@*
@emph{Default}: inertia@*
@* After the structure is centered, it is also aligned to a set of orthogonal axes.
 This variable decides which set of axes to use. Only implemented for 3D, in which case
 the default is @t{inertia}; otherwise @t{none} is default and the only legal value.


@emph{Options}:
@itemize @minus
@item @strong{none}:  Do not rotate. Will still give output regarding center of mass and moment of inertia.
@item @strong{inertia}:  The axis of inertia.
@item @strong{pseudo_inertia}:  Pseudo-axis of inertia, calculated considering all species to have equal mass.
@item @strong{large_axis}:  The larger axis of the molecule.
@end itemize

@c ----------------------------------
@item @strong{MainAxis}@*
@vindex @code{MainAxis}@*
@emph{Section}: Utilities::oct-center-geom@*
@emph{Type}: block@*
@* A vector of reals defining the axis to which the molecule
 should be aligned. If not present, the default value will
 be the x-axis. For example in 3D:
 @t{
 @*%MainAxis
 @* 1 | 0 | 0
 @*%}



@c ----------------------------------
@end itemize
@node oct-conductivity_spectrum,,,
@subsection oct-conductivity_spectrum
@c ----------------------------------

@itemize
@item @strong{ConductivityFromForces}@*
@vindex @code{ConductivityFromForces}@*
@emph{Section}: Utilities::oct-conductivity_spectrum@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* (Experimental) If enabled, Octopus will attempt to calculate the conductivity from the forces instead of the current.



@c ----------------------------------
@item @strong{ConductivitySpectrumTimeStepFactor}@*
@vindex @code{ConductivitySpectrumTimeStepFactor}@*
@emph{Section}: Utilities::oct-conductivity_spectrum@*
@emph{Type}: integer@*
@emph{Default}: 1@*
@* In the calculation of the conductivity, it is not necessary
 to read the velocity at every time step. This variable controls
 the integer factor between the simulation time step and the
 time step used to calculate the conductivity.



@c ----------------------------------
@end itemize
@node oct-convert,,,
@subsection oct-convert
@c ----------------------------------

@itemize
@item @strong{ConvertEnd}@*
@vindex @code{ConvertEnd}@*
@emph{Section}: Utilities::oct-convert@*
@emph{Type}: integer@*
@emph{Default}: 1@*
@* The last number of the filename or folder.



@c ----------------------------------
@item @strong{ConvertEnergyMax}@*
@vindex @code{ConvertEnergyMax}@*
@emph{Section}: Utilities::oct-convert@*
@emph{Type}: float@*
@emph{Default}: w_max@*
@* Maximum energy to output from Fourier transform.



@c ----------------------------------
@item @strong{ConvertEnergyMin}@*
@vindex @code{ConvertEnergyMin}@*
@emph{Section}: Utilities::oct-convert@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* Minimum energy to output from Fourier transform.



@c ----------------------------------
@item @strong{ConvertEnergyStep}@*
@vindex @code{ConvertEnergyStep}@*
@emph{Section}: Utilities::oct-convert@*
@emph{Type}: float@*
@emph{Default}: \(2 \pi / T\), where \(T\) is the total propagation time@*
@* Energy step to output from Fourier transform.
 Sampling rate for the Fourier transform. If you supply a number equal or smaller than zero, then
 the sampling rate will be \(2 \pi / T\), where \(T\) is the total propagation time.



@c ----------------------------------
@item @strong{ConvertFTMethod}@*
@vindex @code{ConvertFTMethod}@*
@emph{Section}: Utilities::oct-convert@*
@emph{Type}: integer@*
@emph{Default}: FAST_FOURIER@*
@* Describes the method used to perform the Fourier Transform


@emph{Options}:
@itemize @minus
@item @strong{fast_fourier}:  Uses Fast Fourier Transform as implemented in the external library.
@item @strong{standard_fourier}:  Uses polinomial approach to the computation of discrete Fourier Transform.
 It uses the same variable described in how to obtain spectrum from
 a time-propagation calculation.
@end itemize

@c ----------------------------------
@item @strong{ConvertFilename}@*
@vindex @code{ConvertFilename}@*
@emph{Section}: Utilities::oct-convert@*
@emph{Type}: string@*
@emph{Default}: "density"@*
@* Input filename. The original filename which is going to be converted in the format
 specified in @t{OutputFormat}. It is going to convert various files, it should
 only contain the beginning of the name. For instance, in the case of the restart
 files, it should be one space ' '.



@c ----------------------------------
@item @strong{ConvertFolder}@*
@vindex @code{ConvertFolder}@*
@emph{Section}: Utilities::oct-convert@*
@emph{Type}: string@*
@* The folder name where the input files are. The default is
 @t{td.} if @t{ConvertIterateFolder = true}, otherwise @t{restart}.



@c ----------------------------------
@item @strong{ConvertHow}@*
@vindex @code{ConvertHow}@*
@emph{Section}: Utilities::oct-convert@*
@emph{Type}: integer@*
@emph{Default}: convert_format@*
@* Select how the mesh function will be converted.


@emph{Options}:
@itemize @minus
@item @strong{format}:  The format of the mesh function will be convert from the binary file.obf.
 The format of the output function is set by OutputHow variable.
@item @strong{fourier_transform}:  A fourier transform of the mesh function will be computed.
 It requieres that ConvertStart and ConvertEnd have to be set.
@item @strong{operation}:  Convert utility will generate a new mesh function constructed by linear
 combination of scalar function of different mesh functions,
@end itemize

@c ----------------------------------
@item @strong{ConvertIterateFolder}@*
@vindex @code{ConvertIterateFolder}@*
@emph{Section}: Utilities::oct-convert@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* This variable decides if a folder is going to be iterated or the
 filename is going to be iterated.



@c ----------------------------------
@item @strong{ConvertOutputFilename}@*
@vindex @code{ConvertOutputFilename}@*
@emph{Section}: Utilities::oct-convert@*
@emph{Type}: string@*
@emph{Default}: "density"@*
@* Output filename. The name of the file in which the converted mesh function will be
 written in the format specified in @t{OutputFormat}.



@c ----------------------------------
@item @strong{ConvertOutputFolder}@*
@vindex @code{ConvertOutputFolder}@*
@emph{Section}: Utilities::oct-convert@*
@emph{Type}: string@*
@* The folder name where the output files will be write. The default is
 @t{convert}.



@c ----------------------------------
@item @strong{ConvertReadSize}@*
@vindex @code{ConvertReadSize}@*
@emph{Section}: Utilities::oct-convert@*
@emph{Type}: integer@*
@emph{Default}: mesh%np@*
@* How many points are read at once. For the parallel run this has not been
 yet tested, so it should be one. For the serial run, a number
 of 100-1000 will speed-up the execution time by this factor.



@c ----------------------------------
@item @strong{ConvertScalarOperation}@*
@vindex @code{ConvertScalarOperation}@*
@emph{Section}: Utilities::oct-convert@*
@emph{Type}: block@*
@* This variable is used to generate a new mesh function as a linear combination
 different mesh function having the same mesh. Each row defines an operation for
 for a single mesh function.
 The format of the block is the following: @*
 'variable name' | 'folder' | 'file' | 'operation'



@c ----------------------------------
@item @strong{ConvertStart}@*
@vindex @code{ConvertStart}@*
@emph{Section}: Utilities::oct-convert@*
@emph{Type}: integer@*
@* The starting number of the filename or folder.
 Default is 0 if @t{ConvertIterateFolder = true}, otherwise 1.



@c ----------------------------------
@item @strong{ConvertStep}@*
@vindex @code{ConvertStep}@*
@emph{Section}: Utilities::oct-convert@*
@emph{Type}: integer@*
@emph{Default}: 1@*
@* The padding between the filenames or folder.



@c ----------------------------------
@item @strong{ConvertSubtract}@*
@vindex @code{ConvertSubtract}@*
@emph{Section}: Utilities::oct-convert@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* Decides if a reference file is going to be subtracted.



@c ----------------------------------
@item @strong{ConvertSubtractFilename}@*
@vindex @code{ConvertSubtractFilename}@*
@emph{Section}: Utilities::oct-convert@*
@emph{Type}: string@*
@emph{Default}: density@*
@* Input filename. The file which is going to subtracted to rest of the files.



@c ----------------------------------
@item @strong{ConvertSubtractFolder}@*
@vindex @code{ConvertSubtractFolder}@*
@emph{Section}: Utilities::oct-convert@*
@emph{Type}: string@*
@emph{Default}: .@*
@* The folder name which is going to be subtracted.



@c ----------------------------------
@end itemize
@node oct-local_multipoles,,,
@subsection oct-local_multipoles
@c ----------------------------------

@itemize
@item @strong{LDBaderThreshold}@*
@vindex @code{LDBaderThreshold}@*
@emph{Section}: Utilities::oct-local_multipoles@*
@emph{Type}: float@*
@emph{Default}: 0.01@*
@* This variable sets the threshold for the basins calculations. Recommended values:
 0.01 -> intramolecular volumes; 0.2 -> intermolecular volumes.



@c ----------------------------------
@item @strong{LDEnd}@*
@vindex @code{LDEnd}@*
@emph{Section}: Utilities::oct-local_multipoles@*
@emph{Type}: integer@*
@* The last number of the filename or folder.



@c ----------------------------------
@item @strong{LDFilename}@*
@vindex @code{LDFilename}@*
@emph{Section}: Utilities::oct-local_multipoles@*
@emph{Type}: string@*
@emph{Default}: 'density'@*
@* Input filename. The original filename for the density which is going to be
 fragmented into domains.



@c ----------------------------------
@item @strong{LDFolder}@*
@vindex @code{LDFolder}@*
@emph{Section}: Utilities::oct-local_multipoles@*
@emph{Type}: string@*
@* The folder name where the density used as input file is.



@c ----------------------------------
@item @strong{LDIonicDipole}@*
@vindex @code{LDIonicDipole}@*
@emph{Section}: Utilities::oct-local_multipoles@*
@emph{Type}: logical@*
@emph{Default}: yes@*
@* Describes if the ionic dipole has to be take into account
 when computing the multipoles.



@c ----------------------------------
@item @strong{LDIterateFolder}@*
@vindex @code{LDIterateFolder}@*
@emph{Section}: Utilities::oct-local_multipoles@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* This variable decides if a folder is going to be iterated.



@c ----------------------------------
@item @strong{LDMultipoleLmax}@*
@vindex @code{LDMultipoleLmax}@*
@emph{Section}: Utilities::oct-local_multipoles@*
@emph{Type}: integer@*
@emph{Default}: 1@*
@* Maximum electric multipole of the density output to the file @t{local.multipoles/<>domain%<>.multipoles}
 during a time-dependent simulation. Must be non-negative.



@c ----------------------------------
@item @strong{LDOutput}@*
@vindex @code{LDOutput}@*
@emph{Section}: Utilities::oct-local_multipoles@*
@emph{Type}: flag@*
@emph{Default}: multipoles@*
@* Defines what should be output during the local domains
 simulation. Many of the options can increase the computational
 cost of the simulation, so only use the ones that you need. In
 most cases the default value is enough, as it is adapted to the
 details.


@emph{Options}:
@itemize @minus
@item @strong{multipoles}:  Outputs the (electric) multipole moments of the density to the file @t{ld.general/multipoles}.
 This is required to, @emph{e.g.}, calculate optical absorption spectra of finite systems. The
 maximum value of \(l\) can be set with the variable @t{LDMultipoleLmax}.
@item @strong{density}:  If set, @t{octopus} outputs the densities corresponding to the local domains to
 the folder @t{ld.general/densities}.
 The output format is set by the @t{LDOutputFormat} input variable.
@item @strong{local_v}:  If set, @t{octopus} outputs the different components of the potential
 to the folder @t{ld.general/potential}.
 The output format is set by the @t{LDOutputFormat} input variable.
@item @strong{energy}:  If set, @t{octopus} outputs the different components of the energy of the local domains
 to the folder @t{ld.general/energy}.
@end itemize

@c ----------------------------------
@item @strong{LDOutputFormat}@*
@vindex @code{LDOutputFormat}@*
@emph{Section}: Utilities::oct-local_multipoles@*
@emph{Type}: flag@*
@emph{Default}: none@*
@* Describes the format of the output files (see @t{LDOutput}).
 It can take the same values as @t{OutputFormat} flag.



@c ----------------------------------
@item @strong{LDOverWrite}@*
@vindex @code{LDOverWrite}@*
@emph{Section}: Utilities::oct-local_multipoles@*
@emph{Type}: logical@*
@emph{Default}: true@*
@* Controls whether to over-write existing files.



@c ----------------------------------
@item @strong{LDRadiiFile}@*
@vindex @code{LDRadiiFile}@*
@emph{Section}: Utilities::oct-local_multipoles@*
@emph{Type}: string@*
@emph{Default}: 'default'@*
@* Full path for the radii file. If set, def_rsize will be reset to the new values.
 This file should have the same format as share/PP/default.



@c ----------------------------------
@item @strong{LDRestart}@*
@vindex @code{LDRestart}@*
@emph{Section}: Utilities::oct-local_multipoles@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* Restart information will be read from @t{LDRestartFolder}.



@c ----------------------------------
@item @strong{LDRestartFolder}@*
@vindex @code{LDRestartFolder}@*
@emph{Section}: Utilities::oct-local_multipoles@*
@emph{Type}: string@*
@emph{Default}: "ld.general"@*
@* The folder name where the density used as input file is.



@c ----------------------------------
@item @strong{LDStart}@*
@vindex @code{LDStart}@*
@emph{Section}: Utilities::oct-local_multipoles@*
@emph{Type}: integer@*
@* The starting number of the filename or folder.



@c ----------------------------------
@item @strong{LDStep}@*
@vindex @code{LDStep}@*
@emph{Section}: Utilities::oct-local_multipoles@*
@emph{Type}: integer@*
@emph{Default}: 1@*
@* The padding between the filenames or folder.



@c ----------------------------------
@item @strong{LDUpdate}@*
@vindex @code{LDUpdate}@*
@emph{Section}: Utilities::oct-local_multipoles@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* Controls if the calculation of the local domains is desired at each iteration.



@c ----------------------------------
@item @strong{LDUseAtomicRadii}@*
@vindex @code{LDUseAtomicRadii}@*
@emph{Section}: Utilities::oct-local_multipoles@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* If set, atomic radii will be used to assign lone pairs to ion.



@c ----------------------------------
@item @strong{LocalDomains}@*
@vindex @code{LocalDomains}@*
@emph{Section}: Utilities::oct-local_multipoles@*
@emph{Type}: block@*
@* The LocalDomains are by definition part of the global grid. The domains are defined by
 selecting a type shape. The domain box will be constructed using the given parameters.
 A local domain could be construct by addition of several box centered on the ions.
 The grid points inside this box will belong to the local domain.

 The format of this block is the following:@*
 @t{ 'Label' | Shape | %< | Shape dependencies >% }
 @*The first field is the label of the domain.
 Label = string with the name of the new local domain.
 The second is the shape type of the box used to define the domain.
 Shape = SPHERE, CYLINDER, PARALLELEPIPED, MINIMUM, BADER.
 Some types may need some parameters given in the remaining fields of the row.
 (the valid options are detailed below).

 @t{%LocalDomains
 @*case (SPHERE):         | rsize | %<dim origin coordinates>
 @*case (CYLINDER):       | rsize | xsize | %<origin coordinates>
 @*case (PARALLELEPIPED): | %<lsize> | %<origin coordinates>
 @*case (MINIMUM):        | rsize | 'center_list'
 @*case (BADER):          | 'center_list'
 @*%}
 @*rsize: Radius in input length units
 @*xsize: the length of the cylinder in the x-direction
 @*origin coordinates: in input length units separated by |, where the box is centered.
 @*lsize: half of the length of the parallelepiped in each direction.
 @*center_list: string containing the list of atoms in xyz file for each domain in the form "2,16-23"



@c ----------------------------------
@end itemize
@node oct-photoelectron_spectrum,,,
@subsection oct-photoelectron_spectrum
@c ----------------------------------

@itemize
@item @strong{PhotoelectronSpectrumOutput}@*
@vindex @code{PhotoelectronSpectrumOutput}@*
@emph{Section}: Utilities::oct-photoelectron_spectrum@*
@emph{Type}: block@*
@emph{Default}: none@*
@* Specifies what to output extracting the photoelectron cross-section informations.
 When we use polar coordinates the zenith axis is set by vec (default is the first
 laser field polarization vector), theta is the inclination angle measured from
 vec (from 0 to \pi), and phi is the azimuthal angle on a plane perpendicular to
 vec (from 0 to 2\pi).
 Each option must be in a separate row. Optionally individual output formats can be defined
 for each row or they can be read separately from @t{OutputFormat} variable
 in the input file.

 Example (minimal):
 @t{%PhotoelectronSpectrumOutput
 @*@ @ energy_tot
 @*@ @ velocity_map
 @*%@*}

 Example (with OutputFormat):
 @t{%PhotoelectronSpectrumOutput
 @*@ @ arpes        | vtk
 @*@ @ velocity_map | ncdf
 @*%@*}



@emph{Options}:
@itemize @minus
@item @strong{energy_tot}:  Output the energy-resolved photoelectron spectrum: E.
@item @strong{energy_angle}:  Output the energy and angle resolved spectrum: (theta, E)
 The result is integrated over phi.
@item @strong{velocity_map_cut}:  Velocity map on a plane orthogonal to pvec: (px, py). The allowed cutting planes
 (pvec) can only be parallel to the x,y,z=0 planes.
 Space is oriented so that the z-axis is along vec. Supports the -I option.
@item @strong{energy_xy}:  Angle and energy-resolved spectrum on the inclination plane: (Ex, Ey).
 The result is integrated over ph;
@item @strong{energy_th_ph}:  Ionization probability integrated on spherical cuts: (theta, phi).
@item @strong{velocity_map}:  Full momentum-resolved ionization probability: (px, py, pz).
 The output format can be controlled with @t{OutputHow} and can be vtk, ncdf or ascii.
@item @strong{arpes}:  Full ARPES for semi-periodic systems (vtk).
@item @strong{arpes_cut}:  ARPES cut on a plane following a zero-weight path in reciprocal space.
@end itemize

@c ----------------------------------
@item @strong{PhotoelectronSpectrumResolveStates}@*
@vindex @code{PhotoelectronSpectrumResolveStates}@*
@emph{Section}: Utilities::oct-photoelectron_spectrum@*
@emph{Type}: block@*
@* If @t{yes} calculate the photoelectron spectrum resolved in each K.S. state.
 Optionally a range of states can be given as two slot block where the
 first slot is the lower state index and the second is the highest one.
 For example to calculate the spectra from state i to state j:

 @t{%PhotoelectronSpectrumResolveStates
 @* i | j
 @*%}



@c ----------------------------------
@end itemize
@node oct-propagation_spectrum,,,
@subsection oct-propagation_spectrum
@c ----------------------------------

@itemize
@item @strong{PropagationSpectrumDampFactor}@*
@vindex @code{PropagationSpectrumDampFactor}@*
@emph{Section}: Utilities::oct-propagation_spectrum@*
@emph{Type}: float@*
@emph{Default}: -1.0@*
@* If @t{PropagationSpectrumDampMode = exponential, gaussian}, the damping parameter of the exponential
 is fixed through this variable.
 Default value ensure that the damping function adquires a 0.0001 value at the end of the propagation time.



@c ----------------------------------
@item @strong{PropagationSpectrumDampMode}@*
@vindex @code{PropagationSpectrumDampMode}@*
@emph{Section}: Utilities::oct-propagation_spectrum@*
@emph{Type}: integer@*
@* Decides which damping/filtering is to be applied in order to
 calculate spectra by calculating a Fourier transform. The
 default is polynomial damping, except when @t{SpectrumMethod = compressed_sensing}.
 In that case the default is none.


@emph{Options}:
@itemize @minus
@item @strong{none}:  No filtering at all.
@item @strong{exponential}:  Exponential filtering, corresponding to a Lorentzian-shaped spectrum.
@item @strong{polynomial}:  Third-order polynomial damping.
@item @strong{gaussian}:  Gaussian damping.
@end itemize

@c ----------------------------------
@item @strong{PropagationSpectrumEndTime}@*
@vindex @code{PropagationSpectrumEndTime}@*
@emph{Section}: Utilities::oct-propagation_spectrum@*
@emph{Type}: float@*
@emph{Default}: -1.0 au@*
@* Processing is done for the given function in a time-window that ends at the
 value of this variable. If set to a negative value, the maximum value from
 the corresponding multipole file will used.



@c ----------------------------------
@item @strong{PropagationSpectrumEnergyStep}@*
@vindex @code{PropagationSpectrumEnergyStep}@*
@emph{Section}: Utilities::oct-propagation_spectrum@*
@emph{Type}: float@*
@emph{Default}: 0.01 eV@*
@* Sampling rate for the spectrum. If you supply a number equal or smaller than zero, then
 the sampling rate will be \(2 \pi / T\), where \(T\) is the total propagation time.



@c ----------------------------------
@item @strong{PropagationSpectrumMaxEnergy}@*
@vindex @code{PropagationSpectrumMaxEnergy}@*
@emph{Section}: Utilities::oct-propagation_spectrum@*
@emph{Type}: float@*
@emph{Default}: 20 eV@*
@* The Fourier transform is calculated for energies smaller than this value.



@c ----------------------------------
@item @strong{PropagationSpectrumMinEnergy}@*
@vindex @code{PropagationSpectrumMinEnergy}@*
@emph{Section}: Utilities::oct-propagation_spectrum@*
@emph{Type}: float@*
@* The Fourier transform is calculated for energies larger than this value.



@c ----------------------------------
@item @strong{PropagationSpectrumSigmaDiagonalization}@*
@vindex @code{PropagationSpectrumSigmaDiagonalization}@*
@emph{Section}: Utilities::oct-propagation_spectrum@*
@emph{Type}: logical@*
@emph{Default}: .false.@*
@* If @t{PropagationSpectrumSigmaDiagonalization = yes}, the polarizability tensor is diagonalizied.
 This variable is only used if the cross_section_tensor is computed.



@c ----------------------------------
@item @strong{PropagationSpectrumStartTime}@*
@vindex @code{PropagationSpectrumStartTime}@*
@emph{Section}: Utilities::oct-propagation_spectrum@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* Processing is done for the given function in a time-window that starts at the
 value of this variable.



@c ----------------------------------
@item @strong{PropagationSpectrumSymmetrizeSigma}@*
@vindex @code{PropagationSpectrumSymmetrizeSigma}@*
@emph{Section}: Utilities::oct-propagation_spectrum@*
@emph{Type}: logical@*
@emph{Default}: .false.@*
@* The polarizablity tensor has to be real and symmetric. Due to numerical accuracy,
 that is not extricly conserved when computing it from different time-propations.
 If @t{PropagationSpectrumSymmetrizeSigma = yes}, the polarizability tensor is
 symmetrized before its diagonalizied.
 This variable is only used if the cross_section_tensor is computed.



@c ----------------------------------
@item @strong{PropagationSpectrumTransform}@*
@vindex @code{PropagationSpectrumTransform}@*
@emph{Section}: Utilities::oct-propagation_spectrum@*
@emph{Type}: integer@*
@emph{Default}: sine@*
@* Decides which transform to perform, if @t{SpectrumMethod = fourier}.


@emph{Options}:
@itemize @minus
@item @strong{laplace}:  Real exponential transform: \(\int dt e^{-wt} f(t)\). Produces the real part of the polarizability at imaginary
 frequencies, @emph{e.g.} for Van der Waals \(C_6\) coefficients.
 This is the only allowed choice for complex scaling.
@item @strong{sine}:  Sine transform: \(\int dt \sin(wt) f(t)\). Produces the imaginary part of the polarizability.
@item @strong{cosine}:  Cosine transform: \(\int dt \cos(wt) f(t)\). Produces the real part of the polarizability.
@end itemize

@c ----------------------------------
@item @strong{PropagationSpectrumType}@*
@vindex @code{PropagationSpectrumType}@*
@emph{Section}: Utilities::oct-propagation_spectrum@*
@emph{Type}: integer@*
@emph{Default}: AbsorptionSpectrum@*
@* Type of spectrum to calculate.


@emph{Options}:
@itemize @minus
@item @strong{AbsorptionSpectrum}:  Photoabsorption spectrum.
@item @strong{EnergyLossSpectrum}:  Dynamic structure factor (also known as energy-loss function or spectrum).
@item @strong{DipolePower}:  Power spectrum of the dipole moment.
@item @strong{RotatoryStrength}:  Rotatory strength spectrum.
@end itemize

@c ----------------------------------
@item @strong{SpectrumMethod}@*
@vindex @code{SpectrumMethod}@*
@emph{Section}: Utilities::oct-propagation_spectrum@*
@emph{Type}: integer@*
@emph{Default}: fourier@*
@* Decides which method is used to obtain the spectrum.


@emph{Options}:
@itemize @minus
@item @strong{fourier}:  The standard Fourier transform. Further specified by @t{PropagationSpectrumTransform}.
@item @strong{compressed_sensing}:  (Experimental) Uses the compressed sensing technique.
@end itemize

@c ----------------------------------
@item @strong{SpectrumSignalNoise}@*
@vindex @code{SpectrumSignalNoise}@*
@emph{Section}: Utilities::oct-propagation_spectrum@*
@emph{Type}: float@*
@emph{Default}: 0.0@*
@* For compressed sensing, the signal to process, the
 time-dependent dipole in this case, is assumed to have some
 noise that is given by this dimensionless quantity.



@c ----------------------------------
@item @strong{TransientAbsorptionReference}@*
@vindex @code{TransientAbsorptionReference}@*
@emph{Section}: Utilities::oct-propagation_spectrum@*
@emph{Type}: string@*
@emph{Default}: "."@*
@* In case of delayed kick, the calculation of the transient absorption requires
 to substract a reference calculation, containing the gauge-field without the kick
 This reference must be computed using GaugeFieldPropagate=yes and to have
 TDOutput = gauge_field.
 This variables defined the directory in which the reference gauge_field field is,
 relative to the current folder



@c ----------------------------------
@end itemize
@node oct-spin_susceptibility,,,
@subsection oct-spin_susceptibility
@c ----------------------------------

@itemize
@item @strong{TransientMagnetizationReference}@*
@vindex @code{TransientMagnetizationReference}@*
@emph{Section}: Utilities::oct-spin_susceptibility@*
@emph{Type}: string@*
@emph{Default}: "."@*
@* In case of delayed kick, the calculation of the transient spin susceptibility requires
 to substract a reference calculation, containing dynamics of the magnetization without the kick
 This reference must be computed having
 TDOutput = total_magnetization.
 This variables defined the directory in which the reference total_magnetization file is,
 relative to the current folder



@c ----------------------------------
@end itemize
@node oct-tdtdm,,,
@subsection oct-tdtdm
@c ----------------------------------

@itemize
@item @strong{SupercellDimensions}@*
@vindex @code{SupercellDimensions}@*
@emph{Section}: Utilities::oct-tdtdm@*
@emph{Type}: block@*
@emph{Default}: KPointsGrid@*
@* This block allows to specify the size of the supercell used to plot excitonic wavefunctions.
 If not specified, the code uses the number of k-points for defining the size of the supercell.



@c ----------------------------------
@item @strong{TDTDMFrequencies}@*
@vindex @code{TDTDMFrequencies}@*
@emph{Section}: Utilities::oct-tdtdm@*
@emph{Type}: block@*
@* This block defines for which frequencies the analysis is performed.

 Each row of the block indicates a frequency.



@c ----------------------------------
@item @strong{TDTDMHoleCoordinates}@*
@vindex @code{TDTDMHoleCoordinates}@*
@emph{Section}: Utilities::oct-tdtdm@*
@emph{Type}: float@*
@* The position of the hole used to compute the TDTDM,
 in Cartesian coordinates.
 Note that the code will use the closest grid point.

 The coordinates of the hole are specified in the following way
 @t{%TDTDMHoleCoordinates
 @*@ @ hole_x | hole_y | hole_z
 @*%}

 If TDTDMHoleCoordinates or TDTDMHoleReducedCoordinates are not specified,
 the code will use the coordinate of the first atom in the cell.



@c ----------------------------------
@item @strong{TDTDMHoleReducedCoordinates}@*
@vindex @code{TDTDMHoleReducedCoordinates}@*
@emph{Section}: Utilities::oct-tdtdm@*
@emph{Type}: float@*
@* Same as TDTDMHoleCoordinates, except that coordinates are given in reduced coordinates



@c ----------------------------------
@end itemize
@node oct-unfold,,,
@subsection oct-unfold
@c ----------------------------------

@itemize
@item @strong{UnfoldEnergyStep}@*
@vindex @code{UnfoldEnergyStep}@*
@emph{Section}: Utilities::oct-unfold@*
@emph{Type}: float@*
@* Specifies the energy resolution for the unfolded band structure.
 If you specify 0, the resolution will be set to be 1/1000 points between @t{UnfoldMinEnergy}
 and @t{UnfoldMaxEnergy}



@c ----------------------------------
@item @strong{UnfoldKPointsPath}@*
@vindex @code{UnfoldKPointsPath}@*
@emph{Section}: Utilities::oct-unfold@*
@emph{Type}: block@*
@* Specifies the k-point path for which the unfolding need to be done.
 The syntax is identical to @t{KPointsPath}.



@c ----------------------------------
@item @strong{UnfoldLatticeParameters}@*
@vindex @code{UnfoldLatticeParameters}@*
@emph{Section}: Utilities::oct-unfold@*
@emph{Type}: block@*
@* The lattice parameters of the primitive cell, on which unfolding is performed.
 See the LatticeParameters variable for a more detailed description.



@c ----------------------------------
@item @strong{UnfoldLatticeVectors}@*
@vindex @code{UnfoldLatticeVectors}@*
@emph{Section}: Utilities::oct-unfold@*
@emph{Type}: block@*
@emph{Default}: simple cubic@*
@* Lattice vectors of the primitive cell on which the unfolding is performed.
 See the LatticeVectors variable for a more detailed description.



@c ----------------------------------
@item @strong{UnfoldMaxEnergy}@*
@vindex @code{UnfoldMaxEnergy}@*
@emph{Section}: Utilities::oct-unfold@*
@emph{Type}: float@*
@* Specifies the end of the energy range for the unfolded band structure.
 The default value correspond to the largest eigenvalue.



@c ----------------------------------
@item @strong{UnfoldMinEnergy}@*
@vindex @code{UnfoldMinEnergy}@*
@emph{Section}: Utilities::oct-unfold@*
@emph{Type}: float@*
@* Specifies the start of the energy range for the unfolded band structure.
 The default value correspond to the samllest eigenvalue.



@c ----------------------------------
@item @strong{UnfoldMode}@*
@vindex @code{UnfoldMode}@*
@emph{Section}: Utilities::oct-unfold@*
@emph{Type}: flag@*
@emph{Default}: none@*
@* Specifies which stage of the unfolding tool to use


@emph{Options}:
@itemize @minus
@item @strong{unfold_setup}:  Writes the list of k-points corresponding to the path specified by @t{UnfoldKPointPath}.
 This list of k-point (unfold_kpt.dat) must be used for an unocc calculation of the supercell,
 adding the line "include 'unfold_kpt.dat'" to the inp file and removing the KPointGrid information.
@item @strong{unfold_run}:  Perform the actual unfolding, based on the states obtained from the previous unocc run.
@end itemize

@c ----------------------------------
@end itemize
@node oct-vibrational_spectrum,,,
@subsection oct-vibrational_spectrum
@c ----------------------------------

@itemize
@item @strong{VibrationalSpectrumTime}@*
@vindex @code{VibrationalSpectrumTime}@*
@emph{Section}: Utilities::oct-vibrational_spectrum@*
@emph{Type}: integer@*
@* This variable controls the maximum time for the calculation of
 the velocity autocorrelation function. The default is the total
 propagation time.



@c ----------------------------------
@item @strong{VibrationalSpectrumTimeStepFactor}@*
@vindex @code{VibrationalSpectrumTimeStepFactor}@*
@emph{Section}: Utilities::oct-vibrational_spectrum@*
@emph{Type}: integer@*
@emph{Default}: 10@*
@* In the calculation of the vibrational spectrum, it is not necessary
 to read the velocity at every time step. This variable controls
 the integer factor between the simulation time step and the
 time step used to calculate the vibrational spectrum.



@c ----------------------------------
@end itemize
@node oct-wannier90,,,
@subsection oct-wannier90
@c ----------------------------------

@itemize
@item @strong{SCDMmu}@*
@vindex @code{SCDMmu}@*
@emph{Section}: Utilities::oct-wannier90@*
@emph{Type}: float@*
@* Energy range up to which states are considered for SCDM.



@c ----------------------------------
@item @strong{SCDMsigma}@*
@vindex @code{SCDMsigma}@*
@emph{Section}: Utilities::oct-wannier90@*
@emph{Type}: float@*
@emph{Default}: 0.2@*
@* Broadening of SCDM smearing function.



@c ----------------------------------
@item @strong{Wannier90Files}@*
@vindex @code{Wannier90Files}@*
@emph{Section}: Utilities::oct-wannier90@*
@emph{Type}: flag@*
@emph{Default}: w90_mmn + w90_amn + w90_eig@*
@* Specifies which files to generate.
 Example: @t{w90_mmn + w90_unk}


@emph{Options}:
@itemize @minus
@item @strong{w90_mmn}:  (see Wannier90 documentation)
@item @strong{w90_unk}:  (see Wannier90 documentation)
@item @strong{w90_amn}:  (see Wannier90 documentation)
@item @strong{w90_eig}:  Eigenvalues. See Wannier90 documentation for more details.
@end itemize

@c ----------------------------------
@item @strong{Wannier90Mode}@*
@vindex @code{Wannier90Mode}@*
@emph{Section}: Utilities::oct-wannier90@*
@emph{Type}: integer@*
@* Specifies which stage of the Wannier90 interface to use


@emph{Options}:
@itemize @minus
@item @strong{none}:  Nothing is done.
@item @strong{w90_setup}:  Writes parts of the wannier90 input file @t{w90_prefix.win} corresponding to
 the octopus inp file. Importantly it generates the correct form of Monkhorst-Pack mesh
 written to the file w90_kpoints that has to be used in a gs calculation of Octopus by
 as @t{ include w90_kpoints } instead of the @t{%KpointsGrid} block.
@item @strong{w90_output}:  Generates the relevant files for a wannier90 run, specified by the variable @t{W90_interface_files}.
 This needs files previously generated
 by @t{wannier90.x -pp w90 }
@item @strong{w90_wannier}:  Parse the output of wannier90 to generate the Wannier states on the real-space grid.
 The states will be written in the folder wannier. By default, the states are written as
 binary files, similar to the Kohn-Sham states.

 Not implemented for spinor states.
@end itemize

@c ----------------------------------
@item @strong{Wannier90Prefix}@*
@vindex @code{Wannier90Prefix}@*
@emph{Section}: Utilities::oct-wannier90@*
@emph{Type}: string@*
@emph{Default}: w90@*
@* Prefix for wannier90 files



@c ----------------------------------
@item @strong{Wannier90UseSCDM}@*
@vindex @code{Wannier90UseSCDM}@*
@emph{Section}: Utilities::oct-wannier90@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* By default oct-wannier90 uses the projection method to generate the .amn file.
 By setting this variable to yes, oct-wannier90 will use SCDM method instead.



@c ----------------------------------
@item @strong{Wannier90UseTD}@*
@vindex @code{Wannier90UseTD}@*
@emph{Section}: Utilities::oct-wannier90@*
@emph{Type}: logical@*
@emph{Default}: no@*
@* By default oct-wannier90 uses the ground-state states to compute the necessary information.
 By setting this variable to yes, oct-wannier90 will use the TD states instead.



@c ----------------------------------
@end itemize
@node oct-xyz-anim,,,
@subsection oct-xyz-anim
@c ----------------------------------

@itemize
@item @strong{AnimationMultiFiles}@*
@vindex @code{AnimationMultiFiles}@*
@emph{Section}: Utilities::oct-xyz-anim@*
@emph{Type}: logical@*
@emph{Default}: false@*
@* If true, each iteration written will be in a separate file.



@c ----------------------------------
@item @strong{AnimationSampling}@*
@vindex @code{AnimationSampling}@*
@emph{Section}: Utilities::oct-xyz-anim@*
@emph{Type}: integer@*
@emph{Default}: 100@*
@* Sampling rate of the animation. The animation will be constructed using
 the iteration numbers that are multiples of @t{AnimationSampling@t{.



@c ----------------------------------
@end itemize
