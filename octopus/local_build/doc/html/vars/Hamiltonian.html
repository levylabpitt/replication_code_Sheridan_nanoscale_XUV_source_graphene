
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
<style>
   BODY {background-color: white; 
         font-size: 10pt; font-family: verdana,helvetica;}
   A  {text-decoration: none;color: blue}
</style>
</head>
<body>

<a name='Hamiltonian'</a>
<H2>Hamiltonian</H2>


<p><b><a name='AdaptivelyCompressedExchange'></a>AdaptivelyCompressedExchange</b>
<br/><i>Section</i>: Hamiltonian
<br/><i>Type</i>: logical
<br/><i>Default</i>: false
<br/><br> (Experimental) If set to yes, Octopus will use the adaptively compressed exchange
 operator (ACE) for HF and hybrid calculations, as defined in
  Lin, J. Chem. Theory Comput. 2016, 12, 2242.

</p><hr width='30%' align='left'/>


<p><b><a name='CalculateSelfInducedMagneticField'></a>CalculateSelfInducedMagneticField</b>
<br/><i>Section</i>: Hamiltonian
<br/><i>Type</i>: logical
<br/><i>Default</i>: no
<br/><br> The existence of an electronic current implies the creation of a self-induced magnetic
 field, which may in turn back-react on the system. Of course, a fully consistent treatment
 of this kind of effect should be done in QED theory, but we will attempt a first
 approximation to the problem by considering the lowest-order relativistic terms
 plugged into the normal Hamiltonian equations (spin-other-orbit coupling terms, etc.).
 For the moment being, none of this is done, but a first step is taken by calculating
 the induced magnetic field of a system that has a current, by considering the magnetostatic
 approximation and Biot-Savart law:
<br><br>
 \( \nabla^2 \vec{A} + 4\pi\alpha \vec{J} = 0\)
<br><br>
 \( \vec{B} = \vec{\nabla} \times \vec{A}\)
<br><br>
 If <tt>CalculateSelfInducedMagneticField</tt> is set to yes, this <i>B</i> field is
 calculated at the end of a <tt>gs</tt> calculation (nothing is done -- yet -- in the <tt>td</tt>case)
 and printed out, if the <tt>Output</tt> variable contains the <tt>potential</tt> keyword (the prefix
 of the output files is <tt>Bind</tt>).

</p><hr width='30%' align='left'/>


<p><b><a name='ClassicalPotential'></a>ClassicalPotential</b>
<br/><i>Section</i>: Hamiltonian
<br/><i>Type</i>: integer
<br/><i>Default</i>: no
<br/><br> Whether and how to add to the external potential the potential generated by
 the classical charges read from block <tt>PDBClassical</tt>, for QM/MM calculations.
 Not available in periodic systems.

<br/><i>Options</i>:
<ul>
<li><b>no</b>:   No classical charges.
</li>
<li><b>point_charges</b>:   Classical charges are treated as point charges.
</li>
<li><b>gaussian_smeared</b>:   Classical charges are treated as Gaussian distributions.
  Smearing widths are hard-coded by species (experimental).
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='CurrentDensity'></a>CurrentDensity</b>
<br/><i>Section</i>: Hamiltonian
<br/><i>Type</i>: integer
<br/><i>Default</i>: gradient_corrected
<br/><br> This variable selects the method used to
 calculate the current density. For the moment this variable is
 for development purposes and users should not need to use
 it.

<br/><i>Options</i>:
<ul>
<li><b>gradient</b>:  The calculation of current is done using the gradient operator. (Experimental)
</li>
<li><b>gradient_corrected</b>:  The calculation of current is done using the gradient operator
 with additional corrections for the total current from non-local operators.
</li>
<li><b>hamiltonian</b>:  The current density is obtained from the commutator of the
 Hamiltonian with the position operator. (Experimental)
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='EnablePhotons'></a>EnablePhotons</b>
<br/><i>Section</i>: Hamiltonian
<br/><i>Type</i>: logical
<br/><i>Default</i>: no
<br/><br> This variable can be used to enable photons in several types of calculations.
 It can be used to activate the one-photon OEP formalism.
 In the case of CalculationMode = casida, it enables photon modes as
 described in ACS Photonics 2019, 6, 11, 2757-2778.
 Finally, if set to yes when solving the ferquency-dependent Sternheimer
 equation, the photons are coupled to the electronic subsystem.

</p><hr width='30%' align='left'/>


<p><b><a name='EwaldAlpha'></a>EwaldAlpha</b>
<br/><i>Section</i>: Hamiltonian
<br/><i>Type</i>: float
<br/><i>Default</i>: 0.21
<br/><br> The value 'Alpha' that controls the splitting of the Coulomb
 interaction in the Ewald sum used to calculation the ion-ion
 interaction for periodic systems. This value affects the speed
 of the calculation, normally users do not need to modify it.

</p><hr width='30%' align='left'/>


<p><b><a name='ExternalCurrent'></a>ExternalCurrent</b>
<br/><i>Section</i>: Hamiltonian
<br/><i>Type</i>: logical
<br/><i>Default</i>: no
<br/><br> If an external current density will be used.

</p><hr width='30%' align='left'/>


<p><b><a name='FilterPotentials'></a>FilterPotentials</b>
<br/><i>Section</i>: Hamiltonian
<br/><i>Type</i>: integer
<br/><i>Default</i>: filter_ts
<br/><br> <tt>Octopus</tt> can filter the pseudopotentials so that they no
 longer contain Fourier components larger than the mesh itself. This is
 very useful to decrease the egg-box effect, and so should be used in
 all instances where atoms move (<i>e.g.</i> geometry optimization,
 molecular dynamics, and vibrational modes).

<br/><i>Options</i>:
<ul>
<li><b>filter_none</b>:  Do not filter.
</li>
<li><b>filter_TS</b>:  The filter of M. Tafipolsky and R. Schmid, <i>J. Chem. Phys.</i> <b>124</b>, 174102 (2006).
</li>
<li><b>filter_BSB</b>:  The filter of E. L. Briggs, D. J. Sullivan, and J. Bernholc, <i>Phys. Rev. B</i> <b>54</b>, 14362 (1996).
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='ForceTotalEnforce'></a>ForceTotalEnforce</b>
<br/><i>Section</i>: Hamiltonian
<br/><i>Type</i>: logical
<br/><i>Default</i>: no
<br/><br> (Experimental) If this variable is set to "yes", then the sum
 of the total forces will be enforced to be zero.

</p><hr width='30%' align='left'/>


<p><b><a name='GaugeFieldDelay'></a>GaugeFieldDelay</b>
<br/><i>Section</i>: Hamiltonian
<br/><i>Type</i>: float
<br/><i>Default</i>: 0.
<br/><br> The application of the gauge field acts as a probe of the system. For dynamical
 systems one can apply this probe with a delay relative to the start of the simulation.

</p><hr width='30%' align='left'/>


<p><b><a name='GaugeFieldDynamics'></a>GaugeFieldDynamics</b>
<br/><i>Section</i>: Hamiltonian
<br/><i>Type</i>: integer
<br/><i>Default</i>: polarization
<br/><br> This variable select the dynamics of the gauge field used to
 apply a finite electric field to periodic systems in
 time-dependent runs.

<br/><i>Options</i>:
<ul>
<li><b>none</b>:  The gauge field does not have dynamics. The induced polarization field is zero.
</li>
<li><b>polarization</b>:  The gauge field follows the dynamic described in
 Bertsch et al, Phys. Rev. B 62 7998 (2000).
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='GaugeFieldPropagate'></a>GaugeFieldPropagate</b>
<br/><i>Section</i>: Hamiltonian
<br/><i>Type</i>: logical
<br/><i>Default</i>: no
<br/><br> Propagate the gauge field with initial condition set by GaugeVectorField or zero if not specified

</p><hr width='30%' align='left'/>


<p><b><a name='GaugeVectorField'></a>GaugeVectorField</b>
<br/><i>Section</i>: Hamiltonian
<br/><i>Type</i>: block
<br/><br> The gauge vector field is used to include a uniform (but time-dependent)
 external electric field in a time-dependent run for
 a periodic system. An optional second row specifies the initial
 value for the time derivative of the gauge field (which is set
 to zero by default). By default this field is not included.
 If <tt>KPointsUseSymmetries = yes</tt>, then <tt>SymmetryBreakDir</tt>
 must be set in the same direction.
 This is used with utility <tt>oct-dielectric_function</tt>
 according to GF Bertsch, J-I Iwata, A Rubio, and K Yabana,
 <i>Phys. Rev. B</i> <b>62</b>, 7998-8002 (2000).

</p><hr width='30%' align='left'/>


<p><b><a name='GyromagneticRatio'></a>GyromagneticRatio</b>
<br/><i>Section</i>: Hamiltonian
<br/><i>Type</i>: float
<br/><i>Default</i>: 2.0023193043768
<br/><br> The gyromagnetic ratio of the electron. This is of course a physical
 constant, and the default value is the exact one that you should not
 touch, unless:
 (i)  You want to disconnect the anomalous Zeeman term in the Hamiltonian
 (then set it to zero; this number only affects that term);
 (ii) You are using an effective Hamiltonian, as is the case when
 you calculate a 2D electron gas, in which case you have an effective
 gyromagnetic factor that depends on the material.

</p><hr width='30%' align='left'/>


<p><b><a name='MagneticConstrain'></a>MagneticConstrain</b>
<br/><i>Section</i>: Hamiltonian
<br/><i>Type</i>: integer
<br/><i>Default</i>: no
<br/><br> This variable selects which magnetic constrain expression is added to the Hamiltonian.

<br/><i>Options</i>:
<ul>
<li><b>constrain_none</b>:  No constrain is added to the Hamiltonian.
</li>
<li><b>constrain_dir</b>:  We are adding a constrain for the direction of the magnetic moments only,
 see PRB 91, 054420 (2015).
</li>
<li><b>constrain_full</b>:  We are adding a constrain for the direction and norm of the magnetic moments only,
 see PRB 91, 054420 (2015).
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='MagneticConstrainStrength'></a>MagneticConstrainStrength</b>
<br/><i>Section</i>: Hamiltonian
<br/><i>Type</i>: float
<br/><i>Default</i>: 0.01
<br/><br> This variable determines the value of the Lagrange multiplier used for the constrain term.

</p><hr width='30%' align='left'/>


<p><b><a name='MaxwellHamiltonianOperator'></a>MaxwellHamiltonianOperator</b>
<br/><i>Section</i>: Hamiltonian
<br/><i>Type</i>: integer
<br/><i>Default</i>: faraday_ampere
<br/><br> With this variable the the Maxwell Hamiltonian operator can be selected

<br/><i>Options</i>:
<ul>
<li><b>faraday_ampere_old</b>:  old version
</li>
<li><b>faraday_ampere</b>:  The propagation operation in vacuum with Spin 1 matrices without Gauss law condition.
</li>
<li><b>faraday_ampere_medium</b>:  The propagation operation in medium with Spin 1 matrices without Gauss law condition
</li>
<li><b>faraday_ampere_gauss</b>:  The propagation operation is done by 4x4 matrices also with Gauss laws constraint.
</li>
<li><b>faraday_ampere_gauss_medium</b>:  The propagation operation is done by 4x4 matrices also with Gauss laws constraint in medium
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='MaxwellMediumCalculation'></a>MaxwellMediumCalculation</b>
<br/><i>Section</i>: Hamiltonian
<br/><i>Type</i>: integer
<br/><i>Default</i>: RS
<br/><br> For linear media the calculation of the Maxwell Operator acting on the RS state can be done
 directly using the Riemann-Silberstein representation or by calculating the curl of the
 electric and magnetic fields.

<br/><i>Options</i>:
<ul>
<li><b>RS</b>:  Medium calculation directly via Hamiltonian
</li>
<li><b>EM</b>:  Medium calculation via curl of electric field and magnetic field
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='ParticleMass'></a>ParticleMass</b>
<br/><i>Section</i>: Hamiltonian
<br/><i>Type</i>: float
<br/><i>Default</i>: 1.0
<br/><br> It is possible to make calculations for a particle with a mass
 different from one (atomic unit of mass, or mass of the electron).
 This is useful to describe non-electronic systems, or for
 esoteric purposes.

</p><hr width='30%' align='left'/>


<p><b><a name='RashbaSpinOrbitCoupling'></a>RashbaSpinOrbitCoupling</b>
<br/><i>Section</i>: Hamiltonian
<br/><i>Type</i>: float
<br/><i>Default</i>: 0.0
<br/><br> (Experimental.) For systems described in 2D (electrons confined to 2D in semiconductor structures), one
 may add the Bychkov-Rashba spin-orbit coupling term [Bychkov and Rashba, <i>J. Phys. C: Solid
 State Phys.</i> <b>17</b>, 6031 (1984)]. This variable determines the strength
 of this perturbation, and has dimensions of energy times length.

</p><hr width='30%' align='left'/>


<p><b><a name='RelativisticCorrection'></a>RelativisticCorrection</b>
<br/><i>Section</i>: Hamiltonian
<br/><i>Type</i>: integer
<br/><i>Default</i>: non_relativistic
<br/><br> The default value means that <i>no</i> relativistic correction is used. To
 include spin-orbit coupling turn <tt>RelativisticCorrection</tt> to <tt>spin_orbit</tt>
 (this will only work if <tt>SpinComponents</tt> has been set to <tt>non_collinear</tt>, which ensures
 the use of spinors).

<br/><i>Options</i>:
<ul>
<li><b>non_relativistic</b>:  No relativistic corrections.
</li>
<li><b>spin_orbit</b>:  Spin-orbit.
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='RiemannSilbersteinSign'></a>RiemannSilbersteinSign</b>
<br/><i>Section</i>: Hamiltonian
<br/><i>Type</i>: integer
<br/><i>Default</i>: plus
<br/><br> Sign for the imaginary part of the Riemann Silberstein vector which represents the magnetic field

<br/><i>Options</i>:
<ul>
<li><b>minus</b>:  Riemann Silberstein sign is minus
</li>
<li><b>plus</b>:  Riemann Silberstein sign is plus
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='SOStrength'></a>SOStrength</b>
<br/><i>Section</i>: Hamiltonian
<br/><i>Type</i>: float
<br/><i>Default</i>: 1.0
<br/><br> Tuning of the spin-orbit coupling strength: setting this value to zero turns off spin-orbit terms in
 the Hamiltonian, and setting it to one corresponds to full spin-orbit.

</p><hr width='30%' align='left'/>


<p><b><a name='StaticElectricField'></a>StaticElectricField</b>
<br/><i>Section</i>: Hamiltonian
<br/><i>Type</i>: block
<br/><i>Default</i>: 0
<br/><br> A static constant electric field may be added to the usual Hamiltonian,
 by setting the block <tt>StaticElectricField</tt>.
 The three possible components of the block (which should only have one
 line) are the three components of the electric field vector.
 It can be applied in a periodic direction of a large supercell via
 the single-point Berry phase.

</p><hr width='30%' align='left'/>


<p><b><a name='StaticMagneticField'></a>StaticMagneticField</b>
<br/><i>Section</i>: Hamiltonian
<br/><i>Type</i>: block
<br/><br> A static constant magnetic field may be added to the usual Hamiltonian,
 by setting the block <tt>StaticMagneticField</tt>.
 The three possible components of the block (which should only have one
 line) are the three components of the magnetic field vector. Note that
 if you are running the code in 1D mode, this will not work, and if you
 are running the code in 2D mode the magnetic field will have to be in
 the <i>z</i>-direction, so that the first two columns should be zero.
 Possible in periodic system only in these cases: 2D system, 1D periodic,
 with <tt>StaticMagneticField2DGauge = linear_y</tt>;
 3D system, 1D periodic, field is zero in <i>y</i>- and <i>z</i>-directions (given
 currently implemented gauges).
<br><br>
 The magnetic field should always be entered in atomic units, regardless
 of the <tt>Units</tt> variable. Note that we use the "Gaussian" system
 meaning 1 au[B] = \( 2.350517568\times 10^9\) Gauss, which corresponds to
 \(2.3505175678\times 10^5\) Tesla.

</p><hr width='30%' align='left'/>


<p><b><a name='StaticMagneticField2DGauge'></a>StaticMagneticField2DGauge</b>
<br/><i>Section</i>: Hamiltonian
<br/><i>Type</i>: integer
<br/><i>Default</i>: linear_xy
<br/><br> The gauge of the static vector potential \(A\) when a magnetic field
 \(B = \left( 0, 0, B_z \right)\) is applied to a 2D-system.

<br/><i>Options</i>:
<ul>
<li><b>linear_xy</b>:  Linear gauge with \(A = \frac{1}{2c} \left( -y, x \right) B_z\). (Cannot be used for periodic systems.)
</li>
<li><b>linear_y</b>:  Linear gauge with \(A = \frac{1}{c} \left( -y, 0 \right) B_z\). Can be used for <tt>PeriodicDimensions = 1</tt>
 but not <tt>PeriodicDimensions = 2</tt>.
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='TheoryLevel'></a>TheoryLevel</b>
<br/><i>Section</i>: Hamiltonian
<br/><i>Type</i>: integer
<br/><br> The calculations can be run with different "theory levels" that
 control how electrons are simulated. The default is
 <tt>dft</tt>. When hybrid functionals are requested, through
 the <tt>XCFunctional</tt> variable, the default is
 <tt>hartree_fock</tt>.

<br/><i>Options</i>:
<ul>
<li><b>hartree</b>:  Calculation within the Hartree method (experimental). Note that, contrary to popular
 belief, the Hartree potential is self-interaction-free. Therefore, this run
 mode will not yield the same result as <tt>kohn-sham</tt> without exchange-correlation.
</li>
<li><b>independent_particles</b>:  Particles will be considered as independent, <i>i.e.</i> as non-interacting.
 This mode is mainly used for testing purposes, as the code is usually
 much faster with <tt>independent_particles</tt>.
</li>
<li><b>hartree_fock</b>:  This is the traditional Hartree-Fock scheme. Like the Hartree scheme, it is fully
 self-interaction-free.
</li>
<li><b>kohn_sham</b>:  This is the default density-functional theory scheme. Note that you can also use
 hybrid functionals in this scheme, but they will be handled the "DFT" way, <i>i.e.</i>,
 solving the OEP equation.
</li>
<li><b>generalized_kohn_sham</b>:  This is similar to the <tt>kohn-sham</tt> scheme, except that this allows for nonlocal operators.
 This is the default mode to run hybrid functionals, meta-GGA functionals, or DFT+U.
 It can be more convenient to use <tt>kohn-sham</tt> DFT within the OEP scheme to get similar (but not the same) results.
 Note that within this scheme you can use a correlation functional, or a hybrid
 functional (see <tt>XCFunctional</tt>). In the latter case, you will be following the
 quantum-chemistry recipe to use hybrids.
</li>
<li><b>rdmft</b>:  (Experimental) Reduced Density Matrix functional theory.
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='TimeZero'></a>TimeZero</b>
<br/><i>Section</i>: Hamiltonian
<br/><i>Type</i>: logical
<br/><i>Default</i>: no
<br/><br> (Experimental) If set to yes, the ground state and other time
 dependent calculation will assume that they are done at time
 zero, so that all time depedent field at that time will be
 included.

</p><hr width='30%' align='left'/>

<a name='Hamiltonian::DFT+U'</a>
<H2>Hamiltonian::DFT+U</H2>


<p><b><a name='ACBN0IntersiteCutoff'></a>ACBN0IntersiteCutoff</b>
<br/><i>Section</i>: Hamiltonian::DFT+U
<br/><i>Type</i>: float
<br/><br> The cutoff radius defining the maximal intersite distance considered.
 Only available with ACBN0 functional with intersite interaction.

</p><hr width='30%' align='left'/>


<p><b><a name='ACBN0IntersiteInteraction'></a>ACBN0IntersiteInteraction</b>
<br/><i>Section</i>: Hamiltonian::DFT+U
<br/><i>Type</i>: logical
<br/><i>Default</i>: no
<br/><br> If set to yes, Octopus will determine the effective intersite interaction V
 Only available with ACBN0 functional.
 It is strongly recommended to set AOLoewdin=yes when using the option.

</p><hr width='30%' align='left'/>


<p><b><a name='ACBN0RotationallyInvariant'></a>ACBN0RotationallyInvariant</b>
<br/><i>Section</i>: Hamiltonian::DFT+U
<br/><i>Type</i>: logical
<br/><br> If set to yes, Octopus will use for U and J a formula which is rotationally invariant.
 This is different from the original formula for U and J.
 This is activated by default, except in the case of spinors, as this is not yet implemented in this case.

</p><hr width='30%' align='left'/>


<p><b><a name='ACBN0Screening'></a>ACBN0Screening</b>
<br/><i>Section</i>: Hamiltonian::DFT+U
<br/><i>Type</i>: float
<br/><i>Default</i>: 1.0
<br/><br> If set to 0, no screening will be included in the ACBN0 functional, and the U
 will be estimated from bare Hartree-Fock. If set to 1 (default), the full screening
 of the U, as defined in the ACBN0 functional, is used.

</p><hr width='30%' align='left'/>


<p><b><a name='DFTUBasisFromStates'></a>DFTUBasisFromStates</b>
<br/><i>Section</i>: Hamiltonian::DFT+U
<br/><i>Type</i>: logical
<br/><i>Default</i>: no
<br/><br> If set to yes, Octopus will construct the localized basis from
 user-defined states. The states are taken at the Gamma point (or the first k-point of the
 states in the restart_proj folder.
 The states are defined via the block DFTUBasisStates

</p><hr width='30%' align='left'/>


<p><b><a name='DFTUBasisStates'></a>DFTUBasisStates</b>
<br/><i>Section</i>: Hamiltonian::DFT+U
<br/><i>Type</i>: block
<br/><i>Default</i>: none
<br/><br> Each line of this block contains the index of a state to be used to construct the
 localized basis. See DFTUBasisFromStates for details.

</p><hr width='30%' align='left'/>


<p><b><a name='DFTUDoubleCounting'></a>DFTUDoubleCounting</b>
<br/><i>Section</i>: Hamiltonian::DFT+U
<br/><i>Type</i>: integer
<br/><i>Default</i>: dft_u_fll
<br/><br> This variable selects which DFT+U
 double counting term is used.

<br/><i>Options</i>:
<ul>
<li><b>dft_u_fll</b>:  (Default) The Fully Localized Limit (FLL)
</li>
<li><b>dft_u_amf</b>:  (Experimental) Around mean field double counting, as defined in PRB 44, 943 (1991) and PRB 49, 14211 (1994).
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='DFTUPoissonSolver'></a>DFTUPoissonSolver</b>
<br/><i>Section</i>: Hamiltonian::DFT+U
<br/><i>Type</i>: integer
<br/><br> This variable selects which Poisson solver
 is used to compute the Coulomb integrals over a submesh.
 These are non-periodic Poisson solvers.
 The FFT Poisson solver with spherical cutoff is used by default.
<br><br>

<br/><i>Options</i>:
<ul>
<li><b>dft_u_poisson_direct</b>:  Direct Poisson solver. Slow but working in all cases.
</li>
<li><b>dft_u_poisson_isf</b>:  (Experimental) ISF Poisson solver on a submesh.
 This does not work for non-orthogonal cells nor domain parallelization.
</li>
<li><b>dft_u_poisson_psolver</b>:  (Experimental) PSolver Poisson solver on a submesh.
 This does not work for non-orthogonal cells nor domain parallelization.
 Requires the PSolver external library.
</li>
<li><b>dft_u_poisson_fft</b>:  (Default) FFT Poisson solver on a submesh.
 This uses the 0D periodic version of the FFT kernels.
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='SkipSOrbitals'></a>SkipSOrbitals</b>
<br/><i>Section</i>: Hamiltonian::DFT+U
<br/><i>Type</i>: logical
<br/><i>Default</i>: no
<br/><br> If set to yes, Octopus will determine the effective U for all atomic orbitals
 from the peusopotential but s orbitals. Only available with ACBN0 functional.

</p><hr width='30%' align='left'/>


<p><b><a name='UseAllAtomicOrbitals'></a>UseAllAtomicOrbitals</b>
<br/><i>Section</i>: Hamiltonian::DFT+U
<br/><i>Type</i>: logical
<br/><i>Default</i>: no
<br/><br> If set to yes, Octopus will determine the effective U for all atomic orbitals
 from the peusopotential. Only available with ACBN0 functional.
 It is strongly recommended to set AOLoewdin=yes when using the option.

</p><hr width='30%' align='left'/>

<a name='Hamiltonian::PCM'</a>
<H2>Hamiltonian::PCM</H2>


<p><b><a name='PCMCalcMethod'></a>PCMCalcMethod</b>
<br/><i>Section</i>: Hamiltonian::PCM
<br/><i>Type</i>: integer
<br/><i>Default</i>: pcm_direct
<br/><br> Defines the method to be used to obtain the PCM potential.

<br/><i>Options</i>:
<ul>
<li><b>pcm_direct</b>:  Direct sum of the potential generated by the polarization charges regularized
 with a Gaussian smearing [A. Delgado, et al., J Chem Phys 143, 144111 (2015)].
</li>
<li><b>pcm_poisson</b>:  Solving the Poisson equation for the polarization charge density.
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='PCMCalculation'></a>PCMCalculation</b>
<br/><i>Section</i>: Hamiltonian::PCM
<br/><i>Type</i>: logical
<br/><i>Default</i>: no
<br/><br> If true, the calculation is performed accounting for solvation effects
 by using the Integral Equation Formalism Polarizable Continuum Model IEF-PCM
 formulated in real-space and real-time (<i>J. Chem. Phys.</i> <b>143</b>, 144111 (2015),
 <i>Chem. Rev.</i> <b>105</b>, 2999 (2005), <i>J. Chem. Phys.</i> <b>139</b>, 024105 (2013)).
 At the moment, this option is available only for <tt>TheoryLevel = DFT</tt>.
 PCM is tested for CalculationMode = gs, while still experimental for other values (in particular, CalculationMode = td).

</p><hr width='30%' align='left'/>


<p><b><a name='PCMCavity'></a>PCMCavity</b>
<br/><i>Section</i>: Hamiltonian::PCM
<br/><i>Type</i>: string
<br/><br> Name of the file containing the geometry of the cavity hosting the solute molecule.
 The data must be in atomic units and the file must contain the following information sequentially:
  T               < Number of tesserae
  s_x(1:T)        < coordinates x of the tesserae
  s_y(1:T)        < coordinates y of the tesserae
  s_z(1:T)        < coordinates z of the tesserae
  A(1:T)          < areas of the tesserae
  R_sph(1:T)      < Radii of the spheres to which the tesserae belong
  normal(1:T,1:3) < Outgoing unitary vectors at the tesserae surfaces

</p><hr width='30%' align='left'/>


<p><b><a name='PCMChargeSmearNN'></a>PCMChargeSmearNN</b>
<br/><i>Section</i>: Hamiltonian::PCM
<br/><i>Type</i>: integer
<br/><i>Default</i>: 2 * max_area * PCMSmearingFactor
<br/><br> Defines the number of nearest neighbor mesh-points to be taken around each
 cavity tessera in order to smear the charge when PCMCalcMethod = pcm_poisson.
 Setting PCMChargeSmearNN = 1 means first nearest neighbors, PCMChargeSmearNN = 2
 second nearest neighbors, and so on.
 The default value is such that the neighbor mesh contains points in a radius
 equal to the width used for the gaussian smearing.

</p><hr width='30%' align='left'/>


<p><b><a name='PCMDebyeRelaxTime'></a>PCMDebyeRelaxTime</b>
<br/><i>Section</i>: Hamiltonian::PCM
<br/><i>Type</i>: float
<br/><i>Default</i>: 0.0
<br/><br> Relaxation time of the solvent within Debye model (\(\tau\)). Recall Debye dieletric function:
 \(\varepsilon(\omega)=\varepsilon_d+\frac{\varepsilon_0-\varepsilon_d}{1-i\omega\tau}\)

</p><hr width='30%' align='left'/>


<p><b><a name='PCMDrudeLDamping'></a>PCMDrudeLDamping</b>
<br/><i>Section</i>: Hamiltonian::PCM
<br/><i>Type</i>: float
<br/><i>Default</i>: 0.0
<br/><br> Damping factor of the solvent charges oscillations within Drude-Lorentz model (\(\gamma\)).
 Recall Drude-Lorentz dielectric function: \(\varepsilon(\omega)=1+\frac{A}{\omega_0^2-\omega^2+i\gamma\omega}\)

</p><hr width='30%' align='left'/>


<p><b><a name='PCMDrudeLOmega'></a>PCMDrudeLOmega</b>
<br/><i>Section</i>: Hamiltonian::PCM
<br/><i>Type</i>: float
<br/><i>Default</i>: \(\sqrt{1/(\varepsilon_0-1)}\)
<br/><br> Resonance frequency of the solvent within Drude-Lorentz model (\(\omega_0\)).
 Recall Drude-Lorentz dielectric function: \(\varepsilon(\omega)=1+\frac{A}{\omega_0^2-\omega^2+i\gamma\omega}\)
 Default values of \(\omega_0\) guarantee to recover static dielectric constant.

</p><hr width='30%' align='left'/>


<p><b><a name='PCMDynamicEpsilon'></a>PCMDynamicEpsilon</b>
<br/><i>Section</i>: Hamiltonian::PCM
<br/><i>Type</i>: float
<br/><i>Default</i>: PCMStaticEpsilon
<br/><br> High-frequency dielectric constant of the solvent (\(\varepsilon_d\)).
 \(\varepsilon_d=\varepsilon_0\) indicate equilibrium with solvent.

</p><hr width='30%' align='left'/>


<p><b><a name='PCMEoMInitialCharges'></a>PCMEoMInitialCharges</b>
<br/><i>Section</i>: Hamiltonian::PCM
<br/><i>Type</i>: integer
<br/><i>Default</i>: 0
<br/><br> If =0 the propagation of the solvent polarization charges starts from internally generated initial charges
  in equilibrium with the initial potential.
 For Debye EOM-PCM, if >0 the propagation of the solvent polarization charges starts from initial charges from input file.
 										if =1, initial pol. charges due to solute electrons are read from input file.
 										else if =2, initial pol. charges due to external potential are read from input file.
 										else if =3, initial pol. charges due to solute electrons and external potential are read from input file.
 Files should be located in pcm directory and are called ASC_e.dat and ASC_ext.dat, respectively.
 The latter files are generated after any PCM run and contain the last values of the polarization charges.

</p><hr width='30%' align='left'/>


<p><b><a name='PCMEpsilonModel'></a>PCMEpsilonModel</b>
<br/><i>Section</i>: Hamiltonian::PCM
<br/><i>Type</i>: integer
<br/><i>Default</i>: pcm_debye
<br/><br> Define the dielectric function model.

<br/><i>Options</i>:
<ul>
<li><b>pcm_debye</b>:  Debye model: \(\varepsilon(\omega)=\varepsilon_d+\frac{\varepsilon_0-\varepsilon_d}{1-i\omega\tau}\)
</li>
<li><b>pcm_drude</b>:  Drude-Lorentz model: \(\varepsilon(\omega)=1+\frac{A}{\omega_0^2-\omega^2+i\gamma\omega}\)
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='PCMGamessBenchmark'></a>PCMGamessBenchmark</b>
<br/><i>Section</i>: Hamiltonian::PCM
<br/><i>Type</i>: logical
<br/><i>Default</i>: .false.
<br/><br> If PCMGamessBenchmark is set to "yes", the pcm_matrix is also written in a Gamess format.
 for benchamarking purposes.

</p><hr width='30%' align='left'/>


<p><b><a name='PCMKick'></a>PCMKick</b>
<br/><i>Section</i>: Hamiltonian::PCM
<br/><i>Type</i>: logical
<br/><i>Default</i>: no
<br/><br> This variable controls the effect the kick has on the polarization of the solvent.
 If .true.  ONLY the FAST degrees-of-freedom of the solvent follow the kick. The potential due to polarization charges behaves
  as another kick, i.e., it is a delta-perturbation.
 If .false. ALL           degrees-of-freedom of the solvent follow the kick. The potential due to polarization charges evolves
  following an equation of motion. When Debye dielectric model is used, just a part of the potential behaves as another kick.

</p><hr width='30%' align='left'/>


<p><b><a name='PCMLocalField'></a>PCMLocalField</b>
<br/><i>Section</i>: Hamiltonian::PCM
<br/><i>Type</i>: logical
<br/><i>Default</i>: no
<br/><br> This variable is a flag for including local field effects when an external field is applied. The total field interacting with
 the molecule (also known as cavity field) is not the bare field in the solvent (the so-called Maxwell field), but it also
 include a contribution due to the polarization of the solvent. The latter is calculated here within the PCM framework.
 See [G. Gil, et al., J. Chem. Theory Comput., 2019, 15 (4), pp 2306â€“2319].

</p><hr width='30%' align='left'/>


<p><b><a name='PCMQtotTol'></a>PCMQtotTol</b>
<br/><i>Section</i>: Hamiltonian::PCM
<br/><i>Type</i>: float
<br/><i>Default</i>: 0.5
<br/><br> If <tt>PCMRenormCharges=.true.</tt> and  \(\delta Q = |[\sum_i q_i| - ((\epsilon-1)/\epsilon)*|Q_M]|>PCMQtotTol\)
 the polarization charges will be normalized as
 \(q_i^\prime=q_i + signfunction(e, n, \delta Q) (q_i/q_{tot})*\delta Q\)
 with \(q_{tot} = \sum_i q_i\). For values of \(\delta Q > 0.5\)
 (printed by the code in the file pcm/pcm_info.out) even, if polarization charges are renormalized,
 the calculated results might be inaccurate or erroneous.

</p><hr width='30%' align='left'/>


<p><b><a name='PCMRadiusScaling'></a>PCMRadiusScaling</b>
<br/><i>Section</i>: Hamiltonian::PCM
<br/><i>Type</i>: float
<br/><br> Scales the radii of the spheres used to build the solute cavity surface.
 The default value depends on the choice of <tt>PCMVdWRadii</tt>:
 1.2 for <tt>pcm_vdw_optimized</tt> and 1.0 for <tt>pcm_vdw_species</tt>.

</p><hr width='30%' align='left'/>


<p><b><a name='PCMRenormCharges'></a>PCMRenormCharges</b>
<br/><i>Section</i>: Hamiltonian::PCM
<br/><i>Type</i>: logical
<br/><i>Default</i>: .false.
<br/><br> If .true. renormalization of the polarization charges is performed to enforce fulfillment
 of the Gauss law, \(\sum_i q_i^{e/n} = -[(\epsilon-1)/\epsilon] Q_M^{e/n}\) where
 \(q_i^{e/n}\) are the polarization charges induced by the electrons/nuclei of the molecule
 and \(Q_M^{e/n}\) is the nominal electronic/nuclear charge of the system. This can be needed
 to treat molecules in weakly polar solvents.

</p><hr width='30%' align='left'/>


<p><b><a name='PCMSmearingFactor'></a>PCMSmearingFactor</b>
<br/><i>Section</i>: Hamiltonian::PCM
<br/><i>Type</i>: float
<br/><i>Default</i>: 1.0
<br/><br> Parameter used to control the width (area of each tessera) of the Gaussians used to distribute
 the polarization charges on each tessera (arXiv:1507.05471). If set to zero, the solvent
 reaction potential in real-space is defined by using point charges.

</p><hr width='30%' align='left'/>


<p><b><a name='PCMSolute'></a>PCMSolute</b>
<br/><i>Section</i>: Hamiltonian::PCM
<br/><i>Type</i>: logical
<br/><i>Default</i>: yes
<br/><br> This variable is a flag for including polarization effects of the solvent due to the solute.
 (Useful for analysis) When external fields are applied, turning off the solvent-molecule interaction (PCMSolute=no) and
 activating the solvent polarization due to the applied field (PCMLocalField=yes) allows to include only local field effects.

</p><hr width='30%' align='left'/>


<p><b><a name='PCMSpheresOnH'></a>PCMSpheresOnH</b>
<br/><i>Section</i>: Hamiltonian::PCM
<br/><i>Type</i>: logical
<br/><i>Default</i>: no
<br/><br> If true, spheres centered at the Hydrogens atoms are included to build the solute cavity surface.

</p><hr width='30%' align='left'/>


<p><b><a name='PCMStaticEpsilon'></a>PCMStaticEpsilon</b>
<br/><i>Section</i>: Hamiltonian::PCM
<br/><i>Type</i>: float
<br/><i>Default</i>: 1.0
<br/><br> Static dielectric constant of the solvent (\(\varepsilon_0\)). 1.0 indicates gas phase.

</p><hr width='30%' align='left'/>


<p><b><a name='PCMTDLevel'></a>PCMTDLevel</b>
<br/><i>Section</i>: Hamiltonian::PCM
<br/><i>Type</i>: integer
<br/><i>Default</i>: eq
<br/><br> When CalculationMode=td, PCMTDLevel it sets the way the time-depenendent solvent polarization is propagated.

<br/><i>Options</i>:
<ul>
<li><b>eq</b>:  If PCMTDLevel=eq, the solvent is always in equilibrium with the solute or the external field, i.e.,
 the solvent polarization follows instantaneously the changes in solute density or in the external field.
 PCMTDLevel=neq and PCMTDLevel=eom are both nonequilibrium runs.
</li>
<li><b>neq</b>:  If PCMTDLevel=neq, solvent polarization charges are splitted in two terms:
 one that follows instantaneously the changes in the solute density or in the external field (dynamical polarization charges),
 and another that lag behind in the evolution w.r.t. the solute density or the external field (inertial polarization charges).
</li>
<li><b>eom</b>:  If PCMTDLevel=eom, solvent polarization charges evolves following an equation of motion, generalizing 'neq' propagation.
 The equation of motion used here depends on the value of PCMEpsilonModel.
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='PCMTessMinDistance'></a>PCMTessMinDistance</b>
<br/><i>Section</i>: Hamiltonian::PCM
<br/><i>Type</i>: float
<br/><i>Default</i>: 0.1
<br/><br> Minimum distance between tesserae.
 Any two tesserae having smaller distance in the starting tesselation will be merged together.

</p><hr width='30%' align='left'/>


<p><b><a name='PCMTessSubdivider'></a>PCMTessSubdivider</b>
<br/><i>Section</i>: Hamiltonian::PCM
<br/><i>Type</i>: integer
<br/><i>Default</i>: 1
<br/><br> Allows to subdivide further each tessera refining the discretization of the cavity tesselation.
 Can take only two values, 1 or 4. 1 corresponds to 60 tesserae per sphere, while 4 corresponds to 240 tesserae per sphere.

</p><hr width='30%' align='left'/>


<p><b><a name='PCMUpdateIter'></a>PCMUpdateIter</b>
<br/><i>Section</i>: Hamiltonian::PCM
<br/><i>Type</i>: integer
<br/><i>Default</i>: 1
<br/><br> Defines how often the PCM potential is updated during time propagation.

</p><hr width='30%' align='left'/>


<p><b><a name='PCMVdWRadii'></a>PCMVdWRadii</b>
<br/><i>Section</i>: Hamiltonian::PCM
<br/><i>Type</i>: integer
<br/><i>Default</i>: pcm_vdw_optimized
<br/><br> This variable selects which van der Waals radius will be used to generate the solvent cavity.

<br/><i>Options</i>:
<ul>
<li><b>pcm_vdw_optimized</b>:  Use the van der Waals radius optimized by Stefan Grimme in J. Comput. Chem. 27: 1787-1799, 2006,
 except for C, N and O, reported in J. Chem. Phys. 120, 3893 (2004).
</li>
<li><b>pcm_vdw_species</b>:  The vdW radii are set from the <tt>share/pseudopotentials/elements</tt> file. These values are obtained from
 Alvarez S., Dalton Trans., 2013, 42, 8617-8636. Values can be changed in the <tt>Species</tt> block.
</li>
</ul>
</p><hr width='30%' align='left'/>

<a name='Hamiltonian::Poisson'</a>
<H2>Hamiltonian::Poisson</H2>


<p><b><a name='AlphaFMM'></a>AlphaFMM</b>
<br/><i>Section</i>: Hamiltonian::Poisson
<br/><i>Type</i>: float
<br/><i>Default</i>: 0.291262136
<br/><br> Dimensionless parameter for the correction of the self-interaction of the
 electrostatic Hartree potential, when using <tt>PoissonSolver = FMM</tt>.
<br><br>
 Octopus represents charge density on a real-space grid, each
 point containing a value \(\rho\) corresponding to the charge
 density in the cell centered in such point. Therefore, the
 integral for the Hartree potential at point \(i\), \(V_H(i)\), can be reduced to a summation:
<br><br>
 \(V_H(i) = \frac{\Omega}{4\pi\varepsilon_0} \sum_{i \neq j}
 \frac{\rho(\vec{r}(j))}{|\vec{r}(j) - \vec{r}(i)|} + V_{self.int.}(i)\)
 where \(\Omega\) is the volume element of the mesh, and \(\vec{r}(j)\) is the
 position of the point \(j\). The \(V_{self.int.}(i)\) corresponds to
 the integral over the cell centered on the point \(i\) that is necessary to
 calculate the Hartree potential at point \(i\):
<br><br>
 \(V_{self.int.}(i)=\frac{1}{4\pi\varepsilon_0}
 \int_{\Omega(i)}d\vec{r} \frac{\rho(\vec{r}(i))}{|\vec{r}-\vec{r}(i)|}\)
<br><br>
 In the FMM version implemented into Octopus, a correction method
 for \(V_H(i)\) is used
 (see Garc&iacute;a-Risue&ntilde;o <i>et al.</i>, <i>J. Comp. Chem.</i> <b>35</b>, 427 (2014)).
 This method defines cells neighbouring cell \(i\), which
 have volume \(\Omega(i)/8\) (in 3D) and charge density obtained by
 interpolation. In the calculation of \(V_H(i)\), in order to avoid
 double counting of charge, and to cancel part of the errors arising
 from considering the distances constant in the summation above, a
 term \(-\alpha_{FMM}V_{self.int.}(i)\) is added to the summation (see
 the paper for the explicit formulae).

</p><hr width='30%' align='left'/>


<p><b><a name='DeltaEFMM'></a>DeltaEFMM</b>
<br/><i>Section</i>: Hamiltonian::Poisson
<br/><i>Type</i>: float
<br/><i>Default</i>: 0.0001
<br/><br> Dimensionless parameter for relative convergence of <tt>PoissonSolver = FMM</tt>.
 Sets energy error bound.
 Strong inhomogeneous systems may violate the error bound.
 For inhomogeneous systems we have an error-controlled sequential version available
 (from Ivo Kabadshow).
<br><br>
 Our implementation of FMM (based on H. Dachsel, <i>J. Chem. Phys.</i> <b>131</b>,
 244102 (2009)) can keep the error of the Hartree energy below an
 arbitrary bound. The quotient of the value chosen for the maximum
 error in the Hartree energy and the value of the Hartree energy is
 <tt>DeltaEFMM</tt>.
<br><br>

</p><hr width='30%' align='left'/>


<p><b><a name='DressedOrbitals'></a>DressedOrbitals</b>
<br/><i>Section</i>: Hamiltonian::Poisson
<br/><i>Type</i>: logical
<br/><i>Default</i>: false
<br/><br> Allows for the calculation of coupled elecron-photon problems
 by applying the dressed orbital approach. Details can be found in
 https://arxiv.org/abs/1812.05562
 At the moment, N electrons in d (<=3) spatial dimensions, coupled
 to one photon mode can be described. The photon mode is included by
 raising the orbital dimension to d+1 and changing the particle interaction
 kernel and the local potential, where the former is included automatically,
 but the latter needs to by added by hand as a user_defined_potential!
 Coordinate 1-d: electron; coordinate d+1: photon.

</p><hr width='30%' align='left'/>


<p><b><a name='Poisson1DSoftCoulombParam'></a>Poisson1DSoftCoulombParam</b>
<br/><i>Section</i>: Hamiltonian::Poisson
<br/><i>Type</i>: float
<br/><i>Default</i>: 1.0 bohr
<br/><br> When <tt>Dimensions = 1</tt>, to prevent divergence, the Coulomb interaction treated by the Poisson
 solver is not \(1/r\) but \(1/\sqrt{a^2 + r^2}\), where this variable sets the value of \(a\).

</p><hr width='30%' align='left'/>


<p><b><a name='PoissonCutoffRadius'></a>PoissonCutoffRadius</b>
<br/><i>Section</i>: Hamiltonian::Poisson
<br/><i>Type</i>: float
<br/><br> When <tt>PoissonSolver = fft</tt> and <tt>PoissonFFTKernel</tt> is neither <tt>multipole_corrections</tt>
 nor <tt>fft_nocut</tt>,
 this variable controls the distance after which the electron-electron interaction goes to zero.
 A warning will be written if the value is too large and will cause spurious interactions between images.
 The default is half of the FFT box max dimension in a finite direction.

</p><hr width='30%' align='left'/>


<p><b><a name='PoissonFFTKernel'></a>PoissonFFTKernel</b>
<br/><i>Section</i>: Hamiltonian::Poisson
<br/><i>Type</i>: integer
<br/><br> Defines which kernel is used to impose the correct boundary
 conditions when using FFTs to solve the Poisson equation. The
 default is selected depending on the dimensionality and
 periodicity of the system:
 <br>In 1D, <tt>spherical</tt> if finite, <tt>fft_nocut</tt> if periodic.
 <br>In 2D, <tt>spherical</tt> if finite, <tt>cylindrical</tt> if 1D-periodic, <tt>fft_nocut</tt> if 2D-periodic.
 <br>In 3D, <tt>spherical</tt> if finite, <tt>cylindrical</tt> if 1D-periodic, <tt>planar</tt> if 2D-periodic,
 <tt>fft_nocut</tt> if 3D-periodic.
 See C. A. Rozzi et al., <i>Phys. Rev. B</i> <b>73</b>, 205119 (2006) for 3D implementation and
 A. Castro et al., <i>Phys. Rev. B</i> <b>80</b>, 033102 (2009) for 2D implementation.

<br/><i>Options</i>:
<ul>
<li><b>spherical</b>:  FFTs using spherical cutoff (in 2D or 3D).
</li>
<li><b>cylindrical</b>:  FFTs using cylindrical cutoff (in 2D or 3D).
</li>
<li><b>planar</b>:  FFTs using planar cutoff (in 3D).
</li>
<li><b>fft_nocut</b>:  FFTs without using a cutoff (for fully periodic systems).
</li>
<li><b>multipole_correction</b>:  The boundary conditions are imposed by using a multipole expansion. Only appropriate for finite systems.
 Further specification occurs with variables <tt>PoissonSolverBoundaries</tt> and <tt>PoissonSolverMaxMultipole</tt>.
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='PoissonSolver'></a>PoissonSolver</b>
<br/><i>Section</i>: Hamiltonian::Poisson
<br/><i>Type</i>: integer
<br/><br> Defines which method to use to solve the Poisson equation. Some incompatibilities apply depending on
 dimensionality, periodicity, etc.
 For a comparison of the accuracy and performance of the methods in Octopus, see P Garcia-Risue&ntilde;o,
 J Alberdi-Rodriguez <i>et al.</i>, <i>J. Comp. Chem.</i> <b>35</b>, 427-444 (2014)
 or <a href=http://arxiv.org/abs/1211.2092>arXiV</a>.
 Defaults:
 <br> 1D and 2D: <tt>fft</tt>.
 <br> 3D: <tt>cg_corrected</tt> if curvilinear, <tt>isf</tt> if not periodic, <tt>fft</tt> if periodic.
 <br> Dressed orbitals: <tt>direct_sum</tt>.

<br/><i>Options</i>:
<ul>
<li><b>direct_sum</b>:  Direct evaluation of the Hartree potential (only for finite systems).
</li>
<li><b>FMM</b>:  (Experimental) Fast multipole method. Requires FMM library.
</li>
<li><b>NoPoisson</b>:  Do not use a Poisson solver at all.
</li>
<li><b>fft</b>:  The Poisson equation is solved using FFTs. A cutoff technique
 for the Poisson kernel is selected so the proper boundary
 conditions are imposed according to the periodicity of the
 system. This can be overridden by the <tt>PoissonFFTKernel</tt>
 variable. To choose the FFT library use <tt>FFTLibrary</tt>
</li>
<li><b>psolver</b>:  Solver based on Interpolating Scaling Functions as implemented in the PSolver library.
 Parallelization in k-points requires <tt>PoissonSolverPSolverParallelData</tt> = no.
 Requires the PSolver external library.
</li>
<li><b>poke</b>:  (Experimental) Solver from the Poke library.
</li>
<li><b>cg</b>:  Conjugate gradients (only for finite systems).
</li>
<li><b>cg_corrected</b>:  Conjugate gradients, corrected for boundary conditions (only for finite systems).
</li>
<li><b>multigrid</b>:  Multigrid method (only for finite systems).
</li>
<li><b>isf</b>:  Interpolating Scaling Functions Poisson solver (only for finite systems).
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='PoissonSolverBoundaries'></a>PoissonSolverBoundaries</b>
<br/><i>Section</i>: Hamiltonian::Poisson
<br/><i>Type</i>: integer
<br/><i>Default</i>: multipole
<br/><br> For finite systems, some Poisson solvers (<tt>multigrid</tt>,
 <tt>cg_corrected</tt>, and <tt>fft</tt> with <tt>PoissonFFTKernel = multipole_correction</tt>)
 require the calculation of the
 boundary conditions with an auxiliary method. This variable selects that method.

<br/><i>Options</i>:
<ul>
<li><b>multipole</b>:  A multipole expansion of the density is used to approximate the potential on the boundaries.
</li>
<li><b>exact</b>:  An exact integration of the Poisson equation is done over the boundaries. This option is
 experimental, and not implemented for domain parallelization.
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='PoissonSolverMaxIter'></a>PoissonSolverMaxIter</b>
<br/><i>Section</i>: Hamiltonian::Poisson
<br/><i>Type</i>: integer
<br/><i>Default</i>: 500
<br/><br> The maximum number of iterations for conjugate-gradient
 Poisson solvers.

</p><hr width='30%' align='left'/>


<p><b><a name='PoissonSolverMaxMultipole'></a>PoissonSolverMaxMultipole</b>
<br/><i>Section</i>: Hamiltonian::Poisson
<br/><i>Type</i>: integer
<br/><br> Order of the multipolar expansion for boundary corrections.
<br><br>
 The Poisson solvers <tt>multigrid</tt>, <tt>cg</tt>, and <tt>cg_corrected</tt>
 (and <tt>fft</tt> with <tt>PoissonFFTKernel = multipole_correction</tt>)
 do a multipolar expansion of the given
 charge density, such that \(\rho = \rho_{multip.expansion}+\Delta
 \rho\). The Hartree potential due to the \(\rho_{multip.expansion}\) is
 calculated analytically, while the Hartree potential due to \(\Delta \rho\)
 is calculated with either a multigrid or cg solver.
 The order of the multipolar expansion is set by this variable.
<br><br>
 Default is 4 for <tt>PoissonSolver = cg_corrected</tt> and <tt>multigrid</tt>, and 2
 for <tt>fft</tt> with <tt>PoissonFFTKernel = multipole_correction</tt>.

</p><hr width='30%' align='left'/>


<p><b><a name='PoissonSolverNodes'></a>PoissonSolverNodes</b>
<br/><i>Section</i>: Hamiltonian::Poisson
<br/><i>Type</i>: integer
<br/><i>Default</i>: 0
<br/><br> How many nodes to use to solve the Poisson equation. A value of
 0, the default, implies that all available nodes are used.

</p><hr width='30%' align='left'/>


<p><b><a name='PoissonSolverThreshold'></a>PoissonSolverThreshold</b>
<br/><i>Section</i>: Hamiltonian::Poisson
<br/><i>Type</i>: float
<br/><i>Default</i>: 1e-6
<br/><br> The tolerance for the Poisson solution, used by the <tt>cg</tt>,
 <tt>cg_corrected</tt>, and <tt>multigrid</tt> solvers.

</p><hr width='30%' align='left'/>


<p><b><a name='PoissonTestPeriodicThreshold'></a>PoissonTestPeriodicThreshold</b>
<br/><i>Section</i>: Hamiltonian::Poisson
<br/><i>Type</i>: float
<br/><i>Default</i>: 1e-5
<br/><br> This threshold determines the accuracy of the periodic copies of
 the Gaussian charge distribution that are taken into account when
 computing the analytical solution for periodic systems.
 Be aware that the default leads to good results for systems
 that are periodic in 1D - for 3D it is very costly because of the
 large number of copies needed.

</p><hr width='30%' align='left'/>

<a name='Hamiltonian::Poisson::Multigrid'</a>
<H2>Hamiltonian::Poisson::Multigrid</H2>


<p><b><a name='PoissonSolverMGMaxCycles'></a>PoissonSolverMGMaxCycles</b>
<br/><i>Section</i>: Hamiltonian::Poisson::Multigrid
<br/><i>Type</i>: integer
<br/><i>Default</i>: 60
<br/><br> Maximum number of multigrid cycles that are performed if
 convergence is not achieved.

</p><hr width='30%' align='left'/>


<p><b><a name='PoissonSolverMGPostsmoothingSteps'></a>PoissonSolverMGPostsmoothingSteps</b>
<br/><i>Section</i>: Hamiltonian::Poisson::Multigrid
<br/><i>Type</i>: integer
<br/><i>Default</i>: 4
<br/><br> Number of Gauss-Seidel smoothing steps after coarse-level
 correction in the multigrid Poisson solver.

</p><hr width='30%' align='left'/>


<p><b><a name='PoissonSolverMGPresmoothingSteps'></a>PoissonSolverMGPresmoothingSteps</b>
<br/><i>Section</i>: Hamiltonian::Poisson::Multigrid
<br/><i>Type</i>: integer
<br/><i>Default</i>: 1
<br/><br> Number of Gauss-Seidel smoothing steps before coarse-level
 correction in the multigrid Poisson solver.

</p><hr width='30%' align='left'/>


<p><b><a name='PoissonSolverMGRelaxationFactor'></a>PoissonSolverMGRelaxationFactor</b>
<br/><i>Section</i>: Hamiltonian::Poisson::Multigrid
<br/><i>Type</i>: float
<br/><br> Relaxation factor of the relaxation operator used for the
 multigrid method. This is mainly for debugging,
 since overrelaxation does not help in a multigrid scheme.
 The default is 1.0, except 0.6666 for the <tt>gauss_jacobi</tt> method.

</p><hr width='30%' align='left'/>


<p><b><a name='PoissonSolverMGRelaxationMethod'></a>PoissonSolverMGRelaxationMethod</b>
<br/><i>Section</i>: Hamiltonian::Poisson::Multigrid
<br/><i>Type</i>: integer
<br/><br> Method used to solve the linear system approximately in each grid for the
 multigrid procedure that solves Poisson equation. Default is <tt>gauss_seidel</tt>,
 unless curvilinear coordinates are used, in which case the default is <tt>gauss_jacobi</tt>.

<br/><i>Options</i>:
<ul>
<li><b>gauss_seidel</b>:  Gauss-Seidel.
</li>
<li><b>gauss_jacobi</b>:  Gauss-Jacobi.
</li>
<li><b>gauss_jacobi2</b>:  Alternative implementation of Gauss-Jacobi.
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='PoissonSolverMGRestrictionMethod'></a>PoissonSolverMGRestrictionMethod</b>
<br/><i>Section</i>: Hamiltonian::Poisson::Multigrid
<br/><i>Type</i>: integer
<br/><i>Default</i>: fullweight
<br/><br> Method used from fine-to-coarse grid transfer.

<br/><i>Options</i>:
<ul>
<li><b>injection</b>:  Injection
</li>
<li><b>fullweight</b>:  Fullweight restriction
</li>
</ul>
</p><hr width='30%' align='left'/>

<a name='Hamiltonian::Poisson::PSolver'</a>
<H2>Hamiltonian::Poisson::PSolver</H2>


<p><b><a name='PoissonSolverPSolverParallelData'></a>PoissonSolverPSolverParallelData</b>
<br/><i>Section</i>: Hamiltonian::Poisson::PSolver
<br/><i>Type</i>: logical
<br/><i>Default</i>: yes
<br/><br> Indicates whether data is partitioned within the PSolver library.
 If data is distributed among processes, Octopus uses parallel data-structures
 and, thus, less memory.
 If "yes", data is parallelized. The <i>z</i>-axis of the input vector
 is split among the MPI processes.
 If "no", entire input and output vector is saved in all the MPI processes.
 If k-points parallelization is used, "no" must be selected.

</p><hr width='30%' align='left'/>

<a name='Hamiltonian::XC'</a>
<H2>Hamiltonian::XC</H2>


<p><b><a name='DFTULevel'></a>DFTULevel</b>
<br/><i>Section</i>: Hamiltonian::XC
<br/><i>Type</i>: integer
<br/><i>Default</i>: no
<br/><br> This variable selects which DFT+U expression is added to the Hamiltonian.

<br/><i>Options</i>:
<ul>
<li><b>dft_u_none</b>:  No +U term is not applied.
</li>
<li><b>dft_u_empirical</b>:  An empiricial Hubbard U is added on the orbitals specified in the block species
 with hubbard_l and hubbard_u
</li>
<li><b>dft_u_acbn0</b>:  Octopus determines the effective U term using the
 ACBN0 functional as defined in PRX 5, 011006 (2015)
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='HFSingularity'></a>HFSingularity</b>
<br/><i>Section</i>: Hamiltonian::XC
<br/><i>Type</i>: integer
<br/><i>Default</i>: general
<br/><br> (Experimental) This variable selects the method used for the treatment of the
 singularity of the Coulomb potential in Hatree-Fock and hybrid-functional DFT calculations.
 This shoulbe be only applied for periodic systems and is only
 used for FFT kernels of the Poisson solvers.

<br/><i>Options</i>:
<ul>
<li><b>none</b>:  The singularity is replaced by zero.
</li>
<li><b>general</b>:  The general treatment of the singularity, as described in Carrier et al, PRB 75 205126 (2007).
 This is the default option
</li>
<li><b>fcc</b>:  The treatment of the singulariy as described in Gygi and Baldereschi, PRB 34, 4405 (1986).
 This is formally valid for cubic systems only.
</li>
<li><b>spherical_bz</b>:  The divergence in q=0 is treated analytically assuming a spherical Brillouin zone
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='HFSingularityNk'></a>HFSingularityNk</b>
<br/><i>Section</i>: Hamiltonian::XC
<br/><i>Type</i>: integer
<br/><i>Default</i>: 60 in 3D, 1200 in 1D
<br/><br> Number of k-point used (total number of k-points) is (2*Nk+1)^3) in the numerical integration
 of the auxiliary function f(q). See PRB 75, 205126 (2007) for more details.
 Only for HFSingularity=general.
 Also used in 1D.

</p><hr width='30%' align='left'/>


<p><b><a name='HFSingularityNsteps'></a>HFSingularityNsteps</b>
<br/><i>Section</i>: Hamiltonian::XC
<br/><i>Type</i>: integer
<br/><i>Default</i>: 7 in 3D, 15 in 1D
<br/><br> Number of grid refinement steps in the numerical integration of the auxiliary function f(q).
 See PRB 75, 205126 (2007) for more details. Only for HFSingularity=general.
 Also used in 1D.

</p><hr width='30%' align='left'/>


<p><b><a name='Interaction1D'></a>Interaction1D</b>
<br/><i>Section</i>: Hamiltonian::XC
<br/><i>Type</i>: integer
<br/><i>Default</i>: interaction_soft_coulomb
<br/><br> When running in 1D, one has to soften the Coulomb interaction. This softening
 is not unique, and several possibilities exist in the literature.

<br/><i>Options</i>:
<ul>
<li><b>interaction_exp_screened</b>:  Exponentially screened Coulomb interaction.
 See, <i>e.g.</i>, M Casula, S Sorella, and G Senatore, <i>Phys. Rev. B</i> <b>74</b>, 245427 (2006).
</li>
<li><b>interaction_soft_coulomb</b>:  Soft Coulomb interaction of the form \(1/\sqrt{x^2 + \alpha^2}\).
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='Interaction1DScreening'></a>Interaction1DScreening</b>
<br/><i>Section</i>: Hamiltonian::XC
<br/><i>Type</i>: float
<br/><i>Default</i>: 1.0
<br/><br> Defines the screening parameter \(\alpha\) of the softened Coulomb interaction
 when running in 1D.

</p><hr width='30%' align='left'/>


<p><b><a name='KLIPhotonCOC'></a>KLIPhotonCOC</b>
<br/><i>Section</i>: Hamiltonian::XC
<br/><i>Type</i>: logical
<br/><i>Default</i>: .false.
<br/><br> Activate the center of charge translation of the electric dipole operator which should avoid the dependence of the photon KLI on an permanent dipole.

</p><hr width='30%' align='left'/>


<p><b><a name='OEPLevel'></a>OEPLevel</b>
<br/><i>Section</i>: Hamiltonian::XC
<br/><i>Type</i>: integer
<br/><i>Default</i>: oep_kli
<br/><br> At what level shall <tt>Octopus</tt> handle the optimized effective potential (OEP) equation.

<br/><i>Options</i>:
<ul>
<li><b>oep_none</b>:  Do not solve OEP equation.
</li>
<li><b>oep_kli</b>:  Krieger-Li-Iafrate (KLI) approximation.
 Ref: JB Krieger, Y Li, GJ Iafrate, <i>Phys. Lett. A</i> <b>146</b>, 256 (1990).
</li>
<li><b>oep_full</b>:  (Experimental) Full solution of OEP equation using the Sternheimer approach.
 The linear solver will be controlled by the variables in section <tt>Linear Response::Solver</tt>,
 and the iterations for OEP by <tt>Linear Response::SCF in LR calculations</tt> and variable
 <tt>OEPMixing</tt>. Note that default for <tt>LRMaximumIter</tt> is set to 10.
 Ref: S. Kuemmel and J. Perdew, <i>Phys. Rev. Lett.</i> <b>90</b>, 043004 (2003).
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='OEPMixing'></a>OEPMixing</b>
<br/><i>Section</i>: Hamiltonian::XC
<br/><i>Type</i>: float
<br/><i>Default</i>: 1.0
<br/><br> The linear mixing factor used to solve the Sternheimer
 equation in the full OEP procedure.

</p><hr width='30%' align='left'/>


<p><b><a name='OEPMixingScheme'></a>OEPMixingScheme</b>
<br/><i>Section</i>: Hamiltonian::XC
<br/><i>Type</i>: integer
<br/><i>Default</i>: 1.0
<br/><br> Different Mixing Schemes are possible

<br/><i>Options</i>:
<ul>
<li><b>OEP_MIXING_SCHEME_CONST</b>:  Use a constant
 Reference: S. Kuemmel and J. Perdew, <i>Phys. Rev. Lett.</i> <b>90</b>, 4, 043004 (2003)
</li>
<li><b>OEP_MIXING_SCHEME_BB</b>:  Use the Barzilai-Borwein (BB) Method
 Reference: T. W. Hollins, S. J. Clark, K. Refson, and N. I. Gidopoulos,
 <i>Phys. Rev. B</i> <b>85</b>, 235126 (2012)
</li>
<li><b>OEP_MIXING_SCHEME_DENS</b>:  Use the inverse of the electron density
 Reference: S. Kuemmel and J. Perdew, <i>Phys. Rev. B</i> <b>68</b>, 035103 (2003)
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='PhotonModes'></a>PhotonModes</b>
<br/><i>Section</i>: Hamiltonian::XC
<br/><i>Type</i>: block
<br/><br> Each line of the block should specify one photon mode. The syntax is the following:
<br><br>
 %PhotonModes
  omega1 | lambda1| PolX1 | PolY1 | PolZ1
  ...
 %
<br><br>
 The first column is the mode frequency, in units of energy.
 The second column is the coupling strength, in units of energy.
 The remaining columns specify the polarization direction of the mode.
 If the polarization vector should be normalized to one. If that is not the case
 the code will normalize it.

</p><hr width='30%' align='left'/>


<p><b><a name='SICCorrection'></a>SICCorrection</b>
<br/><i>Section</i>: Hamiltonian::XC
<br/><i>Type</i>: integer
<br/><i>Default</i>: sic_none
<br/><br> This variable controls which form of self-interaction correction to use. Note that
 this correction will be applied to the functional chosen by <tt>XCFunctional</tt>.

<br/><i>Options</i>:
<ul>
<li><b>sic_none</b>:  No self-interaction correction.
</li>
<li><b>sic_pz</b>:  Perdew-Zunger SIC, handled by the OEP technique.
</li>
<li><b>sic_amaldi</b>:  Amaldi correction term.
</li>
<li><b>sic_adsic</b>:  Average-density SIC.
 C. Legrand <i>et al.</i>, <i>J. Phys. B</i> <b>35</b>, 1115 (2002).
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='VDWCorrection'></a>VDWCorrection</b>
<br/><i>Section</i>: Hamiltonian::XC
<br/><i>Type</i>: integer
<br/><i>Default</i>: no
<br/><br> (Experimental) This variable selects which van der Waals
 correction to apply to the correlation functional.

<br/><i>Options</i>:
<ul>
<li><b>none</b>:  No correction is applied.
</li>
<li><b>vdw_ts</b>:  The scheme of Tkatchenko and Scheffler, Phys. Rev. Lett. 102
 073005 (2009).
</li>
<li><b>vdw_d3</b>:  The DFT-D3 scheme of S. Grimme, J. Antony, S. Ehrlich, and
 S. Krieg, J. Chem. Phys. 132, 154104 (2010).
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='VDWD3Functional'></a>VDWD3Functional</b>
<br/><i>Section</i>: Hamiltonian::XC
<br/><i>Type</i>: string
<br/><br> (Experimental) You can use this variable to override the
 parametrization used by the DFT-D3 van deer Waals
 correction. Normally you need not set this variable, as the
 proper value will be selected by Octopus (if available).
<br><br>
 This variable takes a string value, the valid values can
 be found in the source file 'external_libs/dftd3/core.f90'.
 For example you can use:
<br><br>
  VDWD3Functional = 'pbe'
<br><br>

</p><hr width='30%' align='left'/>


<p><b><a name='VDWSelfConsistent'></a>VDWSelfConsistent</b>
<br/><i>Section</i>: Hamiltonian::XC
<br/><i>Type</i>: logical
<br/><i>Default</i>: yes
<br/><br> This variable controls whether the VDW correction is applied
 self-consistently, the default, or just as a correction to
 the total energy. This option only works with vdw_ts.

</p><hr width='30%' align='left'/>


<p><b><a name='VDW_TS_cutoff'></a>VDW_TS_cutoff</b>
<br/><i>Section</i>: Hamiltonian::XC
<br/><i>Type</i>: float
<br/><i>Default</i>: 10.0
<br/><br> Set the value of the cutoff (unit of length) for the VDW correction in periodic system
 in the Tkatchenko and Scheffler (vdw_ts) scheme only.

</p><hr width='30%' align='left'/>


<p><b><a name='VDW_TS_damping'></a>VDW_TS_damping</b>
<br/><i>Section</i>: Hamiltonian::XC
<br/><i>Type</i>: float
<br/><i>Default</i>: 20.0
<br/><br> Set the value of the damping function (in unit of 1/length) steepness for the VDW correction in the
 Tkatchenko-Scheffler scheme. See Equation (12) of Phys. Rev. Lett. 102 073005 (2009).

</p><hr width='30%' align='left'/>


<p><b><a name='VDW_TS_sr'></a>VDW_TS_sr</b>
<br/><i>Section</i>: Hamiltonian::XC
<br/><i>Type</i>: float
<br/><i>Default</i>: 0.94
<br/><br> Set the value of the sr parameter in the damping function of the VDW correction in the
 Tkatchenko-Scheffler scheme. See Equation (12) of Phys. Rev. Lett. 102 073005 (2009).
 This parameter depends on the xc functional used.
 The default value is 0.94, which holds for PBE. For PBE0, a value of 0.96 should be used.

</p><hr width='30%' align='left'/>


<p><b><a name='XCFunctional'></a>XCFunctional</b>
<br/><i>Section</i>: Hamiltonian::XC
<br/><i>Type</i>: integer
<br/><br> Defines the exchange and correlation functionals to be used,
 specified as a sum of an exchange functional and a
 correlation functional, or a single exchange-correlation functional
 (<i>e.g.</i> <tt>hyb_gga_xc_pbeh</tt>). For more information on the functionals, see
 <a href=https://gitlab.com/libxc/libxc/wikis/Functionals-list-4.0.4>
 Libxc documentation</a>. The list provided here is from libxc 4; if you have
 linked against a different libxc version, you may have a somewhat different set
 of available functionals. Note that kinetic-energy functionals are not supported.
<br><br>
 The default functional will be selected by Octopus to be consistent
 with the pseudopotentials you are using. If you are not using
 pseudopotentials, Octopus cannot determine the functional used to
 generate the pseudopotential, or the pseudopotential functionals
 are inconsistent, Octopus will use the following defaults:
<br><br>
 <br>1D: <tt>lda_x_1d + lda_c_1d_csc</tt>
 <br>2D: <tt>lda_x_2d + lda_c_2d_amgb</tt>
 <br>3D: <tt>lda_x + lda_c_pz_mod</tt>

<br/><i>Options</i>:
<ul>
<li><b>none</b>:  Exchange and correlation set to zero (not from libxc).
</li>
<li><b>gga_c_tca</b>:  Tognetti, Cortona, Adamo
</li>
<li><b>lda_c_pz_mod</b>:  Perdew & Zunger (Modified)
</li>
<li><b>gga_x_pbe</b>:  Perdew, Burke & Ernzerhof exchange
</li>
<li><b>gga_x_pbe_r</b>:  Perdew, Burke & Ernzerhof exchange (revised)
</li>
<li><b>gga_x_b86</b>:  Becke 86 Xalpha,beta,gamma
</li>
<li><b>gga_x_herman</b>:  Herman et al original GGA
</li>
<li><b>gga_x_b86_mgc</b>:  Becke 86 Xalpha,beta,gamma (with mod. grad. correction)
</li>
<li><b>gga_x_b88</b>:  Becke 88
</li>
<li><b>gga_x_g96</b>:  Gill 96
</li>
<li><b>gga_x_pw86</b>:  Perdew & Wang 86
</li>
<li><b>gga_x_pw91</b>:  Perdew & Wang 91
</li>
<li><b>lda_c_ob_pz</b>:  Ortiz & Ballone (PZ)
</li>
<li><b>gga_x_optx</b>:  Handy & Cohen OPTX 01
</li>
<li><b>gga_x_dk87_r1</b>:  dePristo & Kress 87 (version R1)
</li>
<li><b>gga_x_dk87_r2</b>:  dePristo & Kress 87 (version R2)
</li>
<li><b>gga_x_lg93</b>:  Lacks & Gordon 93
</li>
<li><b>gga_x_ft97_a</b>:  Filatov & Thiel 97 (version A)
</li>
<li><b>gga_x_ft97_b</b>:  Filatov & Thiel 97 (version B)
</li>
<li><b>gga_x_pbe_sol</b>:  Perdew, Burke & Ernzerhof exchange (solids)
</li>
<li><b>gga_x_rpbe</b>:  Hammer, Hansen & Norskov (PBE-like)
</li>
<li><b>gga_x_wc</b>:  Wu & Cohen
</li>
<li><b>gga_x_mpw91</b>:  Modified form of PW91 by Adamo & Barone
</li>
<li><b>lda_c_pw</b>:  Perdew & Wang
</li>
<li><b>gga_x_am05</b>:  Armiento & Mattsson 05 exchange
</li>
<li><b>gga_x_pbea</b>:  Madsen (PBE-like)
</li>
<li><b>gga_x_mpbe</b>:  Adamo & Barone modification to PBE
</li>
<li><b>gga_x_xpbe</b>:  xPBE reparametrization by Xu & Goddard
</li>
<li><b>gga_x_2d_b86_mgc</b>:  Becke 86 MGC for 2D systems
</li>
<li><b>gga_x_bayesian</b>:  Bayesian best fit for the enhancement factor
</li>
<li><b>gga_x_pbe_jsjr</b>:  JSJR reparametrization by Pedroza, Silva & Capelle
</li>
<li><b>gga_x_2d_b88</b>:  Becke 88 in 2D
</li>
<li><b>gga_x_2d_b86</b>:  Becke 86 Xalpha,beta,gamma
</li>
<li><b>gga_x_2d_pbe</b>:  Perdew, Burke & Ernzerhof exchange in 2D
</li>
<li><b>gga_c_pbe</b>:  Perdew, Burke & Ernzerhof correlation
</li>
<li><b>lda_c_pw_mod</b>:  Perdew & Wang (Modified)
</li>
<li><b>gga_c_lyp</b>:  Lee, Yang & Parr
</li>
<li><b>gga_c_p86</b>:  Perdew 86
</li>
<li><b>gga_c_pbe_sol</b>:  Perdew, Burke & Ernzerhof correlation SOL
</li>
<li><b>gga_c_pw91</b>:  Perdew & Wang 91
</li>
<li><b>gga_c_am05</b>:  Armiento & Mattsson 05 correlation
</li>
<li><b>gga_c_xpbe</b>:  xPBE reparametrization by Xu & Goddard
</li>
<li><b>gga_c_lm</b>:  Langreth and Mehl correlation
</li>
<li><b>gga_c_pbe_jrgx</b>:  JRGX reparametrization by Pedroza, Silva & Capelle
</li>
<li><b>gga_x_optb88_vdw</b>:  Becke 88 reoptimized to be used with vdW functional of Dion et al
</li>
<li><b>lda_c_ob_pw</b>:  Ortiz & Ballone (PW)
</li>
<li><b>gga_x_pbek1_vdw</b>:  PBE reparametrization for vdW
</li>
<li><b>gga_x_optpbe_vdw</b>:  PBE reparametrization for vdW
</li>
<li><b>gga_x_rge2</b>:  Regularized PBE
</li>
<li><b>gga_c_rge2</b>:  Regularized PBE
</li>
<li><b>gga_x_rpw86</b>:  refitted Perdew & Wang 86
</li>
<li><b>gga_x_kt1</b>:  Exchange part of Keal and Tozer version 1
</li>
<li><b>gga_xc_kt2</b>:  Keal and Tozer version 2
</li>
<li><b>gga_c_wl</b>:  Wilson & Levy
</li>
<li><b>gga_c_wi</b>:  Wilson & Ivanov
</li>
<li><b>gga_x_mb88</b>:  Modified Becke 88 for proton transfer
</li>
<li><b>lda_c_2d_amgb</b>:  Attaccalite et al
</li>
<li><b>gga_x_sogga</b>:  Second-order generalized gradient approximation
</li>
<li><b>gga_x_sogga11</b>:  Second-order generalized gradient approximation 2011
</li>
<li><b>gga_c_sogga11</b>:  Second-order generalized gradient approximation 2011
</li>
<li><b>gga_c_wi0</b>:  Wilson & Ivanov initial version
</li>
<li><b>gga_xc_th1</b>:  Tozer and Handy v. 1
</li>
<li><b>gga_xc_th2</b>:  Tozer and Handy v. 2
</li>
<li><b>gga_xc_th3</b>:  Tozer and Handy v. 3
</li>
<li><b>gga_xc_th4</b>:  Tozer and Handy v. 4
</li>
<li><b>gga_x_c09x</b>:  C09x to be used with the VdW of Rutgers-Chalmers
</li>
<li><b>gga_c_sogga11_x</b>:  To be used with HYB_GGA_X_SOGGA11_X
</li>
<li><b>lda_c_2d_prm</b>:  Pittalis, Rasanen & Marques correlation in 2D
</li>
<li><b>gga_x_lb</b>:  van Leeuwen & Baerends
</li>
<li><b>gga_xc_hcth_93</b>:  HCTH functional fitted to  93 molecules
</li>
<li><b>gga_xc_hcth_120</b>:  HCTH functional fitted to 120 molecules
</li>
<li><b>gga_xc_hcth_147</b>:  HCTH functional fitted to 147 molecules
</li>
<li><b>gga_xc_hcth_407</b>:  HCTH functional fitted to 407 molecules
</li>
<li><b>gga_xc_edf1</b>:  Empirical functionals from Adamson, Gill, and Pople
</li>
<li><b>gga_xc_xlyp</b>:  XLYP functional
</li>
<li><b>gga_xc_kt1</b>:  Keal and Tozer version 1
</li>
<li><b>gga_xc_b97_d</b>:  Grimme functional to be used with C6 vdW term
</li>
<li><b>lda_c_vbh</b>:  von Barth & Hedin
</li>
<li><b>gga_xc_pbe1w</b>:  Functionals fitted for water
</li>
<li><b>gga_xc_mpwlyp1w</b>:  Functionals fitted for water
</li>
<li><b>gga_xc_pbelyp1w</b>:  Functionals fitted for water
</li>
<li><b>lda_c_1d_csc</b>:  Casula, Sorella, and Senatore 1D correlation
</li>
<li><b>gga_x_lbm</b>:  van Leeuwen & Baerends modified
</li>
<li><b>gga_x_ol2</b>:  Exchange form based on Ou-Yang and Levy v.2
</li>
<li><b>gga_x_apbe</b>:  mu fixed from the semiclassical neutral atom
</li>
<li><b>gga_c_apbe</b>:  mu fixed from the semiclassical neutral atom
</li>
<li><b>gga_x_htbs</b>:  Haas, Tran, Blaha, and Schwarz
</li>
<li><b>gga_x_airy</b>:  Constantin et al based on the Airy gas
</li>
<li><b>gga_x_lag</b>:  Local Airy Gas
</li>
<li><b>gga_xc_mohlyp</b>:  Functional for organometallic chemistry
</li>
<li><b>gga_xc_mohlyp2</b>:  Functional for barrier heights
</li>
<li><b>gga_xc_th_fl</b>:  Tozer and Handy v. FL
</li>
<li><b>gga_xc_th_fc</b>:  Tozer and Handy v. FC
</li>
<li><b>gga_xc_th_fcfo</b>:  Tozer and Handy v. FCFO
</li>
<li><b>gga_xc_th_fco</b>:  Tozer and Handy v. FCO
</li>
<li><b>lda_x_2d</b>:  Exchange in 2D
</li>
<li><b>lda_x</b>:  Exchange
</li>
<li><b>gga_c_optc</b>:  Optimized correlation functional of Cohen and Handy
</li>
<li><b>lda_xc_teter93</b>:  Teter 93 parametrization
</li>
<li><b>lda_c_wigner</b>:  Wigner parametrization
</li>
<li><b>mgga_x_lta</b>:  Local tau approximation of Ernzerhof & Scuseria
</li>
<li><b>mgga_x_tpss</b>:  Tao, Perdew, Staroverov & Scuseria exchange
</li>
<li><b>mgga_x_m06_l</b>:  M06-L exchange functional from Minnesota
</li>
<li><b>mgga_x_gvt4</b>:  GVT4 from Van Voorhis and Scuseria
</li>
<li><b>mgga_x_tau_hcth</b>:  tau-HCTH from Boese and Handy
</li>
<li><b>mgga_x_br89</b>:  Becke-Roussel 89
</li>
<li><b>mgga_x_bj06</b>:  Becke & Johnson correction to Becke-Roussel 89
</li>
<li><b>mgga_x_tb09</b>:  Tran & Blaha correction to Becke & Johnson
</li>
<li><b>mgga_x_rpp09</b>:  Rasanen, Pittalis, and Proetto correction to Becke & Johnson
</li>
<li><b>mgga_x_2d_prhg07</b>:  Pittalis, Rasanen, Helbig, Gross Exchange Functional
</li>
<li><b>mgga_x_2d_prhg07_prp10</b>:  PRGH07 with PRP10 correction
</li>
<li><b>mgga_x_revtpss</b>:  revised Tao, Perdew, Staroverov & Scuseria exchange
</li>
<li><b>mgga_x_pkzb</b>:  Perdew, Kurth, Zupan, and Blaha
</li>
<li><b>lda_x_1d</b>:  Exchange in 1D
</li>
<li><b>lda_c_ml1</b>:  Modified LSD (version 1) of Proynov and Salahub
</li>
<li><b>mgga_x_ms0</b>:  MS exchange of Sun, Xiao, and Ruzsinszky
</li>
<li><b>mgga_x_ms1</b>:  MS1 exchange of Sun, et al
</li>
<li><b>mgga_x_ms2</b>:  MS2 exchange of Sun, et al
</li>
<li><b>hyb_mgga_x_ms2h</b>:  MS2 hybrid exchange of Sun, et al
</li>
<li><b>mgga_x_m11_l</b>:  M11-L exchange functional from Minnesota
</li>
<li><b>mgga_x_mn12_l</b>:  MN12-L exchange functional from Minnesota
</li>
<li><b>mgga_xc_cc06</b>:  Cancio and Chou 2006
</li>
<li><b>lda_c_ml2</b>:  Modified LSD (version 2) of Proynov and Salahub
</li>
<li><b>mgga_x_mk00</b>:  Exchange for accurate virtual orbital energies
</li>
<li><b>mgga_c_tpss</b>:  Tao, Perdew, Staroverov & Scuseria correlation
</li>
<li><b>mgga_c_vsxc</b>:  VSxc from Van Voorhis and Scuseria (correlation part)
</li>
<li><b>mgga_c_m06_l</b>:  M06-L correlation functional from Minnesota
</li>
<li><b>mgga_c_m06_hf</b>:  M06-HF correlation functional from Minnesota
</li>
<li><b>mgga_c_m06</b>:  M06 correlation functional from Minnesota
</li>
<li><b>mgga_c_m06_2x</b>:  M06-2X correlation functional from Minnesota
</li>
<li><b>mgga_c_m05</b>:  M05 correlation functional from Minnesota
</li>
<li><b>mgga_c_m05_2x</b>:  M05-2X correlation functional from Minnesota
</li>
<li><b>mgga_c_pkzb</b>:  Perdew, Kurth, Zupan, and Blaha
</li>
<li><b>mgga_c_bc95</b>:  Becke correlation 95
</li>
<li><b>lda_c_gombas</b>:  Gombas parametrization
</li>
<li><b>mgga_c_revtpss</b>:  revised TPSS correlation
</li>
<li><b>mgga_xc_tpsslyp1w</b>:  Functionals fitted for water
</li>
<li><b>mgga_x_mk00b</b>:  Exchange for accurate virtual orbital energies (v. B)
</li>
<li><b>mgga_x_bloc</b>:  functional with balanced localization
</li>
<li><b>mgga_x_modtpss</b>:  Modified Tao, Perdew, Staroverov & Scuseria exchange
</li>
<li><b>gga_c_pbeloc</b>:  Semilocal dynamical correlation
</li>
<li><b>mgga_c_tpssloc</b>:  Semilocal dynamical correlation
</li>
<li><b>hyb_mgga_x_mn12_sx</b>:  MN12-SX hybrid exchange functional from Minnesota
</li>
<li><b>mgga_x_mbeef</b>:  mBEEF exchange
</li>
<li><b>lda_c_pw_rpa</b>:  Perdew & Wang fit of the RPA
</li>
<li><b>mgga_x_mbeefvdw</b>:  mBEEF-vdW exchange
</li>
<li><b>mgga_xc_b97m_v</b>:  Mardirossian and Head-Gordon
</li>
<li><b>gga_xc_vv10</b>:  Vydrov and Van Voorhis
</li>
<li><b>mgga_x_mvs</b>:  MVS exchange of Sun, Perdew, and Ruzsinszky
</li>
<li><b>gga_c_pbefe</b>:  PBE for formation energies
</li>
<li><b>lda_xc_ksdt</b>:  Karasiev et al. parametrization
</li>
<li><b>lda_c_1d_loos</b>:  P-F Loos correlation LDA
</li>
<li><b>mgga_x_mn15_l</b>:  MN15-L exhange functional from Minnesota
</li>
<li><b>mgga_c_mn15_l</b>:  MN15-L correlation functional from Minnesota
</li>
<li><b>gga_c_op_pw91</b>:  one-parameter progressive functional (PW91 version)
</li>
<li><b>mgga_x_scan</b>:  SCAN exchange of Sun, Ruzsinszky, and Perdew
</li>
<li><b>hyb_mgga_x_scan0</b>:  SCAN hybrid exchange
</li>
<li><b>gga_x_pbefe</b>:  PBE for formation energies
</li>
<li><b>hyb_gga_xc_b97_1p</b>:  version of B97 by Cohen and Handy
</li>
<li><b>mgga_c_scan</b>:  SCAN correlation
</li>
<li><b>hyb_mgga_x_mn15</b>:  MN15 hybrid exchange functional from Minnesota
</li>
<li><b>mgga_c_mn15</b>:  MN15 correlation functional from Minnesota
</li>
<li><b>lda_c_rc04</b>:  Ragot-Cortona
</li>
<li><b>gga_x_cap</b>:  Correct Asymptotic Potential
</li>
<li><b>gga_x_eb88</b>:  Non-empirical (excogitated) B88 functional of Becke and Elliott
</li>
<li><b>gga_c_pbe_mol</b>:  Del Campo, Gazquez, Trickey and Vela (PBE-like)
</li>
<li><b>hyb_gga_xc_pbe_mol0</b>:  PBEmol0
</li>
<li><b>hyb_gga_xc_pbe_sol0</b>:  PBEsol0
</li>
<li><b>hyb_gga_xc_pbeb0</b>:  PBEbeta0
</li>
<li><b>hyb_gga_xc_pbe_molb0</b>:  PBEmolbeta0
</li>
<li><b>hyb_mgga_x_bmk</b>:  Boese-Martin for kinetics
</li>
<li><b>gga_c_bmk</b>:  Boese-Martin for kinetics
</li>
<li><b>lda_c_vwn_1</b>:  Vosko, Wilk, & Nusair (1)
</li>
<li><b>gga_c_tau_hcth</b>:  correlation part of tau-hcth
</li>
<li><b>hyb_mgga_x_tau_hcth</b>:  Hybrid version of tau-HCTH
</li>
<li><b>gga_c_hyb_tau_hcth</b>:  correlation part of hyb_tau-hcth
</li>
<li><b>mgga_x_b00</b>:  Becke 2000
</li>
<li><b>gga_x_beefvdw</b>:  BEEF-vdW exchange
</li>
<li><b>gga_xc_beefvdw</b>:  BEEF-vdW exchange-correlation
</li>
<li><b>lda_c_chachiyo</b>:  Chachiyo simple 2 parameter correlation
</li>
<li><b>mgga_xc_hle17</b>:  high local exchange 2017
</li>
<li><b>lda_c_lp96</b>:  Liu-Parr correlation
</li>
<li><b>hyb_gga_xc_pbe50</b>:  PBE0 with 50% exx
</li>
<li><b>lda_c_vwn_2</b>:  Vosko, Wilk, & Nusair (2)
</li>
<li><b>gga_x_pbetrans</b>:  Gradient-based interpolation between PBE and revPBE
</li>
<li><b>mgga_c_scan_rvv10</b>:  SCAN correlation + rVV10 correlation
</li>
<li><b>mgga_x_revm06_l</b>:  revised M06-L exchange functional from Minnesota
</li>
<li><b>mgga_c_revm06_l</b>:  Revised M06-L correlation functional from Minnesota
</li>
<li><b>hyb_mgga_x_m08_hx</b>:  M08-HX exchange functional from Minnesota
</li>
<li><b>hyb_mgga_x_m08_so</b>:  M08-SO exchange functional from Minnesota
</li>
<li><b>hyb_mgga_x_m11</b>:  M11 hybrid exchange functional from Minnesota
</li>
<li><b>gga_x_chachiyo</b>:  Chachiyo exchange
</li>
<li><b>lda_c_vwn_3</b>:  Vosko, Wilk, & Nusair (3)
</li>
<li><b>lda_c_rpa</b>:  Random Phase Approximation
</li>
<li><b>lda_c_vwn_4</b>:  Vosko, Wilk, & Nusair (4)
</li>
<li><b>gga_x_gam</b>:  GAM functional from Minnesota
</li>
<li><b>gga_c_gam</b>:  GAM functional from Minnesota
</li>
<li><b>gga_x_hcth_a</b>:  HCTH-A
</li>
<li><b>gga_x_ev93</b>:  Engel and Vosko
</li>
<li><b>hyb_mgga_x_dldf</b>:  Dispersionless Density Functional
</li>
<li><b>mgga_c_dldf</b>:  Dispersionless Density Functional
</li>
<li><b>gga_x_bcgp</b>:  Burke, Cancio, Gould, and Pittalis
</li>
<li><b>gga_c_bcgp</b>:  Burke, Cancio, Gould, and Pittalis
</li>
<li><b>lda_c_hl</b>:  Hedin & Lundqvist
</li>
<li><b>hyb_gga_xc_b3pw91</b>:  The original (ACM) hybrid of Becke
</li>
<li><b>hyb_gga_xc_b3lyp</b>:  The (in)famous B3LYP
</li>
<li><b>hyb_gga_xc_b3p86</b>:  Perdew 86 hybrid similar to B3PW91
</li>
<li><b>hyb_gga_xc_o3lyp</b>:  hybrid using the optx functional
</li>
<li><b>hyb_gga_xc_mpw1k</b>:  mixture of mPW91 and PW91 optimized for kinetics
</li>
<li><b>hyb_gga_xc_pbeh</b>:  aka PBE0 or PBE1PBE
</li>
<li><b>hyb_gga_xc_b97</b>:  Becke 97
</li>
<li><b>hyb_gga_xc_b97_1</b>:  Becke 97-1
</li>
<li><b>gga_x_lambda_oc2_n</b>:  lambda_OC2(N) version of PBE
</li>
<li><b>hyb_gga_xc_b97_2</b>:  Becke 97-2
</li>
<li><b>hyb_gga_xc_x3lyp</b>:  hybrid by Xu and Goddard
</li>
<li><b>hyb_gga_xc_b1wc</b>:  Becke 1-parameter mixture of WC and PBE
</li>
<li><b>hyb_gga_xc_b97_k</b>:  Boese-Martin for Kinetics
</li>
<li><b>hyb_gga_xc_b97_3</b>:  Becke 97-3
</li>
<li><b>hyb_gga_xc_mpw3pw</b>:  mixture with the mPW functional
</li>
<li><b>hyb_gga_xc_b1lyp</b>:  Becke 1-parameter mixture of B88 and LYP
</li>
<li><b>hyb_gga_xc_b1pw91</b>:  Becke 1-parameter mixture of B88 and PW91
</li>
<li><b>hyb_gga_xc_mpw1pw</b>:  Becke 1-parameter mixture of mPW91 and PW91
</li>
<li><b>hyb_gga_xc_mpw3lyp</b>:  mixture of mPW and LYP
</li>
<li><b>gga_x_b86_r</b>:  Revised Becke 86 Xalpha,beta,gamma (with mod. grad. correction)
</li>
<li><b>hyb_gga_xc_sb98_1a</b>:  Schmider-Becke 98 parameterization 1a
</li>
<li><b>mgga_xc_zlp</b>:  Zhao, Levy & Parr, Eq. (21)
</li>
<li><b>hyb_gga_xc_sb98_1b</b>:  Schmider-Becke 98 parameterization 1b
</li>
<li><b>hyb_gga_xc_sb98_1c</b>:  Schmider-Becke 98 parameterization 1c
</li>
<li><b>hyb_gga_xc_sb98_2a</b>:  Schmider-Becke 98 parameterization 2a
</li>
<li><b>hyb_gga_xc_sb98_2b</b>:  Schmider-Becke 98 parameterization 2b
</li>
<li><b>hyb_gga_xc_sb98_2c</b>:  Schmider-Becke 98 parameterization 2c
</li>
<li><b>hyb_gga_x_sogga11_x</b>:  Hybrid based on SOGGA11 form
</li>
<li><b>hyb_gga_xc_hse03</b>:  the 2003 version of the screened hybrid HSE
</li>
<li><b>hyb_gga_xc_hse06</b>:  the 2006 version of the screened hybrid HSE
</li>
<li><b>hyb_gga_xc_hjs_pbe</b>:  HJS hybrid screened exchange PBE version
</li>
<li><b>hyb_gga_xc_hjs_pbe_sol</b>:  HJS hybrid screened exchange PBE_SOL version
</li>
<li><b>lda_xc_zlp</b>:  Zhao, Levy & Parr, Eq. (20)
</li>
<li><b>hyb_gga_xc_hjs_b88</b>:  HJS hybrid screened exchange B88 version
</li>
<li><b>hyb_gga_xc_hjs_b97x</b>:  HJS hybrid screened exchange B97x version
</li>
<li><b>hyb_gga_xc_cam_b3lyp</b>:  CAM version of B3LYP
</li>
<li><b>hyb_gga_xc_tuned_cam_b3lyp</b>:  CAM version of B3LYP tuned for excitations
</li>
<li><b>hyb_gga_xc_bhandh</b>:  Becke half-and-half
</li>
<li><b>hyb_gga_xc_bhandhlyp</b>:  Becke half-and-half with B88 exchange
</li>
<li><b>hyb_gga_xc_mb3lyp_rc04</b>:  B3LYP with RC04 LDA
</li>
<li><b>hyb_mgga_x_m05</b>:  M05 hybrid exchange functional from Minnesota
</li>
<li><b>hyb_mgga_x_m05_2x</b>:  M05-2X hybrid exchange functional from Minnesota
</li>
<li><b>hyb_mgga_xc_b88b95</b>:  Mixture of B88 with BC95 (B1B95)
</li>
<li><b>hyb_mgga_xc_b86b95</b>:  Mixture of B86 with BC95
</li>
<li><b>hyb_mgga_xc_pw86b95</b>:  Mixture of PW86 with BC95
</li>
<li><b>hyb_mgga_xc_bb1k</b>:  Mixture of B88 with BC95 from Zhao and Truhlar
</li>
<li><b>hyb_mgga_x_m06_hf</b>:  M06-HF hybrid exchange functional from Minnesota
</li>
<li><b>hyb_mgga_xc_mpw1b95</b>:  Mixture of mPW91 with BC95 from Zhao and Truhlar
</li>
<li><b>hyb_mgga_xc_mpwb1k</b>:  Mixture of mPW91 with BC95 for kinetics
</li>
<li><b>hyb_mgga_xc_x1b95</b>:  Mixture of X with BC95
</li>
<li><b>hyb_mgga_xc_xb1k</b>:  Mixture of X with BC95 for kinetics
</li>
<li><b>hyb_mgga_x_m06</b>:  M06 hybrid exchange functional from Minnesota
</li>
<li><b>gga_x_lambda_ch_n</b>:  lambda_CH(N) version of PBE
</li>
<li><b>hyb_mgga_x_m06_2x</b>:  M06-2X hybrid exchange functional from Minnesota
</li>
<li><b>hyb_mgga_xc_pw6b95</b>:  Mixture of PW91 with BC95 from Zhao and Truhlar
</li>
<li><b>hyb_mgga_xc_pwb6k</b>:  Mixture of PW91 with BC95 from Zhao and Truhlar for kinetics
</li>
<li><b>hyb_gga_xc_mpwlyp1m</b>:  MPW with 1 par. for metals/LYP
</li>
<li><b>hyb_gga_xc_revb3lyp</b>:  Revised B3LYP
</li>
<li><b>hyb_gga_xc_camy_blyp</b>:  BLYP with yukawa screening
</li>
<li><b>hyb_gga_xc_pbe0_13</b>:  PBE0-1/3
</li>
<li><b>hyb_mgga_xc_tpssh</b>:  TPSS hybrid
</li>
<li><b>hyb_mgga_xc_revtpssh</b>:  revTPSS hybrid
</li>
<li><b>hyb_gga_xc_b3lyps</b>:  B3LYP* functional
</li>
<li><b>gga_x_lambda_lo_n</b>:  lambda_LO(N) version of PBE
</li>
<li><b>hyb_gga_xc_wb97</b>:  Chai and Head-Gordon
</li>
<li><b>hyb_gga_xc_wb97x</b>:  Chai and Head-Gordon
</li>
<li><b>hyb_gga_xc_lrc_wpbeh</b>:  Long-range corrected functional by Rorhdanz et al
</li>
<li><b>hyb_gga_xc_wb97x_v</b>:  Mardirossian and Head-Gordon
</li>
<li><b>hyb_gga_xc_lcy_pbe</b>:  PBE with yukawa screening
</li>
<li><b>hyb_gga_xc_lcy_blyp</b>:  BLYP with yukawa screening
</li>
<li><b>hyb_gga_xc_lc_vv10</b>:  Vydrov and Van Voorhis
</li>
<li><b>gga_x_hjs_b88_v2</b>:  HJS screened exchange corrected B88 version
</li>
<li><b>hyb_gga_xc_camy_b3lyp</b>:  B3LYP with Yukawa screening
</li>
<li><b>gga_c_q2d</b>:  Chiodo et al
</li>
<li><b>hyb_gga_xc_wb97x_d</b>:  Chai and Head-Gordon
</li>
<li><b>hyb_gga_xc_hpbeint</b>:  hPBEint
</li>
<li><b>hyb_gga_xc_lrc_wpbe</b>:  Long-range corrected functional by Rorhdanz et al
</li>
<li><b>hyb_mgga_x_mvsh</b>:  MVSh hybrid
</li>
<li><b>hyb_gga_xc_b3lyp5</b>:  B3LYP with VWN functional 5 instead of RPA
</li>
<li><b>hyb_gga_xc_edf2</b>:  Empirical functional from Lin, George and Gill
</li>
<li><b>hyb_gga_xc_cap0</b>:  Correct Asymptotic Potential hybrid
</li>
<li><b>hyb_gga_xc_lc_wpbe</b>:  Long-range corrected functional by Vydrov and Scuseria
</li>
<li><b>hyb_gga_xc_hse12</b>:  HSE12 by Moussa, Schultz and Chelikowsky
</li>
<li><b>hyb_gga_xc_hse12s</b>:  Short-range HSE12 by Moussa, Schultz, and Chelikowsky
</li>
<li><b>hyb_gga_xc_hse_sol</b>:  HSEsol functional by Schimka, Harl, and Kresse
</li>
<li><b>hyb_gga_xc_cam_qtp_01</b>:  CAM-QTP(01): CAM-B3LYP retuned using ionization potentials of water
</li>
<li><b>hyb_gga_xc_mpw1lyp</b>:  Becke 1-parameter mixture of mPW91 and LYP
</li>
<li><b>hyb_gga_xc_mpw1pbe</b>:  Becke 1-parameter mixture of mPW91 and PBE
</li>
<li><b>hyb_gga_xc_kmlyp</b>:  Kang-Musgrave hybrid
</li>
<li><b>gga_x_q2d</b>:  Chiodo et al
</li>
<li><b>gga_x_pbe_mol</b>:  Del Campo, Gazquez, Trickey and Vela (PBE-like)
</li>
<li><b>lda_c_gl</b>:  Gunnarson & Lundqvist
</li>
<li><b>gga_x_wpbeh</b>:  short-range version of the PBE
</li>
<li><b>gga_x_hjs_pbe</b>:  HJS screened exchange PBE version
</li>
<li><b>gga_x_hjs_pbe_sol</b>:  HJS screened exchange PBE_SOL version
</li>
<li><b>gga_x_hjs_b88</b>:  HJS screened exchange B88 version
</li>
<li><b>gga_x_hjs_b97x</b>:  HJS screened exchange B97x version
</li>
<li><b>gga_x_ityh</b>:  short-range recipe for exchange GGA functionals
</li>
<li><b>gga_x_sfat</b>:  short-range recipe for exchange GGA functionals
</li>
<li><b>hyb_mgga_xc_wb97m_v</b>:  Mardirossian and Head-Gordon
</li>
<li><b>lda_x_rel</b>:  Relativistic exchange
</li>
<li><b>gga_x_sg4</b>:  Semiclassical GGA at fourth order
</li>
<li><b>gga_c_sg4</b>:  Semiclassical GGA at fourth order
</li>
<li><b>gga_x_gg99</b>:  Gilbert and Gill 1999
</li>
<li><b>lda_xc_1d_ehwlrg_1</b>:  LDA constructed from slab-like systems of 1 electron
</li>
<li><b>lda_xc_1d_ehwlrg_2</b>:  LDA constructed from slab-like systems of 2 electrons
</li>
<li><b>lda_xc_1d_ehwlrg_3</b>:  LDA constructed from slab-like systems of 3 electrons
</li>
<li><b>gga_x_pbepow</b>:  PBE power
</li>
<li><b>mgga_x_tm</b>:  Tao and Mo 2016
</li>
<li><b>mgga_x_vt84</b>:  meta-GGA version of VT{8,4} GGA
</li>
<li><b>mgga_x_sa_tpss</b>:  TPSS with correct surface asymptotics
</li>
<li><b>gga_x_kgg99</b>:  Gilbert and Gill 1999 (mixed)
</li>
<li><b>gga_xc_hle16</b>:  high local exchange 2016
</li>
<li><b>lda_x_erf</b>:  Attenuated exchange LDA (erf)
</li>
<li><b>lda_xc_lp_a</b>:  Lee-Parr reparametrization B
</li>
<li><b>lda_xc_lp_b</b>:  Lee-Parr reparametrization B
</li>
<li><b>lda_x_rae</b>:  Rae self-energy corrected exchange
</li>
<li><b>lda_c_mcweeny</b>:  McWeeny 76
</li>
<li><b>lda_c_br78</b>:  Brual & Rothstein 78
</li>
<li><b>gga_c_scan_e0</b>:  GGA component of SCAN
</li>
<li><b>lda_c_pk09</b>:  Proynov and Kong 2009
</li>
<li><b>gga_c_gapc</b>:  GapC
</li>
<li><b>gga_c_gaploc</b>:  Gaploc
</li>
<li><b>gga_c_zvpbeint</b>:  another spin-dependent correction to PBEint
</li>
<li><b>gga_c_zvpbesol</b>:  another spin-dependent correction to PBEsol
</li>
<li><b>gga_c_tm_lyp</b>:  Takkar and McCarthy reparametrization
</li>
<li><b>gga_c_tm_pbe</b>:  Thakkar and McCarthy reparametrization
</li>
<li><b>gga_c_w94</b>:  Wilson 94 (Eq. 25)
</li>
<li><b>mgga_c_kcis</b>:  Krieger, Chen, Iafrate, and Savin
</li>
<li><b>hyb_mgga_xc_b0kcis</b>:  Hybrid based on KCIS
</li>
<li><b>mgga_xc_lp90</b>:  Lee & Parr, Eq. (56)
</li>
<li><b>gga_c_cs1</b>:  A dynamical correlation functional
</li>
<li><b>hyb_mgga_xc_mpw1kcis</b>:  Modified Perdew-Wang + KCIS hybrid
</li>
<li><b>hyb_mgga_xc_mpwkcis1k</b>:  Modified Perdew-Wang + KCIS hybrid with more exact exchange
</li>
<li><b>hyb_mgga_xc_pbe1kcis</b>:  Perdew-Burke-Ernzerhof + KCIS hybrid
</li>
<li><b>hyb_mgga_xc_tpss1kcis</b>:  TPSS hybrid with KCIS correlation
</li>
<li><b>gga_x_ak13</b>:  Armiento & Kuemmel 2013
</li>
<li><b>gga_x_b88m</b>:  Becke 88 reoptimized to be used with mgga_c_tau1
</li>
<li><b>mgga_c_b88</b>:  Meta-GGA correlation by Becke
</li>
<li><b>hyb_gga_xc_b5050lyp</b>:  Like B3LYP but more exact exchange
</li>
<li><b>lda_c_ow_lyp</b>:  Wigner with corresponding LYP parameters
</li>
<li><b>lda_c_ow</b>:  Optimized Wigner
</li>
<li><b>mgga_x_gx</b>:  GX functional of Loos
</li>
<li><b>mgga_x_pbe_gx</b>:  PBE-GX functional of Loos
</li>
<li><b>lda_xc_gdsmfb</b>:  Groth et al. parametrization
</li>
<li><b>lda_c_gk72</b>:  Gordon and Kim 1972
</li>
<li><b>lda_c_karasiev</b>:  Karasiev reparameterization of Chachiyo
</li>
<li><b>mgga_x_revscan</b>:  revised SCAN
</li>
<li><b>mgga_c_revscan</b>:  revised SCAN correlation
</li>
<li><b>hyb_mgga_x_revscan0</b>:  revised SCAN hybrid exchange
</li>
<li><b>mgga_c_scan_vv10</b>:  SCAN correlation +  VV10 correlation
</li>
<li><b>mgga_c_revscan_vv10</b>:  revised SCAN correlation
</li>
<li><b>mgga_x_br89_explicit</b>:  Becke-Roussel 89 with an explicit inversion of x(y)
</li>
<li><b>gga_x_lv_rpw86</b>:  Berland and Hyldgaard
</li>
<li><b>hyb_mgga_xc_b98</b>:  Becke 98
</li>
<li><b>gga_x_pbe_tca</b>:  PBE revised by Tognetti et al
</li>
<li><b>lda_c_xalpha</b>:  Slater Xalpha
</li>
<li><b>rdmft_xc_m</b>:  RDMFT Mueller functional (not from libxc).
</li>
<li><b>gga_x_pbeint</b>:  PBE for hybrid interfaces
</li>
<li><b>gga_c_zpbeint</b>:  spin-dependent gradient correction to PBEint
</li>
<li><b>gga_c_pbeint</b>:  PBE for hybrid interfaces
</li>
<li><b>gga_c_zpbesol</b>:  spin-dependent gradient correction to PBEsol
</li>
<li><b>mgga_xc_otpss_d</b>:  oTPSS_D functional of Goerigk and Grimme
</li>
<li><b>gga_xc_opbe_d</b>:  oPBE_D functional of Goerigk and Grimme
</li>
<li><b>gga_xc_opwlyp_d</b>:  oPWLYP-D functional of Goerigk and Grimme
</li>
<li><b>gga_xc_oblyp_d</b>:  oBLYP-D functional of Goerigk and Grimme
</li>
<li><b>gga_x_vmt84_ge</b>:  VMT{8,4} with constraint satisfaction with mu = mu_GE
</li>
<li><b>gga_x_vmt84_pbe</b>:  VMT{8,4} with constraint satisfaction with mu = mu_PBE
</li>
<li><b>lda_c_vwn</b>:  Vosko, Wilk, & Nusair (5)
</li>
<li><b>lda_xc_cmplx</b>:  Complex-scaled LDA exchange and correlation (not from libxc).
</li>
<li><b>pbe_xc_cmplx</b>:  Complex-scaled PBE exchange and correlation (not from libxc).
</li>
<li><b>lb94_xc_cmplx</b>:  Complex-scaled LB94 exchange and correlation (not from libxc).
</li>
<li><b>gga_x_vmt_ge</b>:  Vela, Medel, and Trickey with mu = mu_GE
</li>
<li><b>gga_x_vmt_pbe</b>:  Vela, Medel, and Trickey with mu = mu_PBE
</li>
<li><b>mgga_c_cs</b>:  Colle and Salvetti
</li>
<li><b>mgga_c_mn12_sx</b>:  MN12-SX correlation functional from Minnesota
</li>
<li><b>mgga_c_mn12_l</b>:  MN12-L correlation functional from Minnesota
</li>
<li><b>mgga_c_m11_l</b>:  M11-L correlation functional from Minnesota
</li>
<li><b>mgga_c_m11</b>:  M11 correlation functional from Minnesota
</li>
<li><b>mgga_c_m08_so</b>:  M08-SO correlation functional from Minnesota
</li>
<li><b>mgga_c_m08_hx</b>:  M08-HX correlation functional from Minnesota
</li>
<li><b>gga_c_n12_sx</b>:  N12-SX functional from Minnesota
</li>
<li><b>gga_c_n12</b>:  N12 functional from Minnesota
</li>
<li><b>lda_c_vwn_rpa</b>:  Vosko, Wilk, & Nusair (RPA)
</li>
<li><b>ks_inversion</b>:  Inversion of KS potential (not from libxc).
</li>
<li><b>hyb_gga_x_n12_sx</b>:  N12-SX functional from Minnesota
</li>
<li><b>gga_x_n12</b>:  N12 functional from Minnesota
</li>
<li><b>gga_c_regtpss</b>:  Regularized TPSS correlation (ex-VPBE)
</li>
<li><b>gga_c_op_xalpha</b>:  one-parameter progressive functional (XALPHA version)
</li>
<li><b>gga_c_op_g96</b>:  one-parameter progressive functional (G96 version)
</li>
<li><b>gga_c_op_pbe</b>:  one-parameter progressive functional (PBE version)
</li>
<li><b>gga_c_op_b88</b>:  one-parameter progressive functional (B88 version)
</li>
<li><b>gga_c_ft97</b>:  Filatov & Thiel correlation
</li>
<li><b>gga_c_spbe</b>:  PBE correlation to be used with the SSB exchange
</li>
<li><b>lda_c_pz</b>:  Perdew & Zunger
</li>
<li><b>oep_x</b>:  OEP: Exact exchange (not from libxc).
</li>
<li><b>slater_x</b>:  Slater approximation to the exact exchange (not from libxc).
</li>
<li><b>fbe_x</b>:  Exchange functional based on the force balance equation (not from libxc).
</li>
<li><b>gga_x_ssb_sw</b>:  Swart, Sola and Bickelhaupt correction to PBE
</li>
<li><b>xc_half_hartree</b>:  Half-Hartree exchange for two electrons (supports complex scaling) (not from libxc).
 Defined by \(v_{xc}(r) = v_H(r) / 2\).
</li>
<li><b>vdw_c_vdwdf</b>:  van der Waals density functional vdW-DF correlation from libvdwxc (not from libxc).  Use with gga_x_pbe_r.
</li>
<li><b>vdw_c_vdwdf2</b>:  van der Waals density functional vdW-DF2 correlation from libvdwxc (not from libxc).  Use with gga_x_rpw86.
</li>
<li><b>gga_x_ssb</b>:  Swart, Sola and Bickelhaupt
</li>
<li><b>vdw_c_vdwdfcx</b>:  van der Waals density functional vdW-DF-cx correlation from libvdwxc (not from libxc).  Use with gga_x_lv_rpw86.
</li>
<li><b>hyb_gga_xc_mvorb_hse06</b>:  Density-based mixing parameter of HSE06 (not from libxc).
</li>
<li><b>hyb_gga_xc_mvorb_pbeh</b>:  Density-based mixing parameter of PBEH (not from libxc).
 At the moment this is not supported for libxc >= 4.0.
</li>
<li><b>gga_x_ssb_d</b>:  Swart, Sola and Bickelhaupt dispersion
</li>
<li><b>gga_xc_hcth_407p</b>:  HCTH/407+
</li>
<li><b>gga_xc_hcth_p76</b>:  HCTH p=7/6
</li>
<li><b>gga_xc_hcth_p14</b>:  HCTH p=1/4
</li>
<li><b>gga_xc_b97_gga1</b>:  Becke 97 GGA-1
</li>
<li><b>gga_c_hcth_a</b>:  HCTH-A
</li>
<li><b>gga_x_bpccac</b>:  BPCCAC (GRAC for the energy)
</li>
<li><b>gga_c_revtca</b>:  Tognetti, Cortona, Adamo (revised)
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='XCKernel'></a>XCKernel</b>
<br/><i>Section</i>: Hamiltonian::XC
<br/><i>Type</i>: integer
<br/><br> Defines the exchange-correlation kernel. Only LDA kernels are available currently.
 The options are the same as <tt>XCFunctional</tt>.
 Note: the kernel is only needed for Casida, Sternheimer, or optimal-control calculations.
 Defaults:
 <br>1D: <tt>lda_x_1d + lda_c_1d_csc</tt>
 <br>2D: <tt>lda_x_2d + lda_c_2d_amgb</tt>
 <br>3D: <tt>lda_x + lda_c_pz_mod</tt>

<br/><i>Options</i>:
<ul>
<li><b>xc_functional</b>:  The same functional defined by <tt>XCFunctional</tt>.
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='XCKernelLRCAlpha'></a>XCKernelLRCAlpha</b>
<br/><i>Section</i>: Hamiltonian::XC
<br/><i>Type</i>: float
<br/><i>Default</i>: 0.0
<br/><br> Set to a non-zero value to add a long-range correction for solids to the kernel.
 This is the \(\alpha\) parameter defined in S. Botti <i>et al.</i>, <i>Phys. Rev. B</i>
 69, 155112 (2004). The \(\Gamma = \Gamma` = 0\) term \(-\alpha/q^2\) is taken
 into account by introducing an additional pole to the polarizability (see R. Stubner
 <i>et al.</i>, <i>Phys. Rev. B</i> 70, 245119 (2004)). The rest of the terms are included by
 multiplying the Hartree term by \(1 - \alpha / 4 \pi\). The use of non-zero
 \(\alpha\) in combination with <tt>HamiltonianVariation</tt> = <tt>V_ext_only</tt>
 corresponds to account of only the \(\Gamma = \Gamma` = 0\) term.
 Applicable only to isotropic systems. (Experimental)

</p><hr width='30%' align='left'/>


<p><b><a name='XCUseGaugeIndependentKED'></a>XCUseGaugeIndependentKED</b>
<br/><i>Section</i>: Hamiltonian::XC
<br/><i>Type</i>: logical
<br/><i>Default</i>: yes
<br/><br> If true, when evaluating the XC functional, a term including the (paramagnetic or total) current
 is added to the kinetic-energy density such as to make it gauge-independent.
 Applies only to meta-GGA (and hybrid meta-GGA) functionals.

</p><hr width='30%' align='left'/>


<p><b><a name='Xalpha'></a>Xalpha</b>
<br/><i>Section</i>: Hamiltonian::XC
<br/><i>Type</i>: float
<br/><i>Default</i>: 1.0
<br/><br> The parameter of the Slater X\(\alpha\) functional. Applies only for
 <tt>XCFunctional = xc_lda_c_xalpha</tt>.

</p><hr width='30%' align='left'/>


<p><b><a name='libvdwxcDebug'></a>libvdwxcDebug</b>
<br/><i>Section</i>: Hamiltonian::XC
<br/><i>Type</i>: logical
<br/><br> Dump libvdwxc inputs and outputs to files.

</p><hr width='30%' align='left'/>


<p><b><a name='libvdwxcMode'></a>libvdwxcMode</b>
<br/><i>Section</i>: Hamiltonian::XC
<br/><i>Type</i>: integer
<br/><br> Whether libvdwxc should run with serial fftw3, fftw3-mpi, or pfft.
 to specify fftw3-mpi in serial for debugging.
 pfft is not implemented at the moment.

<br/><i>Options</i>:
<ul>
<li><b>libvdwxc_mode_auto</b>:  Use serial fftw3 if actually running in serial, else fftw3-mpi.
</li>
<li><b>libvdwxc_mode_serial</b>:  Run with serial fftw3.  Works only when not parallelizing over domains.
</li>
<li><b>libvdwxc_mode_mpi</b>:  Run with fftw3-mpi.  Works only if Octopus is compiled with MPI.
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='libvdwxcVDWFactor'></a>libvdwxcVDWFactor</b>
<br/><i>Section</i>: Hamiltonian::XC
<br/><i>Type</i>: float
<br/><br> Prefactor of non-local van der Waals functional.
 Setting a prefactor other than one is wrong, but useful
 for debugging.

</p><hr width='30%' align='left'/>

<a name='Hamiltonian::XC::DensityCorrection'</a>
<H2>Hamiltonian::XC::DensityCorrection</H2>


<p><b><a name='XCDensityCorrection'></a>XCDensityCorrection</b>
<br/><i>Section</i>: Hamiltonian::XC::DensityCorrection
<br/><i>Type</i>: integer
<br/><i>Default</i>: none
<br/><br> This variable controls the long-range correction of the XC
 potential using the <a href=http://arxiv.org/abs/1107.4339>XC density representation</a>.

<br/><i>Options</i>:
<ul>
<li><b>none</b>:  No correction is applied.
</li>
<li><b>long_range_x</b>:  The correction is applied to the exchange potential.
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='XCDensityCorrectionCutoff'></a>XCDensityCorrectionCutoff</b>
<br/><i>Section</i>: Hamiltonian::XC::DensityCorrection
<br/><i>Type</i>: float
<br/><i>Default</i>: 0.0
<br/><br> The value of the cutoff applied to the XC density.

</p><hr width='30%' align='left'/>


<p><b><a name='XCDensityCorrectionMinimum'></a>XCDensityCorrectionMinimum</b>
<br/><i>Section</i>: Hamiltonian::XC::DensityCorrection
<br/><i>Type</i>: logical
<br/><i>Default</i>: true
<br/><br> When enabled, the cutoff optimization will
 return the first minimum of the \(q_{xc}\) function if it does
 not find a value of -1 (<a href=http://arxiv.org/abs/1107.4339>details</a>).
 This is required for atoms or small
 molecules, but may cause numerical problems.

</p><hr width='30%' align='left'/>


<p><b><a name='XCDensityCorrectionNormalize'></a>XCDensityCorrectionNormalize</b>
<br/><i>Section</i>: Hamiltonian::XC::DensityCorrection
<br/><i>Type</i>: logical
<br/><i>Default</i>: true
<br/><br> When enabled, the correction will be
 normalized to reproduce the exact boundary conditions of
 the XC potential.

</p><hr width='30%' align='left'/>


<p><b><a name='XCDensityCorrectionOptimize'></a>XCDensityCorrectionOptimize</b>
<br/><i>Section</i>: Hamiltonian::XC::DensityCorrection
<br/><i>Type</i>: logical
<br/><i>Default</i>: true
<br/><br> When enabled, the density cutoff will be
 optimized to replicate the boundary conditions of the exact
 XC potential. If the variable is set to no, the value of
 the cutoff must be given by the <tt>XCDensityCorrectionCutoff</tt>
 variable.

</p><hr width='30%' align='left'/>

</body>
</html>