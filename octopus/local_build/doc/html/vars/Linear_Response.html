
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
<style>
   BODY {background-color: white; 
         font-size: 10pt; font-family: verdana,helvetica;}
   A  {text-decoration: none;color: blue}
</style>
</head>
<body>

<a name='Linear Response'</a>
<H2>Linear Response</H2>


<p><b><a name='MagneticGaugeCorrection'></a>MagneticGaugeCorrection</b>
<br/><i>Section</i>: Linear Response
<br/><i>Type</i>: integer
<br/><i>Default</i>: gipaw
<br/><br> For magnetic linear response: how to handle gauge-invariance in the description
 of the coupling of electrons to the magnetic field.

<br/><i>Options</i>:
<ul>
<li><b>none</b>:  No correction.
 No correction.
</li>
<li><b>gipaw</b>:  GIPAW correction: C Pickard and F Mauri, <i>Phys. Rev. Lett.</i> <b>91</b>, 196401 (2003).
 GIPAW correction: C Pickard and F Mauri, <i>Phys. Rev. Lett.</i> <b>91</b>, 196401 (2003).
</li>
<li><b>icl</b>:  ICL correction: S Ismail-Beigi, EK Chang, and SG Louie, <i>Phys. Rev. Lett.</i> <b>87</b>, 087402 (2001).
 ICL correction: S Ismail-Beigi, EK Chang, and SG Louie, <i>Phys. Rev. Lett.</i> <b>87</b>, 087402 (2001).
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='ResponseMethod'></a>ResponseMethod</b>
<br/><i>Section</i>: Linear Response
<br/><i>Type</i>: integer
<br/><i>Default</i>: sternheimer
<br/><br> Some response properties can be calculated either via
 Sternheimer linear response or by using finite
 differences. You can use this variable to select how you want
 them to be calculated, it applies to <tt>em_resp</tt> and <tt>vib_modes</tt>
 calculation modes. By default, the Sternheimer linear-response
 technique is used.

<br/><i>Options</i>:
<ul>
<li><b>sternheimer</b>:  The linear response is obtained by solving a self-consistent
 Sternheimer equation for the variation of the orbitals. This
 is the recommended method.
</li>
<li><b>finite_differences</b>:  Properties are calculated as a finite-differences derivative of
 the energy obtained by several ground-state calculations. This
 method, slow and limited only to static response, is kept
 mainly because it is simple and useful for testing purposes.
</li>
</ul>
</p><hr width='30%' align='left'/>

<a name='Linear Response::Casida'</a>
<H2>Linear Response::Casida</H2>


<p><b><a name='CasidaCalcForces'></a>CasidaCalcForces</b>
<br/><i>Section</i>: Linear Response::Casida
<br/><i>Type</i>: logical
<br/><i>Default</i>: false
<br/><br> (Experimental) Enable calculation of excited-state forces. Requires previous <tt>vib_modes</tt> calculation.

</p><hr width='30%' align='left'/>


<p><b><a name='CasidaCalcForcesKernel'></a>CasidaCalcForcesKernel</b>
<br/><i>Section</i>: Linear Response::Casida
<br/><i>Type</i>: logical
<br/><i>Default</i>: true
<br/><br> If false, the derivative of the kernel will not be included in the excited-state force calculation.

</p><hr width='30%' align='left'/>


<p><b><a name='CasidaCalcForcesSCF'></a>CasidaCalcForcesSCF</b>
<br/><i>Section</i>: Linear Response::Casida
<br/><i>Type</i>: logical
<br/><i>Default</i>: false
<br/><br> If true, the ground-state forces will be included in the excited-state forces, so they are total forces.
 If false, the excited-state forces that are produced are only the gradients of the excitation energy.

</p><hr width='30%' align='left'/>


<p><b><a name='CasidaCalcTriplet'></a>CasidaCalcTriplet</b>
<br/><i>Section</i>: Linear Response::Casida
<br/><i>Type</i>: logical
<br/><i>Default</i>: false
<br/><br> For a non-spin-polarized ground state, singlet or triplet excitations can be calculated
 using different matrix elements. Default is to calculate singlets. This variable has no
 effect for a spin-polarized calculation.

</p><hr width='30%' align='left'/>


<p><b><a name='CasidaDistributedMatrix'></a>CasidaDistributedMatrix</b>
<br/><i>Section</i>: Linear Response::Casida
<br/><i>Type</i>: logical
<br/><i>Default</i>: false
<br/><br> Large matrices with more than a few thousand rows and columns usually do
 not fit into the memory of one processor anymore. With this option, the
 Casida matrix is distributed in block-cyclic fashion over all cores in the
 ParOther group. The diagonalization is done in parallel using ScaLAPACK
 or ELPA, if available. For very large matrices (>100000), only the
 ParOther strategy should be used because the diagonalization dominates
 the run time of the computation.

</p><hr width='30%' align='left'/>


<p><b><a name='CasidaHermitianConjugate'></a>CasidaHermitianConjugate</b>
<br/><i>Section</i>: Linear Response::Casida
<br/><i>Type</i>: logical
<br/><i>Default</i>: false
<br/><br> The Casida matrix is Hermitian, so it should not matter whether we calculate the upper or
 lower diagonal. Numerical issues may cause small differences however. Use this variable to
 calculate the Hermitian conjugate of the usual matrix, for testing.

</p><hr width='30%' align='left'/>


<p><b><a name='CasidaKSEnergyWindow'></a>CasidaKSEnergyWindow</b>
<br/><i>Section</i>: Linear Response::Casida
<br/><i>Type</i>: float
<br/><br> An alternative to <tt>CasidaKohnShamStates</tt> for specifying which occupied-unoccupied
 transitions will be used: all those whose eigenvalue differences are less than this
 number will be included. If a value less than 0 is supplied, this criterion will not be used.

</p><hr width='30%' align='left'/>


<p><b><a name='CasidaKohnShamStates'></a>CasidaKohnShamStates</b>
<br/><i>Section</i>: Linear Response::Casida
<br/><i>Type</i>: string
<br/><i>Default</i>: all states
<br/><br> The calculation of the excitation spectrum of a system in the Casida frequency-domain
 formulation of linear-response time-dependent density functional theory (TDDFT)
 implies the use of a basis set of occupied/unoccupied Kohn-Sham orbitals. This
 basis set should, in principle, include all pairs formed by all occupied states,
 and an infinite number of unoccupied states. In practice, one has to truncate this
 basis set, selecting a number of occupied and unoccupied states that will form the
 pairs. These states are specified with this variable. If there are, say, 15 occupied
 states, and one sets this variable to the value "10-18", this means that occupied
 states from 10 to 15, and unoccupied states from 16 to 18 will be considered.
<br><br>
 This variable is a string in list form, <i>i.e.</i> expressions such as "1,2-5,8-15" are
 valid. You should include a non-zero number of unoccupied states and a non-zero number
 of occupied states.

</p><hr width='30%' align='left'/>


<p><b><a name='CasidaMomentumTransfer'></a>CasidaMomentumTransfer</b>
<br/><i>Section</i>: Linear Response::Casida
<br/><i>Type</i>: block
<br/><i>Default</i>: 0
<br/><br> Momentum-transfer vector for the calculation of the dynamic structure
 factor. When this variable is set, the transition rates are determined
 using an exponential operator instead of the normal dipole one.

</p><hr width='30%' align='left'/>


<p><b><a name='CasidaParallelEigensolver'></a>CasidaParallelEigensolver</b>
<br/><i>Section</i>: Linear Response::Casida
<br/><i>Type</i>: integer
<br/><br> Choose library to use for solving the parallel eigenproblem
 of the Casida problem. This options is only relevant if a
 distributed matrix is used (CasidaDistributedMatrix=true).
 By default, elpa is chosen if available.

<br/><i>Options</i>:
<ul>
<li><b>casida_elpa</b>:  Use ELPA library as parallel eigensolver
</li>
<li><b>casida_scalapack</b>:  Use Scalapack as parallel eigensolver
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='CasidaPrintExcitations'></a>CasidaPrintExcitations</b>
<br/><i>Section</i>: Linear Response::Casida
<br/><i>Type</i>: string
<br/><i>Default</i>: write all
<br/><br> Specifies which excitations are written at the end of the calculation.
<br><br>
 This variable is a string in list form, <i>i.e.</i> expressions such as "1,2-5,8-15" are
 valid.

</p><hr width='30%' align='left'/>


<p><b><a name='CasidaQuadratureOrder'></a>CasidaQuadratureOrder</b>
<br/><i>Section</i>: Linear Response::Casida
<br/><i>Type</i>: integer
<br/><i>Default</i>: 5
<br/><br> Only applies if <tt>CasidaMomentumTransfer</tt> is nonzero.
 Directionally averaged dynamic structure factor is calculated by
 averaging over the results from a set of \(\vec{q}\)-vectors. The vectors
 are generated using Gauss-Legendre quadrature scheme [see <i>e.g.</i>
 K. Atkinson, <i>J. Austral. Math. Soc.</i> <b>23</b>, 332 (1982)], and this
 variable determines the order of the scheme.

</p><hr width='30%' align='left'/>


<p><b><a name='CasidaTheoryLevel'></a>CasidaTheoryLevel</b>
<br/><i>Section</i>: Linear Response::Casida
<br/><i>Type</i>: flag
<br/><i>Default</i>: <tt>eps_diff + petersilka + lrtddft_casida</tt>
<br/><br> Choose which electron-hole matrix-based theory levels to use in calculating excitation energies.
 More than one may be used to take advantage of the significant commonality between the calculations.
 <tt>variational</tt> and <tt>lrttdft_casida</tt> are not usable with complex wavefunctions.
 Note the restart data saved by each theory level is compatible with all the others.

<br/><i>Options</i>:
<ul>
<li><b>lrtddft_casida</b>:  The full Casida method. Only applies to real wavefunctions.
 Ref: C Jamorski, ME Casida, and DR Salahub, <i>J. Chem. Phys.</i> <b>104</b>, 5134 (1996)
 and ME Casida, "Time-dependent density functional response theory for molecules,"
 in <i>Recent Advances in Density Functional Methods</i>, edited by DE Chong, vol. 1
 of <i>Recent Advances in Computational Chemistry</i>, pp. 155-192 (World Scientific,
 Singapore, 1995).
</li>
<li><b>eps_diff</b>:  Difference of eigenvalues, <i>i.e.</i> independent-particle approximation.
</li>
<li><b>petersilka</b>:  The Petersilka approximation uses only elements of the Tamm-Dancoff matrix between degenerate
 transitions (if no degeneracy, this is just the diagonal elements). Also called the "single-pole" approximation.
 This is acceptable if there is little mixing between single-particle transitions.
 Ref: M Petersilka, UJ Gossmann, and EKU Gross, <i>Phys. Rev. Lett.</i> <b>76</b>, 1212 (1996);
 T Grabo, M Petersilka,and EKU Gross, <i>Theochem</i> <b>501-502</b> 353 (2000).
</li>
<li><b>tamm_dancoff</b>:  The Tamm-Dancoff approximation uses only occupied-unoccupied transitions and not
 unoccupied-occupied transitions.
 Ref: S Hirata and M Head-Gordon, <i>Chem. Phys. Lett.</i> <b>314</b>, 291 (1999).
</li>
<li><b>variational</b>:  Second-order constrained variational theory CV(2)-DFT. Only applies to real wavefunctions.
 Ref: T Ziegler, M Seth, M Krykunov, J Autschbach, and F Wang,
 <i>J. Chem. Phys.</i> <b>130</b>, 154102 (2009).
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='CasidaTransitionDensities'></a>CasidaTransitionDensities</b>
<br/><i>Section</i>: Linear Response::Casida
<br/><i>Type</i>: string
<br/><i>Default</i>: write none
<br/><br> Specifies which transition densities are to be calculated and written down. The
 transition density for the many-body state <i>n</i> will be written to a file called
 <tt>rho_0n</tt> prefixed by the theory level. Format is set by <tt>OutputFormat</tt>.
<br><br>
 This variable is a string in list form, <i>i.e.</i> expressions such as "1,2-5,8-15" are
 valid.

</p><hr width='30%' align='left'/>


<p><b><a name='CasidaWeightThreshold'></a>CasidaWeightThreshold</b>
<br/><i>Section</i>: Linear Response::Casida
<br/><i>Type</i>: float
<br/><i>Default</i>: -1.
<br/><br> Specifies the threshold value for which the individual excitations are printed.
 i.e. juste-h pairs with weight larger than this threshold will be printed.
<br><br>
 If a negative value (default) is set, all coefficients will be printed.
 For many case, a 0.01 value is a valid option.

</p><hr width='30%' align='left'/>


<p><b><a name='CasidaWriteDistributedMatrix'></a>CasidaWriteDistributedMatrix</b>
<br/><i>Section</i>: Linear Response::Casida
<br/><i>Type</i>: logical
<br/><i>Default</i>: false
<br/><br> Set to true to write out the full distributed Casida matrix to a file
 using MPI-IO.

</p><hr width='30%' align='left'/>


<p><b><a name='PhotonmodesFilename'></a>PhotonmodesFilename</b>
<br/><i>Section</i>: Linear Response::Casida
<br/><i>Type</i>: string
<br/><i>Default</i>: "photonmodes"
<br/><br> Filename for photon modes in text format
  - first line contains 2 integers: number of photon modes and number of
    columns
  - each further line contains the given number of floats for one photon
    mode

</p><hr width='30%' align='left'/>

<a name='Linear Response::KdotP'</a>
<H2>Linear Response::KdotP</H2>


<p><b><a name='KdotPCalcSecondOrder'></a>KdotPCalcSecondOrder</b>
<br/><i>Section</i>: Linear Response::KdotP
<br/><i>Type</i>: logical
<br/><i>Default</i>: false
<br/><br> If true, calculates second-order response of wavefunctions as well as first-order response.
 Note that the second derivative of the Hamiltonian is NOT included in this calculation.
 This is needed for a subsequent run in <tt>CalculationMode = em_resp</tt> with <tt>EMHyperpol</tt>.

</p><hr width='30%' align='left'/>


<p><b><a name='KdotPCalculateEffectiveMasses'></a>KdotPCalculateEffectiveMasses</b>
<br/><i>Section</i>: Linear Response::KdotP
<br/><i>Type</i>: logical
<br/><i>Default</i>: true
<br/><br> If true, uses <tt>kdotp</tt> perturbations of ground-state wavefunctions
 to calculate effective masses. It is not correct for degenerate states.

</p><hr width='30%' align='left'/>


<p><b><a name='KdotPEta'></a>KdotPEta</b>
<br/><i>Section</i>: Linear Response::KdotP
<br/><i>Type</i>: float
<br/><i>Default</i>: 0.0
<br/><br> Imaginary frequency added to Sternheimer equation which may improve convergence.
 Not recommended.

</p><hr width='30%' align='left'/>


<p><b><a name='KdotPOccupiedSolutionMethod'></a>KdotPOccupiedSolutionMethod</b>
<br/><i>Section</i>: Linear Response::KdotP
<br/><i>Type</i>: integer
<br/><i>Default</i>: sternheimer_eqn
<br/><br> Method of calculating the contribution of the projection of the
 linear-response wavefunctions in the occupied subspace.

<br/><i>Options</i>:
<ul>
<li><b>sternheimer_eqn</b>:  The Sternheimer equation is solved including the occupied subspace,
 to get the full linear-response wavefunctions.
</li>
<li><b>sum_over_states</b>:  The Sternheimer equation is solved only in the unoccupied subspace,
 and a sum-over-states perturbation-theory expression is used to
 evaluate the contributions in the occupied subspace.
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='KdotPUseNonLocalPseudopotential'></a>KdotPUseNonLocalPseudopotential</b>
<br/><i>Section</i>: Linear Response::KdotP
<br/><i>Type</i>: logical
<br/><i>Default</i>: true
<br/><br> For testing purposes, set to false to ignore the term \(-i \left[\vec{r}, V\right]\) in
 the \(\vec{k} \cdot \vec{p}\) perturbation, which is due to non-local pseudopotentials.

</p><hr width='30%' align='left'/>


<p><b><a name='KdotPVelMethod'></a>KdotPVelMethod</b>
<br/><i>Section</i>: Linear Response::KdotP
<br/><i>Type</i>: integer
<br/><i>Default</i>: grad_vel
<br/><br> Method of velocity calculation.

<br/><i>Options</i>:
<ul>
<li><b>grad_vel</b>:  \(-i \left(\nabla + \left[r, V_{\rm nl} \right] \right)\)
 \(-i \left(\nabla + \left[r, V_{\rm nl} \right] \right)\)
</li>
<li><b>hcom_vel</b>:  As a commutator of the position operator and Hamiltonian, \(-i \left[ r, H \right]\).
 As a commutator of the position operator and Hamiltonian, \(-i \left[ r, H \right]\).
</li>
</ul>
</p><hr width='30%' align='left'/>

<a name='Linear Response::Polarizabilities'</a>
<H2>Linear Response::Polarizabilities</H2>


<p><b><a name='BornChargeSumRuleCorrection'></a>BornChargeSumRuleCorrection</b>
<br/><i>Section</i>: Linear Response::Polarizabilities
<br/><i>Type</i>: logical
<br/><i>Default</i>: true
<br/><br> Enforce the acoustic sum rule by distributing the excess sum of Born charges equally among the atoms.
 Sum rule: \(\sum_{\alpha} Z^{*}_{\alpha, i, j} = Z_{\rm tot} \delta_{ij}\).
 Violation of the sum rule may be caused by inadequate spacing, box size (in finite directions),
 or <i>k</i>-point sampling (in periodic directions).

</p><hr width='30%' align='left'/>


<p><b><a name='EMCalcBornCharges'></a>EMCalcBornCharges</b>
<br/><i>Section</i>: Linear Response::Polarizabilities
<br/><i>Type</i>: logical
<br/><i>Default</i>: false
<br/><br> Calculate linear-response Born effective charges from electric perturbation (experimental).

</p><hr width='30%' align='left'/>


<p><b><a name='EMCalcMagnetooptics'></a>EMCalcMagnetooptics</b>
<br/><i>Section</i>: Linear Response::Polarizabilities
<br/><i>Type</i>: logical
<br/><i>Default</i>: false
<br/><br> Calculate magneto-optical response.

</p><hr width='30%' align='left'/>


<p><b><a name='EMCalcRotatoryResponse'></a>EMCalcRotatoryResponse</b>
<br/><i>Section</i>: Linear Response::Polarizabilities
<br/><i>Type</i>: logical
<br/><i>Default</i>: false
<br/><br> Calculate circular-dichroism spectrum from electric perturbation,
 and write to file <tt>rotatory_strength</tt>.

</p><hr width='30%' align='left'/>


<p><b><a name='EMEta'></a>EMEta</b>
<br/><i>Section</i>: Linear Response::Polarizabilities
<br/><i>Type</i>: float
<br/><i>Default</i>: 0.0
<br/><br> The imaginary part of the frequency, effectively a Lorentzian broadening
 for peaks in the spectrum. It can help convergence of the SCF cycle for the
 Sternheimer equation when on a resonance, and it can be used as a positive
 infinitesimal to get the imaginary parts of response functions at poles.
 In units of energy. Cannot be negative.

</p><hr width='30%' align='left'/>


<p><b><a name='EMForceNoKdotP'></a>EMForceNoKdotP</b>
<br/><i>Section</i>: Linear Response::Polarizabilities
<br/><i>Type</i>: logical
<br/><i>Default</i>: false
<br/><br> If the system is periodic, by default wavefunctions from a previous <tt>kdotp</tt> run will
 be read, to be used in the formulas for the polarizability and
 hyperpolarizability in the quantum theory of polarization. For testing purposes,
 you can set this variable to true to disregard the <tt>kdotp</tt> run, and use the formulas
 for the finite system. This variable has no effect for a finite system.

</p><hr width='30%' align='left'/>


<p><b><a name='EMFreqs'></a>EMFreqs</b>
<br/><i>Section</i>: Linear Response::Polarizabilities
<br/><i>Type</i>: block
<br/><br> This block defines for which frequencies the polarizabilities
 will be calculated. If it is not present, the static (\(\omega = 0\)) response
 is calculated.
<br><br>
 Each row of the block indicates a sequence of frequency values, the
 first column is an integer that indicates the number of steps, the
 second number is the initial frequency, and the third number the final
 frequency. If the first number is one, then only the initial value is
 considered. The block can have any number of rows. Consider the next example:
<br><br>
 <tt>%EMFreqs
 <br>31 | 0.0 | 1.0
 <br> 1 | 0.32
 <br>%</tt>
<br><br>

</p><hr width='30%' align='left'/>


<p><b><a name='EMFreqsSort'></a>EMFreqsSort</b>
<br/><i>Section</i>: Linear Response::Polarizabilities
<br/><i>Type</i>: logical
<br/><i>Default</i>: true
<br/><br> If true, the frequencies specified by the <tt>EMFreqs</tt> block are sorted, so that
 they are calculated in increasing order. Can be set to false to use the order as stated,
 in case this makes better use of available restart information.

</p><hr width='30%' align='left'/>


<p><b><a name='EMHyperpol'></a>EMHyperpol</b>
<br/><i>Section</i>: Linear Response::Polarizabilities
<br/><i>Type</i>: block
<br/><br> This block describes the multiples of the frequency used for
 the dynamic hyperpolarizability. The results are written to the
 file <tt>beta</tt> in the directory for the first multiple.
 There must be three factors, summing to zero: \(\omega_1 + \omega_2 + \omega_3 = 0\).
 For example, for second-harmonic generation, you could use
 <tt>1 | 1 | -2</tt>.

</p><hr width='30%' align='left'/>


<p><b><a name='EMKPointOutput'></a>EMKPointOutput</b>
<br/><i>Section</i>: Linear Response::Polarizabilities
<br/><i>Type</i>: logical
<br/><i>Default</i>: false
<br/><br> Give in the output contributions of different k-points to the dielectric constant.
 Can be also used for magneto-optical effects.

</p><hr width='30%' align='left'/>


<p><b><a name='EMMagnetoopticsNoHVar'></a>EMMagnetoopticsNoHVar</b>
<br/><i>Section</i>: Linear Response::Polarizabilities
<br/><i>Type</i>: logical
<br/><i>Default</i>: true
<br/><br> Exclude corrections to the exchange-correlation and Hartree terms
 from consideration of perturbations induced by a magnetic field

</p><hr width='30%' align='left'/>


<p><b><a name='EMOccupiedResponse'></a>EMOccupiedResponse</b>
<br/><i>Section</i>: Linear Response::Polarizabilities
<br/><i>Type</i>: logical
<br/><i>Default</i>: false
<br/><br> Solve for full response without projector into unoccupied subspace.
 Not possible if there are partial occupations.
 When <tt>EMHyperpol</tt> is set for a periodic system, this variable is ignored and
 the full response is always calculated.

</p><hr width='30%' align='left'/>


<p><b><a name='EMPerturbationType'></a>EMPerturbationType</b>
<br/><i>Section</i>: Linear Response::Polarizabilities
<br/><i>Type</i>: integer
<br/><i>Default</i>: electric
<br/><br> Which perturbation to consider for electromagnetic linear response.

<br/><i>Options</i>:
<ul>
<li><b>none</b>:  Zero perturbation, for use in testing.
</li>
<li><b>electric</b>:  Electric perturbation used to calculate electric polarizabilities
 and hyperpolarizabilities.
</li>
<li><b>magnetic</b>:  Magnetic perturbation used to calculate magnetic susceptibilities.
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='EMWavefunctionsFromScratch'></a>EMWavefunctionsFromScratch</b>
<br/><i>Section</i>: Linear Response::Polarizabilities
<br/><i>Type</i>: logical
<br/><i>Default</i>: false
<br/><br> Do not use saved linear-response wavefunctions from a previous run as starting guess.
 Instead initialize to zero as in <tt>FromScratch</tt>, but restart densities will still
 be used. Restart wavefunctions from a very different frequency can hinder convergence.

</p><hr width='30%' align='left'/>


<p><b><a name='vdWNPoints'></a>vdWNPoints</b>
<br/><i>Section</i>: Linear Response::Polarizabilities
<br/><i>Type</i>: integer
<br/><i>Default</i>: 6
<br/><br> How many points to use in the Gauss-Legendre integration to obtain the
 van der Waals coefficients.

</p><hr width='30%' align='left'/>

<a name='Linear Response::SCF in LR calculations'</a>
<H2>Linear Response::SCF in LR calculations</H2>


<p><b><a name='LRConvAbsDens'></a>LRConvAbsDens</b>
<br/><i>Section</i>: Linear Response::SCF in LR calculations
<br/><i>Type</i>: float
<br/><i>Default</i>: 1e-5
<br/><br> The tolerance in the absolute variation of the density response, to determine if
 the SCF for linear response is converged.
 \(\varepsilon = \int {\rm d}^3r \left| \rho^{out}(\bf r) -\rho^{inp}(\bf r) \right|\).
 A zero value means do not use this criterion.

</p><hr width='30%' align='left'/>


<p><b><a name='LRConvRelDens'></a>LRConvRelDens</b>
<br/><i>Section</i>: Linear Response::SCF in LR calculations
<br/><i>Type</i>: float
<br/><i>Default</i>: 0.0
<br/><br> The tolerance in the relative variation of the density response, to determine if
 the SCF for linear response is converged.
 \(\varepsilon = \frac{1}{N_{\rm elec}}\) <tt>LRConvAbsDens</tt>.
 A zero value means do not use this criterion.

</p><hr width='30%' align='left'/>


<p><b><a name='LRMaximumIter'></a>LRMaximumIter</b>
<br/><i>Section</i>: Linear Response::SCF in LR calculations
<br/><i>Type</i>: integer
<br/><i>Default</i>: 200
<br/><br> The maximum number of SCF iterations to calculate response.

</p><hr width='30%' align='left'/>


<p><b><a name='LRTolAdaptiveFactor'></a>LRTolAdaptiveFactor</b>
<br/><i>Section</i>: Linear Response::SCF in LR calculations
<br/><i>Type</i>: float
<br/><i>Default</i>: 0.1
<br/><br> This factor controls how much the tolerance is decreased
 during the self-consistency process. Smaller values mean that
 tolerance is decreased faster.

</p><hr width='30%' align='left'/>


<p><b><a name='LRTolIterWindow'></a>LRTolIterWindow</b>
<br/><i>Section</i>: Linear Response::SCF in LR calculations
<br/><i>Type</i>: float
<br/><i>Default</i>: 10
<br/><br> Number of iterations necessary to reach the final tolerance.

</p><hr width='30%' align='left'/>


<p><b><a name='LRTolScheme'></a>LRTolScheme</b>
<br/><i>Section</i>: Linear Response::SCF in LR calculations
<br/><i>Type</i>: integer
<br/><i>Default</i>: tol_adaptive
<br/><br> The scheme used to adjust the tolerance of the solver during
 the SCF iteration. For <tt>kdotp</tt> and magnetic <tt>em_resp</tt> modes, or
 whenever <tt>HamiltonianVariation = V_ext_only</tt>, the
 scheme is set to <tt>tol_fixed</tt>, and this variable is ignored.

<br/><i>Options</i>:
<ul>
<li><b>tol_fixed</b>:  The solver tolerance is fixed for all the iterations; this
 improves convergence but increases the computational cost
</li>
<li><b>tol_adaptive</b>:  The tolerance is increased according to the level of
 convergence of the SCF.
</li>
<li><b>tol_linear</b>:  The tolerance decreases linearly for the first <tt>LRTolIterWindow</tt> iterations.
</li>
<li><b>tol_exp</b>:  The tolerance decreases exponentially for the first <tt>LRTolIterWindow</tt> iterations.
</li>
</ul>
</p><hr width='30%' align='left'/>

<a name='Linear Response::Solver'</a>
<H2>Linear Response::Solver</H2>


<p><b><a name='LRTolFinalTol'></a>LRTolFinalTol</b>
<br/><i>Section</i>: Linear Response::Solver
<br/><i>Type</i>: float
<br/><i>Default</i>: 1e-6
<br/><br> This is the tolerance to determine that the linear solver has converged.

</p><hr width='30%' align='left'/>


<p><b><a name='LRTolInitTol'></a>LRTolInitTol</b>
<br/><i>Section</i>: Linear Response::Solver
<br/><i>Type</i>: float
<br/><i>Default</i>: 1e-2
<br/><br> This is the tolerance to determine that the linear solver has converged,
 for the first SCF iteration. Ignored if <tt>LRTolScheme = fixed</tt>.

</p><hr width='30%' align='left'/>


<p><b><a name='LinearSolver'></a>LinearSolver</b>
<br/><i>Section</i>: Linear Response::Solver
<br/><i>Type</i>: integer
<br/><i>Default</i>: qmr_symmetric
<br/><br> Method for solving linear equations, which occur for Sternheimer linear
 response and OEP. The solvers vary in speed, reliability (ability to
 converge), and domain of applicability. QMR solvers are most reliable.

<br/><i>Options</i>:
<ul>
<li><b>idrs</b>:  This is the "Induced Dimension Reduction", IDR(s) (for s=4). IDR(s) is a robust and efficient short recurrence
 Krylov subspace method for solving large nonsymmetric systems of linear equations. It is described in
 [Peter Sonneveld and Martin B. van Gijzen, SIAM J. Sci. Comput. 31, 1035 (2008)]. We have adapted the code
 released by M. B. van Gizjen [http://ta.twi.tudelft.nl/nw/users/gijzen/IDR.html].
</li>
<li><b>bicgstab</b>:  Biconjugate gradients stabilized. Slower than <tt>cg</tt>, but more reliable.
 General matrices.
</li>
<li><b>cg</b>:  Conjugate gradients. Fast but unreliable. Hermitian matrices only
 (no eta in Sternheimer).
</li>
<li><b>multigrid</b>:  Multigrid solver, currently only Gauss-Jacobi (experimental).
 Slow, but fairly reliable. General matrices.
</li>
<li><b>qmr_symmetric</b>:  Quasi-minimal residual solver, for (complex) symmetric matrices. [Real symmetric
 is equivalent to Hermitian.] Slightly slower than <tt>bicgstab</tt> but more reliable.
 For Sternheimer, must be real wavefunctions, but can have eta.
</li>
<li><b>qmr_symmetrized</b>:  Quasi-minimal residual solver, using the symmetrized form \(A^\dagger A x = A^\dagger y\) instead of
 \(A x = y\). Reliable but very slow. General matrices.
</li>
<li><b>qmr_dotp</b>:  Quasi-minimal residual solver, for Hermitian matrices, using the
 symmetric algorithm with conjugated dot product (experimental). Slightly slower than <tt>bicgstab</tt>
 but more reliable. Can always be used in Sternheimer.
</li>
<li><b>qmr_general</b>:  Quasi-minimal residual solver, for general matrices, using the
 most general form of the algorithm. Slow and unreliable.
</li>
<li><b>sos</b>:  Sum over states: the Sternheimer equation is solved by using
 the explicit solution in terms of the ground-state
 wavefunctions. You need unoccupied states to use this method.
 Unlike the other methods, may not give the correct answer.
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='LinearSolverMaxIter'></a>LinearSolverMaxIter</b>
<br/><i>Section</i>: Linear Response::Solver
<br/><i>Type</i>: integer
<br/><i>Default</i>: 1000
<br/><br> Maximum number of iterations the linear solver does, even if
 convergence is not achieved.

</p><hr width='30%' align='left'/>

<a name='Linear Response::Static Polarization'</a>
<H2>Linear Response::Static Polarization</H2>


<p><b><a name='EMCalcDiagonalField'></a>EMCalcDiagonalField</b>
<br/><i>Section</i>: Linear Response::Static Polarization
<br/><i>Type</i>: logical
<br/><i>Default</i>: true
<br/><br> Calculate <i>yz</i>-field for \(\beta_{xyz}\) hyperpolarizability, which is sometimes harder to converge.
 Only applies if <tt>ResponseMethod = finite_differences</tt>.

</p><hr width='30%' align='left'/>


<p><b><a name='EMStartDensityIsZeroField'></a>EMStartDensityIsZeroField</b>
<br/><i>Section</i>: Linear Response::Static Polarization
<br/><i>Type</i>: logical
<br/><i>Default</i>: true
<br/><br> Use the charge density from the zero-field calculation as the starting density for
 SCF calculations with applied fields. For small fields, this will be fastest.
 If there is trouble converging with larger fields, set to false,
 to initialize the calculation for each field from scratch, as specified by the LCAO variables.
 Only applies if <tt>ResponseMethod = finite_differences</tt>.

</p><hr width='30%' align='left'/>


<p><b><a name='EMStaticElectricField'></a>EMStaticElectricField</b>
<br/><i>Section</i>: Linear Response::Static Polarization
<br/><i>Type</i>: float
<br/><i>Default</i>: 0.01 a.u.
<br/><br> Magnitude of the static electric field used to calculate the static polarizability,
 if <tt>ResponseMethod = finite_differences</tt>.

</p><hr width='30%' align='left'/>


<p><b><a name='EMVerbose'></a>EMVerbose</b>
<br/><i>Section</i>: Linear Response::Static Polarization
<br/><i>Type</i>: logical
<br/><i>Default</i>: false
<br/><br> Write full SCF output.
 Only applies if <tt>ResponseMethod = finite_differences</tt>.

</p><hr width='30%' align='left'/>


<p><b><a name='EMWriteRestartDensities'></a>EMWriteRestartDensities</b>
<br/><i>Section</i>: Linear Response::Static Polarization
<br/><i>Type</i>: logical
<br/><i>Default</i>: true
<br/><br> Write density after each calculation for restart, rather than just the resulting electronic dipole moment.
 Only applies if <tt>ResponseMethod = finite_differences</tt>. Restarting from calculations at smaller
 fields can be helpful if there are convergence problems.

</p><hr width='30%' align='left'/>

<a name='Linear Response::Sternheimer'</a>
<H2>Linear Response::Sternheimer</H2>


<p><b><a name='HamiltonianVariation'></a>HamiltonianVariation</b>
<br/><i>Section</i>: Linear Response::Sternheimer
<br/><i>Type</i>: integer
<br/><i>Default</i>: hartree+fxc
<br/><br> The terms to be considered in the variation of the
 Hamiltonian. The external potential (V_ext) is always considered. The default is to include
 also the exchange-correlation and Hartree terms, which fully
 takes into account local fields.
 Just <tt>hartree</tt> gives you the random-phase approximation (RPA).
 If you want to choose the exchange-correlation kernel, use the variable
 <tt>XCKernel</tt>. For <tt>kdotp</tt> and magnetic <tt>em_resp</tt> modes,
 or if <tt>TheoryLevel = independent_particles</tt>,
 the value <tt>V_ext_only</tt> is used and this variable is ignored.

<br/><i>Options</i>:
<ul>
<li><b>V_ext_only</b>:  Neither Hartree nor XC potentials included.
</li>
<li><b>hartree</b>:  The variation of the Hartree potential only.
</li>
<li><b>fxc</b>:  The exchange-correlation kernel (the variation of the
 exchange-correlation potential) only.
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='PhotonEta'></a>PhotonEta</b>
<br/><i>Section</i>: Linear Response::Sternheimer
<br/><i>Type</i>: float
<br/><i>Default</i>: 0.0000367
<br/><br> This variable provides the value for the broadening of the photonic spectra
 when the coupling of electrons to photons is enabled in the frequency-dependent Sternheimer equation

</p><hr width='30%' align='left'/>


<p><b><a name='Preorthogonalization'></a>Preorthogonalization</b>
<br/><i>Section</i>: Linear Response::Sternheimer
<br/><i>Type</i>: logical
<br/><br> Whether initial linear-response wavefunctions should be orthogonalized
 or not against the occupied states, at the start of each SCF cycle.
 Default is true only if <tt>SmearingFunction = semiconducting</tt>,
 or if the <tt>Occupations</tt> block specifies all full or empty states,
 and we are not solving for linear response in the occupied subspace too.

</p><hr width='30%' align='left'/>

<a name='Linear Response::Vibrational Modes'</a>
<H2>Linear Response::Vibrational Modes</H2>


<p><b><a name='CalcInfrared'></a>CalcInfrared</b>
<br/><i>Section</i>: Linear Response::Vibrational Modes
<br/><i>Type</i>: logical
<br/><i>Default</i>: true
<br/><br> If set to true, infrared intensities (and born charges) will be calculated
 and written in <tt>vib_modes/infrared</tt>.

</p><hr width='30%' align='left'/>


<p><b><a name='CalcNormalModeWfs'></a>CalcNormalModeWfs</b>
<br/><i>Section</i>: Linear Response::Vibrational Modes
<br/><i>Type</i>: logical
<br/><i>Default</i>: false
<br/><br> If set to true, the response wavefunctions for each normal mode will be calculated
 and written in directory <tt>restart/vib_modes/phn_nm_wfs_XXXXX</tt>.
 This part is time-consuming and not parallel, but not needed for most purposes.

</p><hr width='30%' align='left'/>


<p><b><a name='Displacement'></a>Displacement</b>
<br/><i>Section</i>: Linear Response::Vibrational Modes
<br/><i>Type</i>: float
<br/><i>Default</i>: 0.01 a.u.
<br/><br> When calculating phonon properties by finite differences (<tt>CalculationMode = vib_modes,
 ResponseMethod = finite_differences</tt>),
 <tt>Displacement</tt> controls how much the atoms are to be moved in order to calculate the
 dynamical matrix.

</p><hr width='30%' align='left'/>


<p><b><a name='SymmetrizeDynamicalMatrix'></a>SymmetrizeDynamicalMatrix</b>
<br/><i>Section</i>: Linear Response::Vibrational Modes
<br/><i>Type</i>: logical
<br/><i>Default</i>: true
<br/><br> If set to true, all entries of the dynamical matrix will be calculated and then
 the matrix will be symmetrized to enforce \(D_{ij} = D_{ji}\). If set to false,
 only the upper half of the matrix will be calculated.

</p><hr width='30%' align='left'/>

</body>
</html>